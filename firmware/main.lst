   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	EVENT_USB_Device_ConfigurationChanged
  15               	EVENT_USB_Device_ConfigurationChanged:
  16               	.LFB57:
  17               		.file 1 "Framework.h"
   1:Framework.h   **** #pragma once
   2:Framework.h   **** #define F_CPU 32000000UL
   3:Framework.h   **** 
   4:Framework.h   **** // includes
   5:Framework.h   **** #include <avr/interrupt.h>
   6:Framework.h   **** #include <util/delay.h>
   7:Framework.h   **** #include "Descriptors.h"
   8:Framework.h   **** #include "usb/usb.h"
   9:Framework.h   **** #include "usb/usb_pipe.h"
  10:Framework.h   **** #include <avr/eeprom.h>
  11:Framework.h   **** #include <avr/io.h>
  12:Framework.h   **** 
  13:Framework.h   **** USB_PIPE(ep_in, 0x81 | USB_EP_PP, USB_EP_TYPE_BULK_gc, 64, 8, PIPE_ENABLE_FLUSH);
  14:Framework.h   **** 
  15:Framework.h   **** bool timeout_or_sampling_no_longer_enabled = 0;
  16:Framework.h   **** 
  17:Framework.h   **** // Queue a byte to be sent over the bulk EP. Blocks if the buffer is full
  18:Framework.h   **** static inline void send_byte(uint8_t byte){
  19:Framework.h   ****     // this should never actually block if your buffer is big enough
  20:Framework.h   ****     while (!usb_pipe_can_write(&ep_in));
  21:Framework.h   **** 	usb_pipe_write_byte(&ep_in, byte);
  22:Framework.h   **** }
  23:Framework.h   **** 
  24:Framework.h   **** // Sends a break to end the USB read and flushes the USB pipe
  25:Framework.h   **** static inline void break_and_flush(){
  26:Framework.h   ****     usb_pipe_flush(&ep_in);
  27:Framework.h   ****     USB.INTFLAGSBSET = USB_TRNIF_bm;
  28:Framework.h   ****     while (!usb_pipe_can_write(&ep_in)){
  29:Framework.h   ****         if (timeout_or_sampling_no_longer_enabled){
  30:Framework.h   ****             usb_pipe_reset(&ep_in);
  31:Framework.h   ****             return;
  32:Framework.h   ****         }
  33:Framework.h   ****     }
  34:Framework.h   **** } 
  35:Framework.h   **** 
  36:Framework.h   **** void EVENT_USB_Device_ConfigurationChanged(uint8_t config){
  18               		.loc 1 36 0
  19               		.cfi_startproc
  20               	.LVL0:
  21               	/* prologue: function */
  22               	/* frame size = 0 */
  23               	/* stack size = 0 */
  24               	.L__stack_usage = 0
  25               	.LBB220:
  26               	.LBB221:
  27               		.file 2 "usb/usb_pipe.h"
   1:usb/usb_pipe.h **** #include "pipe.h"
   2:usb/usb_pipe.h **** #include "usb.h"
   3:usb/usb_pipe.h **** 
   4:usb/usb_pipe.h **** #include <util/atomic.h>
   5:usb/usb_pipe.h **** #ifndef PIPE_ATOMIC
   6:usb/usb_pipe.h **** #define PIPE_ATOMIC ATOMIC_RESTORESTATE
   7:usb/usb_pipe.h **** #endif 
   8:usb/usb_pipe.h **** 
   9:usb/usb_pipe.h **** typedef struct USB_Pipe_data{
  10:usb/usb_pipe.h **** 	bool bank;
  11:usb/usb_pipe.h **** 	uint8_t flush;
  12:usb/usb_pipe.h **** 	uint16_t packet_offset; // Index into current packet for byte mode
  13:usb/usb_pipe.h **** } USB_Pipe_data;
  14:usb/usb_pipe.h **** 
  15:usb/usb_pipe.h **** // Immutable part, constant-folded at compile time
  16:usb/usb_pipe.h **** typedef struct USB_Pipe{
  17:usb/usb_pipe.h **** 	uint8_t ep;
  18:usb/usb_pipe.h **** 	uint8_t type;
  19:usb/usb_pipe.h **** 	USB_Pipe_data* data;
  20:usb/usb_pipe.h **** 	const Pipe* pipe;
  21:usb/usb_pipe.h **** 	uint8_t features;
  22:usb/usb_pipe.h **** } USB_Pipe;
  23:usb/usb_pipe.h **** 
  24:usb/usb_pipe.h **** #define PIPE_ENABLE_FLUSH (1<<0)
  25:usb/usb_pipe.h **** 
  26:usb/usb_pipe.h **** #define USB_PIPE(NAME, EPNO, TYPE, PACKET_SIZE, BUFFER_PACKETS, FEATURES) \
  27:usb/usb_pipe.h **** 	PIPE(NAME##_pipe, (BUFFER_PACKETS), (PACKET_SIZE),               \
  28:usb/usb_pipe.h **** 		((EPNO)&USB_EP_IN)?0:2,                      \
  29:usb/usb_pipe.h **** 		((EPNO)&USB_EP_IN)?2:0                       \
  30:usb/usb_pipe.h **** 	);                                               \
  31:usb/usb_pipe.h **** 	USB_Pipe_data NAME##_data = {      \
  32:usb/usb_pipe.h **** 		.bank = 0,                   \
  33:usb/usb_pipe.h **** 		.flush = 0,                    \
  34:usb/usb_pipe.h **** 	};                                 \
  35:usb/usb_pipe.h **** 	const static USB_Pipe NAME = {     \
  36:usb/usb_pipe.h **** 		.ep = (EPNO),                  \
  37:usb/usb_pipe.h **** 		.type = (TYPE),                \
  38:usb/usb_pipe.h **** 		.data = &(NAME##_data),        \
  39:usb/usb_pipe.h **** 		.pipe = &(NAME##_pipe),        \
  40:usb/usb_pipe.h **** 		.features = (FEATURES),        \
  41:usb/usb_pipe.h **** 	};                                 \
  42:usb/usb_pipe.h **** 
  43:usb/usb_pipe.h **** static inline void usb_pipe_init(const USB_Pipe* p){
  44:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
  28               		.loc 2 44 0
  29 0000 2FB7      		in r18,__SREG__
  30               	.LVL1:
  31               	.LBB222:
  32               	.LBB223:
  33               		.file 3 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h"
   1:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    All rights reserved.
   3:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
   4:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
   7:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  10:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      distribution.
  14:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  15:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      from this software without specific prior written permission.
  18:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  19:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** */
  31:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  32:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** /* $Id: atomic.h 2158 2010-06-10 15:48:28Z joerg_wunsch $ */
  33:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  34:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  37:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #include <avr/io.h>
  38:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #include <avr/interrupt.h>
  39:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  40:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #if !defined(__DOXYGEN__)
  41:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** /* Internal helper functions. */
  42:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  44:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     sei();
  45:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     return 1;
  46:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** }
  47:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  48:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
  49:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
  34               		.loc 3 50 0
  35               	/* #APP */
  36               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
  37 0002 F894      		cli
  38               	 ;  0 "" 2
  39               	.LVL2:
  40               	/* #NOAPP */
  41               	.LBE223:
  42               	.LBE222:
  43               	.LBB224:
  44               	.LBB225:
  45               		.file 4 "usb/pipe.h"
   1:usb/pipe.h    **** // Ring buffer that takes heavy advantage of constant folding
   2:usb/pipe.h    **** #pragma once
   3:usb/pipe.h    **** 
   4:usb/pipe.h    **** #include "Common.h"
   5:usb/pipe.h    **** 
   6:usb/pipe.h    **** // Mutable part, becomes an actual struct
   7:usb/pipe.h    **** typedef struct Pipe_data{
   8:usb/pipe.h    **** 	uint8_t* read_ptr;
   9:usb/pipe.h    **** 	uint8_t* write_ptr;
  10:usb/pipe.h    **** 	int8_t count; // available slots
  11:usb/pipe.h    **** } Pipe_data;
  12:usb/pipe.h    **** 
  13:usb/pipe.h    **** // Immutable part, constant-folded at compile time
  14:usb/pipe.h    **** typedef struct Pipe{
  15:usb/pipe.h    **** 	Pipe_data* data;
  16:usb/pipe.h    **** 	uint8_t* buffer;
  17:usb/pipe.h    **** 	uint8_t  slots;         // Number of slots in the buffer
  18:usb/pipe.h    **** 	uint8_t reserve_read;  // Slots to prevent reading so they are available to writer
  19:usb/pipe.h    **** 	uint8_t reserve_write; // Slots to prevent writing so they are available to reader
  20:usb/pipe.h    **** 	uint16_t size;          // Size of a buffer slot in bytes
  21:usb/pipe.h    **** } Pipe;
  22:usb/pipe.h    **** 
  23:usb/pipe.h    **** #define PIPE_H(NAME, SLOTS, SIZE, RESERVE_READ, RESERVE_WRITE)       \
  24:usb/pipe.h    **** 	extern Pipe_data NAME##_data;         \
  25:usb/pipe.h    **** 	extern uint8_t NAME##_buffer[(SLOTS)*(SIZE)]; \
  26:usb/pipe.h    **** 	const static Pipe NAME = {            \
  27:usb/pipe.h    **** 		.data = &(NAME##_data),           \
  28:usb/pipe.h    **** 		.buffer = &((NAME##_buffer)[0]),  \
  29:usb/pipe.h    **** 		.slots = (SLOTS),                 \
  30:usb/pipe.h    **** 		.size = (SIZE),                   \
  31:usb/pipe.h    **** 		.reserve_read = (RESERVE_READ),   \
  32:usb/pipe.h    **** 		.reserve_write = (RESERVE_WRITE), \
  33:usb/pipe.h    **** 	};
  34:usb/pipe.h    **** 
  35:usb/pipe.h    **** 
  36:usb/pipe.h    **** #define PIPE_C(NAME, SLOTS, SIZE)                   \
  37:usb/pipe.h    **** 	uint8_t NAME##_buffer[(SLOTS)*(SIZE)];           \
  38:usb/pipe.h    **** 	Pipe_data NAME##_data = {                \
  39:usb/pipe.h    **** 		.count = 0,                          \
  40:usb/pipe.h    **** 		.read_ptr = &((NAME##_buffer)[0]),                       \
  41:usb/pipe.h    **** 		.write_ptr = &((NAME##_buffer)[0]),                      \
  42:usb/pipe.h    **** 	};
  43:usb/pipe.h    **** 
  44:usb/pipe.h    **** #define PIPE(NAME, SLOTS, SIZE, RESERVE_READ, RESERVE_WRITE) \
  45:usb/pipe.h    **** 	PIPE_H(NAME, SLOTS, SIZE, RESERVE_READ, RESERVE_WRITE)   \
  46:usb/pipe.h    **** 	PIPE_C(NAME, SLOTS, SIZE)
  47:usb/pipe.h    **** 
  48:usb/pipe.h    **** // Number of slots available to read
  49:usb/pipe.h    **** static inline int8_t pipe_can_read(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  50:usb/pipe.h    **** static inline int8_t pipe_can_read(const Pipe* pipe){
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
  52:usb/pipe.h    **** }
  53:usb/pipe.h    **** 
  54:usb/pipe.h    **** // Number of slots available to write
  55:usb/pipe.h    **** static inline int8_t pipe_can_write(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  56:usb/pipe.h    **** static inline int8_t pipe_can_write(const Pipe* pipe){
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
  58:usb/pipe.h    **** }
  59:usb/pipe.h    **** 
  60:usb/pipe.h    **** static inline uint8_t* pipe_read_ptr(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  61:usb/pipe.h    **** static inline uint8_t* pipe_read_ptr(const Pipe* pipe){
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
  63:usb/pipe.h    **** }
  64:usb/pipe.h    **** 
  65:usb/pipe.h    **** static inline uint8_t* pipe_write_ptr(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  66:usb/pipe.h    **** static inline uint8_t* pipe_write_ptr(const Pipe* pipe){
  67:usb/pipe.h    **** 	return pipe->data->write_ptr;
  68:usb/pipe.h    **** }
  69:usb/pipe.h    **** 
  70:usb/pipe.h    **** static inline void pipe_done_read(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  71:usb/pipe.h    **** static inline void pipe_done_read(const Pipe* pipe){
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
  74:usb/pipe.h    **** 	// Assumes buffer_size % slot_size == 0 and all accesses aligned
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
  77:usb/pipe.h    **** }
  78:usb/pipe.h    **** 
  79:usb/pipe.h    **** static inline void pipe_done_write(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  80:usb/pipe.h    **** static inline void pipe_done_write(const Pipe* pipe){
  81:usb/pipe.h    **** 	pipe->data->count += 1;
  82:usb/pipe.h    **** 	pipe->data->write_ptr += pipe->size;
  83:usb/pipe.h    **** 	// Assumes buffer_size % slot_size == 0 and all accesses aligned
  84:usb/pipe.h    **** 	if (pipe->data->write_ptr == &pipe->buffer[pipe->slots*pipe->size])
  85:usb/pipe.h    **** 		pipe->data->write_ptr = &pipe->buffer[0];
  86:usb/pipe.h    **** }
  87:usb/pipe.h    **** 
  88:usb/pipe.h    **** static inline void pipe_reset(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  89:usb/pipe.h    **** static inline void pipe_reset(const Pipe* pipe){
  90:usb/pipe.h    **** 	pipe->data->count = 0;
  46               		.loc 4 90 0
  47 0004 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
  91:usb/pipe.h    **** 	pipe->data->read_ptr = pipe->data->write_ptr = pipe->buffer;
  48               		.loc 4 91 0
  49 0008 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
  50 000a 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
  51               	.LVL3:
  52 000c 8093 0000 		sts ep_in_pipe_data+2,r24
  53 0010 9093 0000 		sts ep_in_pipe_data+2+1,r25
  54 0014 8093 0000 		sts ep_in_pipe_data,r24
  55 0018 9093 0000 		sts ep_in_pipe_data+1,r25
  56               	.LVL4:
  57               	.LBE225:
  58               	.LBE224:
  59               	.LBB226:
  60               	.LBB227:
  61               	.LBB228:
  62               		.file 5 "usb/usb.h"
   1:usb/usb.h     **** // Minimal USB Stack for ATxmega32a4u and related
   2:usb/usb.h     **** // http://nonolithlabs.com
   3:usb/usb.h     **** // (C) 2011 Kevin Mehall (Nonolith Labs) <km@kevinmehall.net>
   4:usb/usb.h     **** //
   5:usb/usb.h     **** // Heavily borrows from LUFA
   6:usb/usb.h     **** // Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
   7:usb/usb.h     **** //
   8:usb/usb.h     **** // Licensed under the terms of the GNU GPLv3+
   9:usb/usb.h     **** 
  10:usb/usb.h     **** #pragma once
  11:usb/usb.h     **** 
  12:usb/usb.h     **** #include <avr/io.h>
  13:usb/usb.h     **** 
  14:usb/usb.h     **** #define CPU_TO_LE16(x) x
  15:usb/usb.h     **** 
  16:usb/usb.h     **** struct USB_Request_Header;
  17:usb/usb.h     **** typedef struct USB_Request_Header USB_Requst_Header_t;
  18:usb/usb.h     **** 
  19:usb/usb.h     **** #include "StdDescriptors.h"
  20:usb/usb.h     **** #include "StdRequestType.h"
  21:usb/usb.h     **** #include "Events.h"
  22:usb/usb.h     **** 
  23:usb/usb.h     **** #ifndef USB_MAXEP
  24:usb/usb.h     **** 	#define USB_MAXEP 1
  25:usb/usb.h     **** #endif
  26:usb/usb.h     **** 
  27:usb/usb.h     **** #ifndef USB_EP0SIZE
  28:usb/usb.h     **** 	#define EP0SIZE 64
  29:usb/usb.h     **** #endif
  30:usb/usb.h     **** 
  31:usb/usb.h     **** typedef union USB_EP_pair{
  32:usb/usb.h     **** 	union{
  33:usb/usb.h     **** 		struct{
  34:usb/usb.h     **** 			USB_EP_t out;
  35:usb/usb.h     **** 			USB_EP_t in;
  36:usb/usb.h     **** 		};
  37:usb/usb.h     **** 		USB_EP_t ep[2];
  38:usb/usb.h     **** 	};
  39:usb/usb.h     **** } ATTR_PACKED USB_EP_pair_t;
  40:usb/usb.h     **** 
  41:usb/usb.h     **** extern uint8_t ep0_buf_in[USB_EP0SIZE];
  42:usb/usb.h     **** extern uint8_t ep0_buf_out[USB_EP0SIZE];
  43:usb/usb.h     **** extern USB_EP_pair_t endpoints[USB_MAXEP+1];
  44:usb/usb.h     **** 
  45:usb/usb.h     **** /** String descriptor index for the device's unique serial number string descriptor within the devi
  46:usb/usb.h     ****  *  This unique serial number is used by the host to associate resources to the device (such as dri
  47:usb/usb.h     ****  *  number allocations) to a device regardless of the port it is plugged in to on the host. Some mi
  48:usb/usb.h     ****  *  a unique serial number internally, and setting the device descriptors serial number string inde
  49:usb/usb.h     ****  *  will cause it to use the internal serial number.
  50:usb/usb.h     ****  *
  51:usb/usb.h     ****  *  On unsupported devices, this will evaluate to \ref NO_DESCRIPTOR and so will force the host to 
  52:usb/usb.h     ****  *  number for the device.
  53:usb/usb.h     ****  */
  54:usb/usb.h     **** #define USE_INTERNAL_SERIAL            0xDC
  55:usb/usb.h     **** 
  56:usb/usb.h     **** /** Length of the device's unique internal serial number, in bits, if present on the selected micro
  57:usb/usb.h     ****  *  model.
  58:usb/usb.h     ****  */
  59:usb/usb.h     **** #define INTERNAL_SERIAL_LENGTH_BITS    (8 * (1 + (offsetof(NVM_PROD_SIGNATURES_t, COORDY1) - offset
  60:usb/usb.h     **** 
  61:usb/usb.h     **** /** Start address of the internal serial number, in the appropriate address space, if present on th
  62:usb/usb.h     ****  *  model.
  63:usb/usb.h     ****  */
  64:usb/usb.h     **** #define INTERNAL_SERIAL_START_ADDRESS  offsetof(NVM_PROD_SIGNATURES_t, LOTNUM0)
  65:usb/usb.h     **** 
  66:usb/usb.h     **** /* Enums: */
  67:usb/usb.h     **** 	/** Enum for the various states of the USB Device state machine. Only some states are
  68:usb/usb.h     **** 	 *  implemented in the LUFA library - other states are left to the user to implement.
  69:usb/usb.h     **** 	 *
  70:usb/usb.h     **** 	 *  For information on each possible USB device state, refer to the USB 2.0 specification.
  71:usb/usb.h     **** 	 *
  72:usb/usb.h     **** 	 *  \see \ref USB_DeviceState, which stores the current device state machine state.
  73:usb/usb.h     **** 	 */
  74:usb/usb.h     **** 	enum USB_Device_States_t
  75:usb/usb.h     **** 	{
  76:usb/usb.h     **** 		DEVICE_STATE_Unattached                   = 0, /**< Internally implemented by the library. This s
  77:usb/usb.h     **** 		                                                *   that the device is not currently connected to
  78:usb/usb.h     **** 		                                                */
  79:usb/usb.h     **** 		DEVICE_STATE_Powered                      = 1, /**< Internally implemented by the library. This s
  80:usb/usb.h     **** 		                                                *   that the device is connected to a host, but e
  81:usb/usb.h     **** 		                                                *   yet begun.
  82:usb/usb.h     **** 		                                                */
  83:usb/usb.h     **** 		DEVICE_STATE_Default                      = 2, /**< Internally implemented by the library. This s
  84:usb/usb.h     **** 		                                                *   that the device's USB bus has been reset by t
  85:usb/usb.h     **** 		                                                *   now waiting for the host to begin the enumera
  86:usb/usb.h     **** 		                                                */
  87:usb/usb.h     **** 		DEVICE_STATE_Addressed                    = 3, /**< Internally implemented by the library. This s
  88:usb/usb.h     **** 		                                                *   that the device has been addressed by the USB
  89:usb/usb.h     **** 		                                                *   yet configured.
  90:usb/usb.h     **** 		                                                */
  91:usb/usb.h     **** 		DEVICE_STATE_Configured                   = 4, /**< May be implemented by the user project. This 
  92:usb/usb.h     **** 		                                                *   that the device has been enumerated by the ho
  93:usb/usb.h     **** 		                                                *   for USB communications to begin.
  94:usb/usb.h     **** 		                                                */
  95:usb/usb.h     **** 		DEVICE_STATE_Suspended                    = 5, /**< May be implemented by the user project. This 
  96:usb/usb.h     **** 		                                                *   that the USB bus has been suspended by the ho
  97:usb/usb.h     **** 		                                                *   should power down to a minimal power level un
  98:usb/usb.h     **** 		                                                *   resumed.
  99:usb/usb.h     **** 		                                                */
 100:usb/usb.h     **** 	};
 101:usb/usb.h     **** 
 102:usb/usb.h     **** #define USB_EP_size_to_gc(x)  ((x <= 8   )?USB_EP_BUFSIZE_8_gc:\
 103:usb/usb.h     ****                                (x <= 16  )?USB_EP_BUFSIZE_16_gc:\
 104:usb/usb.h     ****                                (x <= 32  )?USB_EP_BUFSIZE_32_gc:\
 105:usb/usb.h     ****                                (x <= 64  )?USB_EP_BUFSIZE_64_gc:\
 106:usb/usb.h     ****                                (x <= 128 )?USB_EP_BUFSIZE_128_gc:\
 107:usb/usb.h     ****                                (x <= 256 )?USB_EP_BUFSIZE_256_gc:\
 108:usb/usb.h     ****                                (x <= 512 )?USB_EP_BUFSIZE_512_gc:\
 109:usb/usb.h     ****                                            USB_EP_BUFSIZE_1023_gc)
 110:usb/usb.h     **** 
 111:usb/usb.h     **** #define USB_EP_IN 0x80
 112:usb/usb.h     **** 
 113:usb/usb.h     **** // Flag in the endpoint address to indicate that the endpoint should use
 114:usb/usb.h     **** // PingPong (double buffer) mode. This is not actually part of the endpoint
 115:usb/usb.h     **** // address as seen by the host. If PP is enabled, this flag needs to be part
 116:usb/usb.h     **** // of the address passed to all USB_EP_* functions.
 117:usb/usb.h     **** #define USB_EP_PP 0x40
 118:usb/usb.h     **** 	
 119:usb/usb.h     **** extern volatile uint8_t USB_DeviceState;
 120:usb/usb.h     **** extern volatile uint8_t USB_Device_ConfigurationNumber;
 121:usb/usb.h     **** 
 122:usb/usb.h     **** /** Configure the XMEGA's clock for use with USB.  */
 123:usb/usb.h     **** void USB_ConfigureClock(void);
 124:usb/usb.h     **** 
 125:usb/usb.h     **** /** Initialize USB functionality */
 126:usb/usb.h     **** void USB_Init(void);
 127:usb/usb.h     **** void USB_ResetInterface(void);
 128:usb/usb.h     **** 
 129:usb/usb.h     **** #define _USB_EP(epaddr) \
 130:usb/usb.h     **** 	USB_EP_pair_t* pair = &endpoints[(epaddr & 0x3F)]; \
 131:usb/usb.h     **** 	USB_EP_t* e __attribute__ ((unused)) = &pair->ep[!!(epaddr&0x80)]; \
 132:usb/usb.h     **** 	
 133:usb/usb.h     **** #define _USB_EP_OTHER(epaddr) \
 134:usb/usb.h     **** 	USB_EP_t* other = &pair->ep[!(epaddr&0x80)]
 135:usb/usb.h     **** 	
 136:usb/usb.h     **** #define _USB_EP_BANK(epaddr, bank) \
 137:usb/usb.h     **** 	USB_EP_t* b = &pair->ep[!!(epaddr&0x80) != bank]
 138:usb/usb.h     **** 
 139:usb/usb.h     **** inline void USB_ep_init(uint8_t ep, uint8_t type, uint16_t bufsize) ATTR_ALWAYS_INLINE;
 140:usb/usb.h     **** inline void USB_ep_init(uint8_t ep, uint8_t type, uint16_t bufsize){
 141:usb/usb.h     **** 	_USB_EP(ep);
 142:usb/usb.h     **** 	if (ep & USB_EP_PP){
 143:usb/usb.h     **** 		_USB_EP_OTHER(ep);
 144:usb/usb.h     **** 		e->STATUS = USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm;
  63               		.loc 5 144 0
  64 001c 80E0      		ldi r24,lo8(endpoints+24)
  65 001e 90E0      		ldi r25,hi8(endpoints+24)
  66 0020 36E0      		ldi r19,lo8(6)
  67 0022 3093 0000 		sts endpoints+24,r19
 145:usb/usb.h     **** 		e->CTRL = type | USB_EP_size_to_gc(bufsize) | USB_EP_PINGPONG_bm;
  68               		.loc 5 145 0
  69 0026 33E9      		ldi r19,lo8(-109)
  70 0028 3093 0000 		sts endpoints+25,r19
 146:usb/usb.h     **** 		other->CTRL = 0;
  71               		.loc 5 146 0
  72 002c FC01      		movw r30,r24
  73 002e 3797      		sbiw r30,7
  74 0030 1082      		st Z,__zero_reg__
 147:usb/usb.h     **** 		other->STATUS = USB_EP_BUSNACK0_bm;
  75               		.loc 5 147 0
  76 0032 0897      		sbiw r24,8
  77 0034 32E0      		ldi r19,lo8(2)
  78 0036 FC01      		movw r30,r24
  79 0038 3083      		st Z,r19
  80               	.LBE228:
  81               	.LBE227:
  82               	.LBE226:
  45:usb/usb_pipe.h **** 		pipe_reset(p->pipe);
  46:usb/usb_pipe.h **** 		USB_ep_init(p->ep, p->type, p->pipe->size);
  47:usb/usb_pipe.h **** 		p->data->bank = 0;
  83               		.loc 2 47 0
  84 003a 1092 0000 		sts ep_in_data,__zero_reg__
  48:usb/usb_pipe.h **** 		p->data->flush = 0;
  85               		.loc 2 48 0
  86 003e 1092 0000 		sts ep_in_data+1,__zero_reg__
  49:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
  87               		.loc 2 49 0
  88 0042 1092 0000 		sts ep_in_data+2,__zero_reg__
  89 0046 1092 0000 		sts ep_in_data+2+1,__zero_reg__
  90               	.LVL5:
  91               	.LBB229:
  92               	.LBB230:
  51:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     return 1;
  52:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** }
  53:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  54:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
  55:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  56:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     sei();
  57:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  58:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     (void)__s;
  59:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** }
  60:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  61:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ void __iCliParam(const uint8_t *__s)
  62:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  63:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
  64:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  65:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     (void)__s;
  66:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** }
  67:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  68:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ void __iRestore(const  uint8_t *__s)
  69:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
  93               		.loc 3 70 0
  94 004a 2FBF      		out __SREG__,r18
  71:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  95               		.loc 3 71 0
  96               	/* epilogue start */
  97               	.LBE230:
  98               	.LBE229:
  99               	.LBE221:
 100               	.LBE220:
  37:Framework.h   **** 	usb_pipe_init(&ep_in);
  38:Framework.h   **** }
 101               		.loc 1 38 0
 102 004c 0895      		ret
 103               		.cfi_endproc
 104               	.LFE57:
 106               	.global	__vector_125
 108               	__vector_125:
 109               	.LFB58:
  39:Framework.h   **** 
  40:Framework.h   **** ISR(USB_BUSEVENT_vect){
 110               		.loc 1 40 0
 111               		.cfi_startproc
 112 004e 1F92      		push r1
 113               	.LCFI0:
 114               		.cfi_def_cfa_offset 3
 115               		.cfi_offset 1, -2
 116 0050 0F92      		push r0
 117               	.LCFI1:
 118               		.cfi_def_cfa_offset 4
 119               		.cfi_offset 0, -3
 120 0052 0FB6      		in r0,__SREG__
 121 0054 0F92      		push r0
 122 0056 1124      		clr __zero_reg__
 123 0058 2F93      		push r18
 124               	.LCFI2:
 125               		.cfi_def_cfa_offset 5
 126               		.cfi_offset 18, -4
 127 005a 3F93      		push r19
 128               	.LCFI3:
 129               		.cfi_def_cfa_offset 6
 130               		.cfi_offset 19, -5
 131 005c 4F93      		push r20
 132               	.LCFI4:
 133               		.cfi_def_cfa_offset 7
 134               		.cfi_offset 20, -6
 135 005e 5F93      		push r21
 136               	.LCFI5:
 137               		.cfi_def_cfa_offset 8
 138               		.cfi_offset 21, -7
 139 0060 6F93      		push r22
 140               	.LCFI6:
 141               		.cfi_def_cfa_offset 9
 142               		.cfi_offset 22, -8
 143 0062 7F93      		push r23
 144               	.LCFI7:
 145               		.cfi_def_cfa_offset 10
 146               		.cfi_offset 23, -9
 147 0064 8F93      		push r24
 148               	.LCFI8:
 149               		.cfi_def_cfa_offset 11
 150               		.cfi_offset 24, -10
 151 0066 9F93      		push r25
 152               	.LCFI9:
 153               		.cfi_def_cfa_offset 12
 154               		.cfi_offset 25, -11
 155 0068 AF93      		push r26
 156               	.LCFI10:
 157               		.cfi_def_cfa_offset 13
 158               		.cfi_offset 26, -12
 159 006a BF93      		push r27
 160               	.LCFI11:
 161               		.cfi_def_cfa_offset 14
 162               		.cfi_offset 27, -13
 163 006c EF93      		push r30
 164               	.LCFI12:
 165               		.cfi_def_cfa_offset 15
 166               		.cfi_offset 30, -14
 167 006e FF93      		push r31
 168               	.LCFI13:
 169               		.cfi_def_cfa_offset 16
 170               		.cfi_offset 31, -15
 171               	/* prologue: Signal */
 172               	/* frame size = 0 */
 173               	/* stack size = 15 */
 174               	.L__stack_usage = 15
  41:Framework.h   **** 	if (USB.INTFLAGSACLR & USB_SOFIF_bm){
 175               		.loc 1 41 0
 176 0070 E0EC      		ldi r30,lo8(1216)
 177 0072 F4E0      		ldi r31,hi8(1216)
 178 0074 8091 CA04 		lds r24,1226
 179 0078 87FD      		sbrc r24,7
 180 007a 00C0      		rjmp .L8
  42:Framework.h   **** 		USB.INTFLAGSACLR = USB_SOFIF_bm;
  43:Framework.h   **** 	}else if (USB.INTFLAGSACLR & (USB_CRCIF_bm | USB_UNFIF_bm | USB_OVFIF_bm)){
 181               		.loc 1 43 0
 182 007c 8091 CA04 		lds r24,1226
 183 0080 8E70      		andi r24,lo8(14)
 184 0082 01F4      		brne .L9
  44:Framework.h   **** 		USB.INTFLAGSACLR = (USB_CRCIF_bm | USB_UNFIF_bm | USB_OVFIF_bm);
  45:Framework.h   **** 	}else if (USB.INTFLAGSACLR & USB_STALLIF_bm){
 185               		.loc 1 45 0
 186 0084 8091 CA04 		lds r24,1226
 187 0088 80FD      		sbrc r24,0
 188 008a 00C0      		rjmp .L10
  46:Framework.h   **** 		USB.INTFLAGSACLR = USB_STALLIF_bm;
  47:Framework.h   **** 	}else{
  48:Framework.h   **** 		USB.INTFLAGSACLR = USB_SUSPENDIF_bm | USB_RESUMEIF_bm | USB_RSTIF_bm;
 189               		.loc 1 48 0
 190 008c 80E7      		ldi r24,lo8(112)
 191 008e 8287      		std Z+10,r24
 192               	.LBB231:
 193               	.LBB232:
 148:usb/usb.h     **** 	}else{
 149:usb/usb.h     **** 		e->STATUS = USB_EP_BUSNACK0_bm;
 150:usb/usb.h     **** 		e->CTRL = type | USB_EP_size_to_gc(bufsize);
 151:usb/usb.h     **** 	}
 152:usb/usb.h     **** }
 153:usb/usb.h     **** 
 154:usb/usb.h     **** inline void USB_ep_cancel(uint8_t ep) ATTR_ALWAYS_INLINE;
 155:usb/usb.h     **** inline void USB_ep_cancel(uint8_t ep){
 156:usb/usb.h     **** 	_USB_EP(ep);
 157:usb/usb.h     **** 	if (ep & USB_EP_PP){
 158:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 159:usb/usb.h     **** 		LACR16(&e->STATUS, USB_EP_BANK_bm);
 160:usb/usb.h     **** 	}else{
 161:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm);
 162:usb/usb.h     **** 	}
 163:usb/usb.h     **** }
 164:usb/usb.h     **** 
 165:usb/usb.h     **** inline void USB_ep_start_bank(uint8_t ep, uint8_t bank, uint8_t* addr, uint16_t size){
 166:usb/usb.h     **** 	_USB_EP(ep);
 167:usb/usb.h     **** 	_USB_EP_BANK(ep, bank);
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 170:usb/usb.h     **** 	
 171:usb/usb.h     **** 	//TODO: the OVF, STALL, and TRNCOMPL flags are in b->STATUS. Clear them if anyone cares.
 172:usb/usb.h     **** 
 173:usb/usb.h     **** 	if (bank==0){
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 175:usb/usb.h     **** 	}else{
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 177:usb/usb.h     **** 	}
 178:usb/usb.h     **** }
 179:usb/usb.h     **** 
 180:usb/usb.h     **** inline void USB_ep_out_start(uint8_t ep, uint8_t* addr) ATTR_ALWAYS_INLINE;
 181:usb/usb.h     **** inline void USB_ep_out_start(uint8_t ep, uint8_t* addr){
 182:usb/usb.h     **** 	USB_ep_start_bank(ep, 0, addr, 0);
 183:usb/usb.h     **** }
 184:usb/usb.h     **** 
 185:usb/usb.h     **** inline void USB_ep_in_start(uint8_t ep, uint8_t* addr, uint16_t size) ATTR_ALWAYS_INLINE;
 186:usb/usb.h     **** inline void USB_ep_in_start(uint8_t ep, uint8_t* addr, uint16_t size){
 187:usb/usb.h     **** 	USB_ep_start_bank(ep, 0, addr, size);
 188:usb/usb.h     **** }
 189:usb/usb.h     **** 
 190:usb/usb.h     **** inline bool USB_ep_done_bank(uint8_t ep, uint8_t bank){
 191:usb/usb.h     **** 	_USB_EP(ep);
 192:usb/usb.h     **** 	return e->STATUS & (bank?USB_EP_TRNCOMPL1_bm:USB_EP_TRNCOMPL0_bm);
 193:usb/usb.h     **** }
 194:usb/usb.h     **** 
 195:usb/usb.h     **** inline bool USB_ep_done(uint8_t ep) ATTR_ALWAYS_INLINE;
 196:usb/usb.h     **** inline bool USB_ep_done(uint8_t ep){
 197:usb/usb.h     **** 	_USB_EP(ep);
 198:usb/usb.h     **** 	if (ep & USB_EP_PP){
 199:usb/usb.h     **** 		return e->STATUS & (USB_EP_TRNCOMPL0_bm|USB_EP_TRNCOMPL1_bm);
 200:usb/usb.h     **** 	}else{
 201:usb/usb.h     **** 		// Because for ep0, TRNCOMPL1 is SETUP
 202:usb/usb.h     **** 		return e->STATUS & USB_EP_TRNCOMPL0_bm;
 203:usb/usb.h     **** 	}
 204:usb/usb.h     **** }
 205:usb/usb.h     **** 
 206:usb/usb.h     **** inline void USB_ep_clear_done(uint8_t ep) ATTR_ALWAYS_INLINE;
 207:usb/usb.h     **** inline void USB_ep_clear_done(uint8_t ep){
 208:usb/usb.h     **** 	_USB_EP(ep);
 209:usb/usb.h     **** 	if (ep & USB_EP_PP){
 210:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_TRNCOMPL0_bm|USB_EP_TRNCOMPL1_bm);
 211:usb/usb.h     **** 	}else{
 212:usb/usb.h     **** 		// Because for ep0, TRNCOMPL1 is SETUP
 213:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_TRNCOMPL0_bm);
 214:usb/usb.h     **** 	}
 215:usb/usb.h     **** }
 216:usb/usb.h     **** 
 217:usb/usb.h     **** inline bool USB_ep_ready(uint8_t ep) ATTR_ALWAYS_INLINE;
 218:usb/usb.h     **** inline bool USB_ep_ready(uint8_t ep){
 219:usb/usb.h     **** 	_USB_EP(ep);
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 221:usb/usb.h     **** }
 222:usb/usb.h     **** 
 223:usb/usb.h     **** inline bool USB_ep_empty(uint8_t ep) ATTR_ALWAYS_INLINE;
 224:usb/usb.h     **** inline bool USB_ep_empty(uint8_t ep){
 225:usb/usb.h     **** 	_USB_EP(ep);
 226:usb/usb.h     **** 	if (ep & USB_EP_PP){
 227:usb/usb.h     **** 		const uint8_t mask = (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 229:usb/usb.h     **** 	}else{
 230:usb/usb.h     **** 		return e->STATUS & USB_EP_BUSNACK0_bm;
 231:usb/usb.h     **** 	}
 232:usb/usb.h     **** }
 233:usb/usb.h     **** 
 234:usb/usb.h     **** inline uint16_t USB_ep_count_bank(uint8_t ep, uint8_t bank) ATTR_ALWAYS_INLINE;
 235:usb/usb.h     **** inline uint16_t USB_ep_count_bank(uint8_t ep, uint8_t bank){
 236:usb/usb.h     **** 	_USB_EP(ep);
 237:usb/usb.h     **** 	_USB_EP_BANK(ep, bank);
 238:usb/usb.h     **** 	return b->CNT;
 239:usb/usb.h     **** }
 240:usb/usb.h     **** 
 241:usb/usb.h     **** inline uint16_t USB_ep_count(uint8_t ep) ATTR_ALWAYS_INLINE;
 242:usb/usb.h     **** inline uint16_t USB_ep_count(uint8_t ep){
 243:usb/usb.h     **** 	return USB_ep_count_bank(ep, 0);
 244:usb/usb.h     **** }
 245:usb/usb.h     **** 
 246:usb/usb.h     **** inline void USB_ep0_send(uint8_t size){
 247:usb/usb.h     **** 	USB_ep_in_start(0x80, ep0_buf_in, size);
 248:usb/usb.h     **** }
 249:usb/usb.h     **** void USB_ep0_send_progmem(const uint8_t* addr, uint16_t size);
 250:usb/usb.h     **** 
 251:usb/usb.h     **** inline void USB_ep_wait(uint8_t ep) ATTR_ALWAYS_INLINE;
 252:usb/usb.h     **** inline void USB_ep_wait(uint8_t ep){
 253:usb/usb.h     **** 	while (!USB_ep_done(ep)){};
 254:usb/usb.h     **** }
 255:usb/usb.h     **** 
 256:usb/usb.h     **** /// Select a certain bank of an endpoint for the next transfer
 257:usb/usb.h     **** inline void USB_ep_set_bank(uint8_t ep, uint8_t bank) ATTR_ALWAYS_INLINE;
 258:usb/usb.h     **** inline void USB_ep_set_bank(uint8_t ep, uint8_t bank){
 259:usb/usb.h     **** 	_USB_EP(ep);
 260:usb/usb.h     **** 	if (bank){
 261:usb/usb.h     **** 		LASR16(&(e->STATUS), USB_EP_BANK_bm);
 262:usb/usb.h     **** 	}else{
 263:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BANK_bm);
 264:usb/usb.h     **** 	}
 265:usb/usb.h     **** }
 266:usb/usb.h     **** 
 267:usb/usb.h     **** /// Get the bank 0/1 which will handle the next request on this endpoint
 268:usb/usb.h     **** inline uint8_t USB_ep_get_bank(uint8_t ep) ATTR_ALWAYS_INLINE;
 269:usb/usb.h     **** inline uint8_t USB_ep_get_bank(uint8_t ep){
 270:usb/usb.h     **** 	_USB_EP(ep);
 271:usb/usb.h     **** 	return !!(e->STATUS & USB_EP_BANK_bm);
 272:usb/usb.h     **** }
 273:usb/usb.h     **** 
 274:usb/usb.h     **** 
 275:usb/usb.h     **** // Enable the OUT stage on the default control pipe. This happens automatically
 276:usb/usb.h     **** // upon the return of HandleSetup, but use this function if it needs to happen
 277:usb/usb.h     **** // before returning (e.g. with USB_ep_wait()).
 278:usb/usb.h     **** inline void USB_ep0_enableOut(void) ATTR_ALWAYS_INLINE;
 279:usb/usb.h     **** inline void USB_ep0_enableOut(void){
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 281:usb/usb.h     **** }
 282:usb/usb.h     **** 
 283:usb/usb.h     **** bool USB_HandleSetup(void);
 284:usb/usb.h     **** 
 285:usb/usb.h     **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 286:usb/usb.h     ****                                     const uint8_t wIndex,
 287:usb/usb.h     ****                                     const void** const DescriptorAddress);
 288:usb/usb.h     **** 
 289:usb/usb.h     **** /** Detaches the device from the USB bus. This has the effect of removing the device from any
 290:usb/usb.h     ****  *  attached host, ceasing USB communications. If no host is present, this prevents any host from
 291:usb/usb.h     ****  *  enumerating the device once attached until \ref USB_Attach() is called.
 292:usb/usb.h     ****  */
 293:usb/usb.h     **** static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
 294:usb/usb.h     **** static inline void USB_Detach(void)
 295:usb/usb.h     **** {
 296:usb/usb.h     **** 	USB.CTRLB &= ~USB_ATTACH_bm;
 297:usb/usb.h     **** }
 298:usb/usb.h     **** 
 299:usb/usb.h     **** /** Attaches the device to the USB bus. This announces the device's presence to any attached
 300:usb/usb.h     ****  *  USB host, starting the enumeration process. If no host is present, attaching the device
 301:usb/usb.h     ****  *  will allow for enumeration once a host is connected to the device.
 302:usb/usb.h     ****  */
 303:usb/usb.h     **** static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
 304:usb/usb.h     **** static inline void USB_Attach(void)
 305:usb/usb.h     **** {
 306:usb/usb.h     **** 	USB.CTRLB |= USB_ATTACH_bm;
 307:usb/usb.h     **** }
 308:usb/usb.h     **** 
 309:usb/usb.h     **** inline void USB_Evt_Task(void) ATTR_ALWAYS_INLINE;
 310:usb/usb.h     **** inline void USB_Evt_Task(void){
 311:usb/usb.h     **** 	if (USB.STATUS & USB_BUSRST_bm){
 194               		.loc 5 311 0
 195 0090 8091 C204 		lds r24,1218
 196 0094 80FF      		sbrs r24,0
 197 0096 00C0      		rjmp .L2
 312:usb/usb.h     **** 		USB.STATUS &= ~USB_BUSRST_bm;
 198               		.loc 5 312 0
 199 0098 8091 C204 		lds r24,1218
 200 009c 8E7F      		andi r24,lo8(-2)
 201 009e 8283      		std Z+2,r24
 313:usb/usb.h     **** 		USB_Init();
 202               		.loc 5 313 0
 203 00a0 0E94 0000 		call USB_Init
 204 00a4 00C0      		rjmp .L2
 205               	.L9:
 206               	.LBE232:
 207               	.LBE231:
  44:Framework.h   **** 		USB.INTFLAGSACLR = (USB_CRCIF_bm | USB_UNFIF_bm | USB_OVFIF_bm);
 208               		.loc 1 44 0
 209 00a6 8EE0      		ldi r24,lo8(14)
 210 00a8 8287      		std Z+10,r24
 211               	.L2:
 212               	/* epilogue start */
  49:Framework.h   **** 		USB_Evt_Task();
  50:Framework.h   **** 	}
  51:Framework.h   **** }
 213               		.loc 1 51 0
 214 00aa FF91      		pop r31
 215 00ac EF91      		pop r30
 216 00ae BF91      		pop r27
 217 00b0 AF91      		pop r26
 218 00b2 9F91      		pop r25
 219 00b4 8F91      		pop r24
 220 00b6 7F91      		pop r23
 221 00b8 6F91      		pop r22
 222 00ba 5F91      		pop r21
 223 00bc 4F91      		pop r20
 224 00be 3F91      		pop r19
 225 00c0 2F91      		pop r18
 226 00c2 0F90      		pop r0
 227 00c4 0FBE      		out __SREG__,r0
 228 00c6 0F90      		pop r0
 229 00c8 1F90      		pop r1
 230 00ca 1895      		reti
 231               	.L10:
  46:Framework.h   **** 		USB.INTFLAGSACLR = USB_STALLIF_bm;
 232               		.loc 1 46 0
 233 00cc 81E0      		ldi r24,lo8(1)
 234 00ce 8287      		std Z+10,r24
 235 00d0 00C0      		rjmp .L2
 236               	.L8:
  42:Framework.h   **** 		USB.INTFLAGSACLR = USB_SOFIF_bm;
 237               		.loc 1 42 0
 238 00d2 80E8      		ldi r24,lo8(-128)
 239 00d4 8287      		std Z+10,r24
 240 00d6 00C0      		rjmp .L2
 241               		.cfi_endproc
 242               	.LFE58:
 244               	.global	__vector_126
 246               	__vector_126:
 247               	.LFB59:
  52:Framework.h   **** 
  53:Framework.h   **** ISR(USB_TRNCOMPL_vect){
 248               		.loc 1 53 0
 249               		.cfi_startproc
 250 00d8 1F92      		push r1
 251               	.LCFI14:
 252               		.cfi_def_cfa_offset 3
 253               		.cfi_offset 1, -2
 254 00da 0F92      		push r0
 255               	.LCFI15:
 256               		.cfi_def_cfa_offset 4
 257               		.cfi_offset 0, -3
 258 00dc 0FB6      		in r0,__SREG__
 259 00de 0F92      		push r0
 260 00e0 1124      		clr __zero_reg__
 261 00e2 0F93      		push r16
 262               	.LCFI16:
 263               		.cfi_def_cfa_offset 5
 264               		.cfi_offset 16, -4
 265 00e4 2F93      		push r18
 266               	.LCFI17:
 267               		.cfi_def_cfa_offset 6
 268               		.cfi_offset 18, -5
 269 00e6 3F93      		push r19
 270               	.LCFI18:
 271               		.cfi_def_cfa_offset 7
 272               		.cfi_offset 19, -6
 273 00e8 4F93      		push r20
 274               	.LCFI19:
 275               		.cfi_def_cfa_offset 8
 276               		.cfi_offset 20, -7
 277 00ea 5F93      		push r21
 278               	.LCFI20:
 279               		.cfi_def_cfa_offset 9
 280               		.cfi_offset 21, -8
 281 00ec 6F93      		push r22
 282               	.LCFI21:
 283               		.cfi_def_cfa_offset 10
 284               		.cfi_offset 22, -9
 285 00ee 7F93      		push r23
 286               	.LCFI22:
 287               		.cfi_def_cfa_offset 11
 288               		.cfi_offset 23, -10
 289 00f0 8F93      		push r24
 290               	.LCFI23:
 291               		.cfi_def_cfa_offset 12
 292               		.cfi_offset 24, -11
 293 00f2 9F93      		push r25
 294               	.LCFI24:
 295               		.cfi_def_cfa_offset 13
 296               		.cfi_offset 25, -12
 297 00f4 AF93      		push r26
 298               	.LCFI25:
 299               		.cfi_def_cfa_offset 14
 300               		.cfi_offset 26, -13
 301 00f6 BF93      		push r27
 302               	.LCFI26:
 303               		.cfi_def_cfa_offset 15
 304               		.cfi_offset 27, -14
 305 00f8 EF93      		push r30
 306               	.LCFI27:
 307               		.cfi_def_cfa_offset 16
 308               		.cfi_offset 30, -15
 309 00fa FF93      		push r31
 310               	.LCFI28:
 311               		.cfi_def_cfa_offset 17
 312               		.cfi_offset 31, -16
 313               	/* prologue: Signal */
 314               	/* frame size = 0 */
 315               	/* stack size = 16 */
 316               	.L__stack_usage = 16
  54:Framework.h   **** 	USB.FIFOWP = 0;
 317               		.loc 1 54 0
 318 00fc E0EC      		ldi r30,lo8(1216)
 319 00fe F4E0      		ldi r31,hi8(1216)
 320 0100 1482      		std Z+4,__zero_reg__
  55:Framework.h   **** 	USB.INTFLAGSBCLR = USB_SETUPIF_bm | USB_TRNIF_bm;
 321               		.loc 1 55 0
 322 0102 83E0      		ldi r24,lo8(3)
 323 0104 8487      		std Z+12,r24
 324               	.LVL6:
 325               	.LBB274:
 326               	.LBB275:
  50:usb/usb_pipe.h **** 	}
  51:usb/usb_pipe.h **** }
  52:usb/usb_pipe.h **** 
  53:usb/usb_pipe.h **** static inline void usb_pipe_reset(const USB_Pipe* p){
  54:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
  55:usb/usb_pipe.h **** 		pipe_reset(p->pipe);
  56:usb/usb_pipe.h **** 		USB_ep_cancel(p->ep);
  57:usb/usb_pipe.h **** 		p->data->flush = 0;
  58:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
  59:usb/usb_pipe.h **** 		p->data->bank = 0;
  60:usb/usb_pipe.h **** 	}
  61:usb/usb_pipe.h **** }
  62:usb/usb_pipe.h **** 
  63:usb/usb_pipe.h **** static inline void _usb_pipe_ep_start(const USB_Pipe* p, uint8_t* data, uint16_t size) ATTR_ALWAYS_
  64:usb/usb_pipe.h **** static inline void _usb_pipe_ep_start(const USB_Pipe* p, uint8_t* data, uint16_t size){
  65:usb/usb_pipe.h **** 	bool bank = 0;
  66:usb/usb_pipe.h **** 
  67:usb/usb_pipe.h **** 	if (p->ep & USB_EP_PP){
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
  70:usb/usb_pipe.h **** 	}
  71:usb/usb_pipe.h **** 
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
  73:usb/usb_pipe.h **** 		USB_ep_start_bank(p->ep, 0, data, size);
  74:usb/usb_pipe.h **** 	}else{
  75:usb/usb_pipe.h **** 		USB_ep_start_bank(p->ep, 1, data, size);
  76:usb/usb_pipe.h **** 	}
  77:usb/usb_pipe.h **** }
  78:usb/usb_pipe.h **** 
  79:usb/usb_pipe.h **** static inline void usb_pipe_handle(const USB_Pipe* p){
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 327               		.loc 2 80 0
 328 0106 2FB7      		in r18,__SREG__
 329               	.LVL7:
 330               	.LBB276:
 331               	.LBB277:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 332               		.loc 3 50 0
 333               	/* #APP */
 334               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 335 0108 F894      		cli
 336               	 ;  0 "" 2
 337               	.LVL8:
 338               	/* #NOAPP */
 339               	.LBE277:
 340               	.LBE276:
 341               	.LBB278:
 342               	.LBB279:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 343               		.loc 5 220 0
 344 010a 8091 0000 		lds r24,endpoints+24
 345 010e 8670      		andi r24,lo8(6)
 346               	.LBE279:
 347               	.LBE278:
  81:usb/usb_pipe.h **** 		if (p->ep & USB_EP_IN){
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 348               		.loc 2 82 0
 349 0110 01F4      		brne .L26
 350               	.LVL9:
 351               	.L12:
 352               	.LBB280:
 353               	.LBB281:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 354               		.loc 3 70 0
 355 0112 2FBF      		out __SREG__,r18
 356               		.loc 3 71 0
 357               	.LBE281:
 358               	.LBE280:
 359               	.LBE275:
 360               	.LBE274:
 361               	.LBB316:
 362               	.LBB317:
 314:usb/usb.h     **** 	}
 315:usb/usb.h     **** }
 316:usb/usb.h     **** 
 317:usb/usb.h     **** inline void USB_Task(void) ATTR_ALWAYS_INLINE;
 318:usb/usb.h     **** inline void USB_Task(void){
 319:usb/usb.h     **** 	// Read once to prevent race condition where SETUP packet is interpreted as OUT
 320:usb/usb.h     **** 	uint8_t status = endpoints[0].out.STATUS;
 363               		.loc 5 320 0
 364 0114 8091 0000 		lds r24,endpoints
 365               	.LVL10:
 321:usb/usb.h     **** 
 322:usb/usb.h     **** 	if (status & USB_EP_SETUP_bm){
 366               		.loc 5 322 0
 367 0118 84FD      		sbrc r24,4
 368 011a 00C0      		rjmp .L27
 369               	.L21:
 323:usb/usb.h     **** 		if (!USB_HandleSetup()){
 324:usb/usb.h     **** 			endpoints[0].out.CTRL |= USB_EP_STALL_bm;
 325:usb/usb.h     **** 			endpoints[0].in.CTRL |= USB_EP_STALL_bm; 
 326:usb/usb.h     **** 		}
 327:usb/usb.h     **** 		USB_ep0_enableOut();
 328:usb/usb.h     **** 	}else if(status & USB_EP_TRNCOMPL0_bm){
 370               		.loc 5 328 0
 371 011c 85FD      		sbrc r24,5
 372 011e 00C0      		rjmp .L28
 373               	.LVL11:
 374               	.L11:
 375               	/* epilogue start */
 376               	.LBE317:
 377               	.LBE316:
  56:Framework.h   **** 	usb_pipe_handle(&ep_in);
  57:Framework.h   **** 	USB_Task();
  58:Framework.h   **** }
 378               		.loc 1 58 0
 379 0120 FF91      		pop r31
 380 0122 EF91      		pop r30
 381 0124 BF91      		pop r27
 382 0126 AF91      		pop r26
 383 0128 9F91      		pop r25
 384 012a 8F91      		pop r24
 385 012c 7F91      		pop r23
 386 012e 6F91      		pop r22
 387 0130 5F91      		pop r21
 388 0132 4F91      		pop r20
 389 0134 3F91      		pop r19
 390 0136 2F91      		pop r18
 391 0138 0F91      		pop r16
 392 013a 0F90      		pop r0
 393 013c 0FBE      		out __SREG__,r0
 394 013e 0F90      		pop r0
 395 0140 1F90      		pop r1
 396 0142 1895      		reti
 397               	.LVL12:
 398               	.L26:
 399               	.LBB326:
 400               	.LBB313:
 401               	.LBB283:
 402               	.LBB284:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 403               		.loc 4 51 0
 404 0144 3091 0000 		lds r19,ep_in_pipe_data+4
 405               	.LBE284:
 406               	.LBE283:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 407               		.loc 2 83 0
 408 0148 1316      		cp __zero_reg__,r19
 409 014a 04F0      		brlt .+2
 410 014c 00C0      		rjmp .L13
 411               	.LBB285:
 412               	.LBB286:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 413               		.loc 4 62 0
 414 014e 8091 0000 		lds r24,ep_in_pipe_data
 415 0152 9091 0000 		lds r25,ep_in_pipe_data+1
 416               	.LVL13:
 417               	.LBE286:
 418               	.LBE285:
 419               	.LBB287:
 420               	.LBB288:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 421               		.loc 2 68 0
 422 0156 4091 0000 		lds r20,ep_in_data
 423               	.LVL14:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 424               		.loc 2 69 0
 425 015a 51E0      		ldi r21,lo8(1)
 426 015c 4130      		cpi r20,lo8(1)
 427 015e 01F4      		brne .+2
 428 0160 00C0      		rjmp .L29
 429 0162 5093 0000 		sts ep_in_data,r21
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 430               		.loc 2 72 0
 431 0166 4423      		tst r20
 432 0168 01F4      		brne .+2
 433 016a 00C0      		rjmp .L30
 434               	.L15:
 435               	.LVL15:
 436               	.LBB289:
 437               	.LBB290:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 438               		.loc 5 168 0
 439 016c 8093 0000 		sts endpoints+20,r24
 440 0170 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 441               		.loc 5 169 0
 442 0174 40E4      		ldi r20,lo8(64)
 443 0176 50E0      		ldi r21,hi8(64)
 444 0178 4093 0000 		sts endpoints+18,r20
 445 017c 5093 0000 		sts endpoints+18+1,r21
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 446               		.loc 5 176 0
 447 0180 E0E0      		ldi r30,lo8(endpoints+24)
 448 0182 F0E0      		ldi r31,hi8(endpoints+24)
 449               	/* #APP */
 450               	 ;  176 "usb/usb.h" 1
 451 0184 04E1      		ldi r16, 20
 452 0186 0693      		.dc.w 0x9306
 453               		
 454               	 ;  0 "" 2
 455               	.LVL16:
 456               	/* #NOAPP */
 457               	.L16:
 458               	.LBE290:
 459               	.LBE289:
 460               	.LBE288:
 461               	.LBE287:
 462               	.LBB294:
 463               	.LBB295:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 464               		.loc 4 72 0
 465 0188 3150      		subi r19,lo8(-(-1))
 466 018a 3093 0000 		sts ep_in_pipe_data+4,r19
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 467               		.loc 4 73 0
 468 018e 805C      		subi r24,lo8(-(64))
 469 0190 9F4F      		sbci r25,hi8(-(64))
 470 0192 8093 0000 		sts ep_in_pipe_data,r24
 471 0196 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 472               		.loc 4 75 0
 473 019a 30E0      		ldi r19,hi8(ep_in_pipe_buffer+512)
 474 019c 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 475 019e 9307      		cpc r25,r19
 476 01a0 01F0      		breq .+2
 477 01a2 00C0      		rjmp .L12
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
 478               		.loc 4 76 0
 479 01a4 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 480 01a6 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 481 01a8 8093 0000 		sts ep_in_pipe_data,r24
 482 01ac 9093 0000 		sts ep_in_pipe_data+1,r25
 483               	.LBE295:
 484               	.LBE294:
 485               	.LBB296:
 486               	.LBB282:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 487               		.loc 3 70 0
 488 01b0 2FBF      		out __SREG__,r18
 489               		.loc 3 71 0
 490               	.LBE282:
 491               	.LBE296:
 492               	.LBE313:
 493               	.LBE326:
 494               	.LBB327:
 495               	.LBB324:
 320:usb/usb.h     **** 	uint8_t status = endpoints[0].out.STATUS;
 496               		.loc 5 320 0
 497 01b2 8091 0000 		lds r24,endpoints
 498               	.LVL17:
 322:usb/usb.h     **** 	if (status & USB_EP_SETUP_bm){
 499               		.loc 5 322 0
 500 01b6 84FF      		sbrs r24,4
 501 01b8 00C0      		rjmp .L21
 502               	.LVL18:
 503               	.L27:
 323:usb/usb.h     **** 		if (!USB_HandleSetup()){
 504               		.loc 5 323 0
 505 01ba 0E94 0000 		call USB_HandleSetup
 506               	.LVL19:
 507 01be 8823      		tst r24
 508 01c0 01F4      		brne .L24
 324:usb/usb.h     **** 			endpoints[0].out.CTRL |= USB_EP_STALL_bm;
 509               		.loc 5 324 0
 510 01c2 8091 0000 		lds r24,endpoints+1
 511 01c6 8460      		ori r24,lo8(4)
 512 01c8 8093 0000 		sts endpoints+1,r24
 325:usb/usb.h     **** 			endpoints[0].in.CTRL |= USB_EP_STALL_bm; 
 513               		.loc 5 325 0
 514 01cc 8091 0000 		lds r24,endpoints+9
 515 01d0 8460      		ori r24,lo8(4)
 516 01d2 8093 0000 		sts endpoints+9,r24
 517               	.L24:
 518               	.LBB318:
 519               	.LBB319:
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 520               		.loc 5 280 0
 521 01d6 E0E0      		ldi r30,lo8(endpoints)
 522 01d8 F0E0      		ldi r31,hi8(endpoints)
 523               	/* #APP */
 524               	 ;  280 "usb/usb.h" 1
 525 01da 02E7      		ldi r16, 114
 526 01dc 0693      		.dc.w 0x9306
 527               		
 528               	 ;  0 "" 2
 529               	/* #NOAPP */
 530 01de 00C0      		rjmp .L11
 531               	.LVL20:
 532               	.L30:
 533               	.LBE319:
 534               	.LBE318:
 535               	.LBE324:
 536               	.LBE327:
 537               	.LBB328:
 538               	.LBB314:
 539               	.LBB297:
 540               	.LBB293:
 541               	.LBB291:
 542               	.LBB292:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 543               		.loc 5 168 0
 544 01e0 8093 0000 		sts endpoints+28,r24
 545 01e4 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 546               		.loc 5 169 0
 547 01e8 40E4      		ldi r20,lo8(64)
 548 01ea 50E0      		ldi r21,hi8(64)
 549               	.LVL21:
 550 01ec 4093 0000 		sts endpoints+26,r20
 551 01f0 5093 0000 		sts endpoints+26+1,r21
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 552               		.loc 5 174 0
 553 01f4 E0E0      		ldi r30,lo8(endpoints+24)
 554 01f6 F0E0      		ldi r31,hi8(endpoints+24)
 555               	.LVL22:
 556               	/* #APP */
 557               	 ;  174 "usb/usb.h" 1
 558 01f8 02E2      		ldi r16, 34
 559 01fa 0693      		.dc.w 0x9306
 560               		
 561               	 ;  0 "" 2
 562               	/* #NOAPP */
 563 01fc 00C0      		rjmp .L16
 564               	.LVL23:
 565               	.L29:
 566               	.LBE292:
 567               	.LBE291:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 568               		.loc 2 69 0
 569 01fe 50E0      		ldi r21,lo8(0)
 570 0200 5093 0000 		sts ep_in_data,r21
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 571               		.loc 2 72 0
 572 0204 4423      		tst r20
 573 0206 01F0      		breq .+2
 574 0208 00C0      		rjmp .L15
 575 020a 00C0      		rjmp .L30
 576               	.LVL24:
 577               	.L28:
 578               	.LBE293:
 579               	.LBE297:
 580               	.LBE314:
 581               	.LBE328:
 582               	.LBB329:
 583               	.LBB325:
 329:usb/usb.h     **** 		EVENT_USB_Device_ControlOUT((uint8_t *) ep0_buf_out, endpoints[0].out.CNT);
 584               		.loc 5 329 0
 585 020c 4091 0000 		lds r20,endpoints+2
 586 0210 5091 0000 		lds r21,endpoints+2+1
 587               	.LVL25:
 588               	.LBB321:
 589               	.LBB322:
 590               		.file 6 "main.c"
   1:main.c        **** #include "Framework.h"
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <inttypes.h>
   4:main.c        **** #include <stdio.h> 
   5:main.c        **** #include <util/delay.h>
   6:main.c        **** #include <string.h> 
   7:main.c        **** #include "nmea/nmea.h"
   8:main.c        **** #define USART_BAUD 4800L
   9:main.c        **** 
  10:main.c        **** // static int uart_putchar(char c); 
  11:main.c        **** static void uart_init (void); 
  12:main.c        **** void send_usb_data(char *s);
  13:main.c        **** bool updating = false;
  14:main.c        **** static void parse_nmea(void);
  15:main.c        **** 
  16:main.c        **** char *message;
  17:main.c        **** static void uart_init(void) {
  18:main.c        **** 
  19:main.c        **** 	// Set the TxD pin high - set PORTC DIR register bit 3 to 1 
  20:main.c        ****   PORTD.OUTSET = PIN3_bm; 
  21:main.c        **** 
  22:main.c        ****   // Set the TxD pin as an output - set PORTC OUT register bit 3 to 1 
  23:main.c        ****   PORTD.DIRSET = PIN3_bm; 
  24:main.c        **** 
  25:main.c        **** 	//Baud rate of 4800
  26:main.c        **** 	uint16_t BSEL = 12;
  27:main.c        **** 	uint8_t BSCALE = 1;
  28:main.c        **** 	USARTD0_BAUDCTRLA = BSEL & 0XFF;
  29:main.c        **** 	USARTD0_BAUDCTRLB = (BSCALE << 4) | (BSEL & 0xF000) >> 8;
  30:main.c        **** 
  31:main.c        **** 	// no interrupts
  32:main.c        **** 	// can't overwrite bits 7:6
  33:main.c        **** 	USARTD0.CTRLA = 0x00;
  34:main.c        **** 
  35:main.c        ****   // Enable transmitter and receiver
  36:main.c        ****   USARTD0.CTRLB = USART_TXEN_bm | USART_RXEN_bm;  
  37:main.c        **** 
  38:main.c        **** 	// async, no parity, 1 stop bit, 8 bit data,
  39:main.c        **** 	// 00     00         00          11    
  40:main.c        ****   USARTD0.CTRLC = 0x03;  
  41:main.c        **** }
  42:main.c        **** 
  43:main.c        **** static void parse_nmea(void) {
  44:main.c        **** 	  const char *buff[] = {
  45:main.c        ****         "$GPRMC,173843,A,3349.896,N,11808.521,W,000.0,360.0,230108,013.4,E*69\r\n",
  46:main.c        ****         "$GPGGA,111609.14,5001.27,N,3613.06,E,3,08,0.0,10.2,M,0.0,M,0.0,0000*70\r\n",
  47:main.c        ****         "$GPGSV,2,1,08,01,05,005,80,02,05,050,80,03,05,095,80,04,05,140,80*7f\r\n",
  48:main.c        ****         "$GPGSV,2,2,08,05,05,185,80,06,05,230,80,07,05,275,80,08,05,320,80*71\r\n",
  49:main.c        ****         "$GPGSA,A,3,01,02,03,04,05,06,07,08,00,00,00,00,0.0,0.0,0.0*3a\r\n",
  50:main.c        ****         "$GPRMC,111609.14,A,5001.27,N,3613.06,E,11.2,0.0,261206,0.0,E*50\r\n",
  51:main.c        ****         "$GPVTG,217.5,T,208.8,M,000.00,N,000.01,K*4C\r\n"
  52:main.c        ****     };
  53:main.c        **** 
  54:main.c        ****     int it;
  55:main.c        ****     nmeaINFO info;
  56:main.c        ****     nmeaPARSER parser;
  57:main.c        ****     nmeaPOS dpos;
  58:main.c        **** 
  59:main.c        ****     nmea_zero_INFO(&info);
  60:main.c        ****     nmea_parser_init(&parser);
  61:main.c        **** 
  62:main.c        ****     for(it = 0; it < 6; ++it){
  63:main.c        ****         nmea_parse(&parser, buff[it], (int)strlen(buff[it]), &info);
  64:main.c        ****         nmea_info2pos(&info, &dpos);
  65:main.c        **** 
  66:main.c        ****         printf(
  67:main.c        ****             "%03d, Lat: %f, Lon: %f, Sig: %d, Fix: %d\n",
  68:main.c        ****             it, dpos.lat, dpos.lon, info.sig, info.fix
  69:main.c        ****         );
  70:main.c        ****     }
  71:main.c        **** 
  72:main.c        ****     nmea_parser_destroy(&parser);
  73:main.c        **** }
  74:main.c        **** 
  75:main.c        **** // static int uart_putchar (char c) { 
  76:main.c        **** //     if (c == '\n') 
  77:main.c        **** //         uart_putchar('\r'); 
  78:main.c        **** 
  79:main.c        **** //     // Wait for the transmit buffer to be empty 
  80:main.c        **** //     while ( !( USARTD0.STATUS & USART_DREIF_bm) ); 
  81:main.c        **** 
  82:main.c        **** //     // Put our character into the transmit buffer 
  83:main.c        **** //     USARTD0.DATA = c; 
  84:main.c        **** 
  85:main.c        **** //     return 0; 
  86:main.c        **** // } 
  87:main.c        **** 
  88:main.c        **** int main(void){
  89:main.c        **** 	USB_ConfigureClock();
  90:main.c        **** 	USB_Init();
  91:main.c        **** 	USB.INTCTRLA = USB_BUSEVIE_bm | USB_INTLVL_MED_gc;
  92:main.c        **** 	USB.INTCTRLB = USB_TRNIE_bm | USB_SETUPIE_bm;
  93:main.c        **** 	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
  94:main.c        **** 	sei();
  95:main.c        **** 	if (false) {
  96:main.c        **** 		uart_init();
  97:main.c        **** 	}
  98:main.c        **** 
  99:main.c        **** 	parse_nmea();
 100:main.c        **** 
 101:main.c        **** 	message = "012345678901234567";
 102:main.c        **** 	// send_usb_data(message);
 103:main.c        **** 	for (;;){
 104:main.c        **** 		// uart_putchar('a');
 105:main.c        **** 	}
 106:main.c        **** 
 107:main.c        **** }
 108:main.c        **** 
 109:main.c        **** #define stringify(s) #s
 110:main.c        **** 
 111:main.c        **** const char PROGMEM hwversion[] = stringify(HW_VERSION);
 112:main.c        **** const char PROGMEM fwversion[] = stringify(FW_VERSION);
 113:main.c        **** 
 114:main.c        **** uint8_t usb_cmd = 0;
 115:main.c        **** uint8_t cmd_data = 0;
 116:main.c        **** 
 117:main.c        **** // void send_usb_data(char *message) {
 118:main.c        **** // 	for (uint8_t = 0; i < 64; i++) ep0_buf_in[i] = 0;
 119:main.c        **** // 	int l = strlen(message);
 120:main.c        **** // 	for (int i=0; i<l; i++) {
 121:main.c        **** // 		ep0_buf_in[i] = message[i];
 122:main.c        **** // 	}
 123:main.c        **** // }
 124:main.c        **** 
 125:main.c        **** /** Event handler for the library USB Control Request reception event. */
 126:main.c        **** bool EVENT_USB_Device_ControlRequest(USB_Request_Header_t* req){
 127:main.c        **** 	// zero out ep0_buf_in
 128:main.c        **** 	for (uint8_t i = 0; i < 64; i++) ep0_buf_in[i] = 0;
 129:main.c        **** 	usb_cmd = 0;
 130:main.c        **** 	if ((req->bmRequestType & CONTROL_REQTYPE_TYPE) == REQTYPE_VENDOR){
 131:main.c        **** 		switch(req->bRequest){
 132:main.c        **** 			case 0x00: // Info
 133:main.c        **** 				if (req->wIndex == 0){
 134:main.c        **** 					USB_ep0_send_progmem((uint8_t*)hwversion, sizeof(hwversion));
 135:main.c        **** 				}else if (req->wIndex == 1){
 136:main.c        **** 					USB_ep0_send_progmem((uint8_t*)fwversion, sizeof(fwversion));
 137:main.c        **** 				}
 138:main.c        **** 				return true;
 139:main.c        **** 			case 0x02:
 140:main.c        **** 				{
 141:main.c        **** 					int l = strlen(message);
 142:main.c        **** 					for (uint8_t i=0; i<64; i++) {
 143:main.c        **** 						ep0_buf_in[i] = message[i];
 144:main.c        **** 					}
 145:main.c        **** 					USB_ep0_send(l);
 146:main.c        **** 					return true;
 147:main.c        **** 				}
 148:main.c        **** 			case 0x08:
 149:main.c        **** 				* ((uint8_t *) req->wIndex) = req->wValue;
 150:main.c        **** 				USB_ep0_send(0);
 151:main.c        **** 				return true;
 152:main.c        **** 			case 0x09:
 153:main.c        **** 				ep0_buf_in[0] = * ((uint8_t *) req->wIndex);
 154:main.c        **** 				USB_ep0_send(1);
 155:main.c        **** 				return true;
 156:main.c        **** 			case 0x16:
 157:main.c        **** 				* ((uint16_t *) req->wIndex) = req->wValue;
 158:main.c        **** 				USB_ep0_send(0);
 159:main.c        **** 				return true;
 160:main.c        **** 			case 0x17:{
 161:main.c        **** 				uint16_t *addr;
 162:main.c        **** 				addr = (uint16_t *) req->wIndex;
 163:main.c        **** 				ep0_buf_in[0] = *addr & 0xFF;
 164:main.c        **** 				ep0_buf_in[1] = *addr >> 8;
 165:main.c        **** 				USB_ep0_send(2);}
 166:main.c        **** 				return true;
 167:main.c        **** 			// read EEPROM	
 168:main.c        **** 			case 0xE0: 
 169:main.c        **** 				eeprom_read_block(ep0_buf_in, (void*)(req->wIndex*64), 64);
 170:main.c        **** 				USB_ep0_send(64);
 171:main.c        **** 				return true;
 172:main.c        **** 
 173:main.c        **** 			// write EEPROM	
 174:main.c        **** 			case 0xE1: 
 175:main.c        **** 				usb_cmd = req->bRequest;
 176:main.c        **** 				cmd_data = req->wIndex;
 177:main.c        **** 				USB_ep0_send(0);
 178:main.c        **** 				return true; // Wait for OUT data (expecting an OUT transfer)
 179:main.c        **** 
 180:main.c        **** 			// disconnect from USB, jump to bootloader	
 181:main.c        **** 			case 0xBB: 
 182:main.c        **** 				USB_enter_bootloader();
 183:main.c        **** 				return true;
 184:main.c        **** 		}
 185:main.c        **** 	}
 186:main.c        **** 	return false;
 187:main.c        **** }
 188:main.c        **** 
 189:main.c        **** void EVENT_USB_Device_ControlOUT(uint8_t* buf, uint8_t count){
 190:main.c        **** 	switch (usb_cmd){
 591               		.loc 6 190 0
 592 0214 8091 0000 		lds r24,usb_cmd
 593               	.LVL26:
 594 0218 813E      		cpi r24,lo8(-31)
 595 021a 01F4      		brne .L24
 191:main.c        **** 		case 0xE1: // Write EEPROM
 192:main.c        **** 			eeprom_update_block(buf, (void*)(cmd_data*64), count);
 596               		.loc 6 192 0
 597 021c 6091 0000 		lds r22,cmd_data
 598 0220 70E0      		ldi r23,lo8(0)
 599 0222 0024      		clr __tmp_reg__
 600 0224 7695      		lsr r23
 601 0226 6795      		ror r22
 602 0228 0794      		ror __tmp_reg__
 603 022a 7695      		lsr r23
 604 022c 6795      		ror r22
 605 022e 0794      		ror __tmp_reg__
 606 0230 762F      		mov r23,r22
 607 0232 602D      		mov r22,__tmp_reg__
 608 0234 80E0      		ldi r24,lo8(ep0_buf_out)
 609 0236 90E0      		ldi r25,hi8(ep0_buf_out)
 610 0238 50E0      		ldi r21,lo8(0)
 611 023a 0E94 0000 		call __eeupd_block_x32a4u
 612               	.LVL27:
 613               	.LBE322:
 614               	.LBE321:
 615               	.LBB323:
 616               	.LBB320:
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 617               		.loc 5 280 0
 618 023e E0E0      		ldi r30,lo8(endpoints)
 619 0240 F0E0      		ldi r31,hi8(endpoints)
 620               	/* #APP */
 621               	 ;  280 "usb/usb.h" 1
 622 0242 02E7      		ldi r16, 114
 623 0244 0693      		.dc.w 0x9306
 624               		
 625               	 ;  0 "" 2
 626               	/* #NOAPP */
 627 0246 00C0      		rjmp .L11
 628               	.LVL28:
 629               	.L13:
 630               	.LBE320:
 631               	.LBE323:
 632               	.LBE325:
 633               	.LBE329:
 634               	.LBB330:
 635               	.LBB315:
  84:usb/usb_pipe.h **** 					_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->pipe->size);
  85:usb/usb_pipe.h **** 					pipe_done_read(p->pipe);
  86:usb/usb_pipe.h **** 				}else if (p->features & PIPE_ENABLE_FLUSH){
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 636               		.loc 2 87 0
 637 0248 8091 0000 		lds r24,ep_in_data+1
 638 024c 8130      		cpi r24,lo8(1)
 639 024e 01F0      		breq .L31
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
  89:usb/usb_pipe.h **** 						// Send short packet
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 640               		.loc 2 91 0
 641 0250 8230      		cpi r24,lo8(2)
 642 0252 01F0      		breq .+2
 643 0254 00C0      		rjmp .L12
 644               	.LVL29:
 645               	.LBB298:
 646               	.LBB299:
 647               	.LBB300:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 648               		.loc 5 228 0
 649 0256 8091 0000 		lds r24,endpoints+24
 650 025a 8670      		andi r24,lo8(6)
 651               	.LBE300:
 652               	.LBE299:
 653               	.LBE298:
 654               		.loc 2 91 0
 655 025c 8630      		cpi r24,lo8(6)
 656 025e 01F0      		breq .+2
 657 0260 00C0      		rjmp .L12
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 658               		.loc 2 92 0
 659 0262 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 660               		.loc 2 93 0
 661 0266 1092 0000 		sts ep_in_data+2,__zero_reg__
 662 026a 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 663               	.LBB301:
 664               	.LBB302:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 665               		.loc 4 90 0
 666 026e 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 667               		.loc 4 91 0
 668 0272 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 669 0274 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 670 0276 8093 0000 		sts ep_in_pipe_data+2,r24
 671 027a 9093 0000 		sts ep_in_pipe_data+2+1,r25
 672 027e 8093 0000 		sts ep_in_pipe_data,r24
 673 0282 9093 0000 		sts ep_in_pipe_data+1,r25
 674               	.LVL30:
 675 0286 00C0      		rjmp .L12
 676               	.LVL31:
 677               	.L31:
 678               	.LBE302:
 679               	.LBE301:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 680               		.loc 2 88 0
 681 0288 82E0      		ldi r24,lo8(2)
 682 028a 8093 0000 		sts ep_in_data+1,r24
 683               	.LBB303:
 684               	.LBB304:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 685               		.loc 4 62 0
 686 028e 7091 0000 		lds r23,ep_in_pipe_data
 687 0292 6091 0000 		lds r22,ep_in_pipe_data+1
 688               	.LBE304:
 689               	.LBE303:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 690               		.loc 2 90 0
 691 0296 8091 0000 		lds r24,ep_in_data+2
 692 029a 9091 0000 		lds r25,ep_in_data+2+1
 693               	.LVL32:
 694               	.LBB305:
 695               	.LBB306:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 696               		.loc 2 68 0
 697 029e 3091 0000 		lds r19,ep_in_data
 698               	.LVL33:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 699               		.loc 2 69 0
 700 02a2 41E0      		ldi r20,lo8(1)
 701 02a4 3130      		cpi r19,lo8(1)
 702 02a6 01F0      		breq .L32
 703               	.L19:
 704 02a8 4093 0000 		sts ep_in_data,r20
 705               	.LBB307:
 706               	.LBB308:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 707               		.loc 5 168 0
 708 02ac 472F      		mov r20,r23
 709 02ae 562F      		mov r21,r22
 710               	.LBE308:
 711               	.LBE307:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 712               		.loc 2 72 0
 713 02b0 3323      		tst r19
 714 02b2 01F4      		brne .L20
 715               	.LVL34:
 716               	.LBB310:
 717               	.LBB309:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 718               		.loc 5 168 0
 719 02b4 4093 0000 		sts endpoints+28,r20
 720 02b8 5093 0000 		sts endpoints+28+1,r21
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 721               		.loc 5 169 0
 722 02bc 8093 0000 		sts endpoints+26,r24
 723 02c0 9093 0000 		sts endpoints+26+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 724               		.loc 5 174 0
 725 02c4 E0E0      		ldi r30,lo8(endpoints+24)
 726 02c6 F0E0      		ldi r31,hi8(endpoints+24)
 727               	.LVL35:
 728               	/* #APP */
 729               	 ;  174 "usb/usb.h" 1
 730 02c8 02E2      		ldi r16, 34
 731 02ca 0693      		.dc.w 0x9306
 732               		
 733               	 ;  0 "" 2
 734               	/* #NOAPP */
 735 02cc 00C0      		rjmp .L12
 736               	.LVL36:
 737               	.L20:
 738               	.LBE309:
 739               	.LBE310:
 740               	.LBB311:
 741               	.LBB312:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 742               		.loc 5 168 0
 743 02ce 4093 0000 		sts endpoints+20,r20
 744 02d2 5093 0000 		sts endpoints+20+1,r21
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 745               		.loc 5 169 0
 746 02d6 8093 0000 		sts endpoints+18,r24
 747 02da 9093 0000 		sts endpoints+18+1,r25
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 748               		.loc 5 176 0
 749 02de E0E0      		ldi r30,lo8(endpoints+24)
 750 02e0 F0E0      		ldi r31,hi8(endpoints+24)
 751               	/* #APP */
 752               	 ;  176 "usb/usb.h" 1
 753 02e2 04E1      		ldi r16, 20
 754 02e4 0693      		.dc.w 0x9306
 755               		
 756               	 ;  0 "" 2
 757               	/* #NOAPP */
 758 02e6 00C0      		rjmp .L12
 759               	.LVL37:
 760               	.L32:
 761               	.LBE312:
 762               	.LBE311:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 763               		.loc 2 69 0
 764 02e8 40E0      		ldi r20,lo8(0)
 765 02ea 00C0      		rjmp .L19
 766               	.LBE306:
 767               	.LBE305:
 768               	.LBE315:
 769               	.LBE330:
 770               		.cfi_endproc
 771               	.LFE59:
 773               		.data
 774               	.LC8:
 775 0000 2530 3364 		.string	"%03d, Lat: %f, Lon: %f, Sig: %d, Fix: %d\n"
 775      2C20 4C61 
 775      743A 2025 
 775      662C 204C 
 775      6F6E 3A20 
 776               	.LC9:
 777 002a 3031 3233 		.string	"012345678901234567"
 777      3435 3637 
 777      3839 3031 
 777      3233 3435 
 777      3637 00
 778               	.LC0:
 779 003d 2447 5052 		.ascii	"$GPRMC"
 779      4D43 
 780 0043 2C31 3733 		.string	",173843,A,3349.896,N,11808.521,W,000.0,360.0,230108,013.4,E*69\r\n"
 780      3834 332C 
 780      412C 3333 
 780      3439 2E38 
 780      3936 2C4E 
 781               	.LC1:
 782 0084 2447 5047 		.ascii	"$GPGGA,1"
 782      4741 2C31 
 783 008c 3131 3630 		.string	"11609.14,5001.27,N,3613.06,E,3,08,0.0,10.2,M,0.0,M,0.0,0000*70\r\n"
 783      392E 3134 
 783      2C35 3030 
 783      312E 3237 
 783      2C4E 2C33 
 784               	.LC2:
 785 00cd 2447 5047 		.ascii	"$GPGSV"
 785      5356 
 786 00d3 2C32 2C31 		.string	",2,1,08,01,05,005,80,02,05,050,80,03,05,095,80,04,05,140,80*7f\r\n"
 786      2C30 382C 
 786      3031 2C30 
 786      352C 3030 
 786      352C 3830 
 787               	.LC3:
 788 0114 2447 5047 		.ascii	"$GPGSV"
 788      5356 
 789 011a 2C32 2C32 		.string	",2,2,08,05,05,185,80,06,05,230,80,07,05,275,80,08,05,320,80*71\r\n"
 789      2C30 382C 
 789      3035 2C30 
 789      352C 3138 
 789      352C 3830 
 790               	.LC4:
 791 015b 2447 5047 		.string	"$GPGSA,A,3,01,02,03,04,05,06,07,08,00,00,00,00,0.0,0.0,0.0*3a\r\n"
 791      5341 2C41 
 791      2C33 2C30 
 791      312C 3032 
 791      2C30 332C 
 792               	.LC5:
 793 019b 24        		.ascii	"$"
 794 019c 4750 524D 		.string	"GPRMC,111609.14,A,5001.27,N,3613.06,E,11.2,0.0,261206,0.0,E*50\r\n"
 794      432C 3131 
 794      3136 3039 
 794      2E31 342C 
 794      412C 3530 
 795               	.LC6:
 796 01dd 2447 5056 		.string	"$GPVTG,217.5,T,208.8,M,000.00,N,000.01,K*4C\r\n"
 796      5447 2C32 
 796      3137 2E35 
 796      2C54 2C32 
 796      3038 2E38 
 797               	.LC7:
 798 020b 0000      		.word	.LC0
 799 020d 0000      		.word	.LC1
 800 020f 0000      		.word	.LC2
 801 0211 0000      		.word	.LC3
 802 0213 0000      		.word	.LC4
 803 0215 0000      		.word	.LC5
 804 0217 0000      		.word	.LC6
 805               		.section	.text.startup,"ax",@progbits
 806               	.global	main
 808               	main:
 809               	.LFB63:
  88:main.c        **** int main(void){
 810               		.loc 6 88 0
 811               		.cfi_startproc
 812 0000 CF93      		push r28
 813               	.LCFI29:
 814               		.cfi_def_cfa_offset 3
 815               		.cfi_offset 28, -2
 816 0002 DF93      		push r29
 817               	.LCFI30:
 818               		.cfi_def_cfa_offset 4
 819               		.cfi_offset 29, -3
 820 0004 CDB7      		in r28,__SP_L__
 821 0006 DEB7      		in r29,__SP_H__
 822 0008 C45D      		subi r28,lo8(-(-212))
 823 000a D040      		sbci r29,hi8(-(-212))
 824               	.LCFI31:
 825               		.cfi_def_cfa 28, 216
 826 000c CDBF      		out __SP_L__,r28
 827 000e DEBF      		out __SP_H__,r29
 828               	/* prologue: function */
 829               	/* frame size = 212 */
 830               	/* stack size = 214 */
 831               	.L__stack_usage = 214
  89:main.c        **** 	USB_ConfigureClock();
 832               		.loc 6 89 0
 833 0010 0E94 0000 		call USB_ConfigureClock
  90:main.c        **** 	USB_Init();
 834               		.loc 6 90 0
 835 0014 0E94 0000 		call USB_Init
  91:main.c        **** 	USB.INTCTRLA = USB_BUSEVIE_bm | USB_INTLVL_MED_gc;
 836               		.loc 6 91 0
 837 0018 E0EC      		ldi r30,lo8(1216)
 838 001a F4E0      		ldi r31,hi8(1216)
 839 001c 82E4      		ldi r24,lo8(66)
 840 001e 8087      		std Z+8,r24
  92:main.c        **** 	USB.INTCTRLB = USB_TRNIE_bm | USB_SETUPIE_bm;
 841               		.loc 6 92 0
 842 0020 83E0      		ldi r24,lo8(3)
 843 0022 8187      		std Z+9,r24
  93:main.c        **** 	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
 844               		.loc 6 93 0
 845 0024 E0EA      		ldi r30,lo8(160)
 846 0026 F0E0      		ldi r31,hi8(160)
 847 0028 8283      		std Z+2,r24
  94:main.c        **** 	sei();
 848               		.loc 6 94 0
 849               	/* #APP */
 850               	 ;  94 "main.c" 1
 851 002a 7894      		sei
 852               	 ;  0 "" 2
 853               	/* #NOAPP */
 854               	.LBB333:
 855               	.LBB334:
  44:main.c        **** 	  const char *buff[] = {
 856               		.loc 6 44 0
 857 002c DE01      		movw r26,r28
 858 002e 5396      		adiw r26,19
 859 0030 E0E0      		ldi r30,lo8(.LC7)
 860 0032 F0E0      		ldi r31,hi8(.LC7)
 861 0034 8EE0      		ldi r24,lo8(14)
 862               	.L34:
 863 0036 0190      		ld r0,Z+
 864 0038 0D92      		st X+,r0
 865 003a 8150      		subi r24,lo8(-(-1))
 866 003c 01F4      		brne .L34
  59:main.c        ****     nmea_zero_INFO(&info);
 867               		.loc 6 59 0
 868 003e CE01      		movw r24,r28
 869 0040 8196      		adiw r24,33
 870 0042 0E94 0000 		call nmea_zero_INFO
  60:main.c        ****     nmea_parser_init(&parser);
 871               		.loc 6 60 0
 872 0046 CE01      		movw r24,r28
 873 0048 0996      		adiw r24,9
 874 004a 0E94 0000 		call nmea_parser_init
 875               	.LVL38:
  63:main.c        ****         nmea_parse(&parser, buff[it], (int)strlen(buff[it]), &info);
 876               		.loc 6 63 0
 877 004e 6B89      		ldd r22,Y+19
 878 0050 7C89      		ldd r23,Y+20
 879 0052 FB01      		movw r30,r22
 880 0054 DF01      		movw r26,r30
 881 0056 0D90      		ld __tmp_reg__,X+
 882 0058 0020      		tst __tmp_reg__
 883 005a 01F4      		brne .-6
 884 005c AD01      		movw r20,r26
 885 005e 4150      		subi r20,lo8(-(-1))
 886 0060 5040      		sbci r21,hi8(-(-1))
 887 0062 4E1B      		sub r20,r30
 888 0064 5F0B      		sbc r21,r31
 889 0066 CE01      		movw r24,r28
 890 0068 0996      		adiw r24,9
 891 006a 9E01      		movw r18,r28
 892 006c 2F5D      		subi r18,lo8(-(33))
 893 006e 3F4F      		sbci r19,hi8(-(33))
 894 0070 0E94 0000 		call nmea_parse
  64:main.c        ****         nmea_info2pos(&info, &dpos);
 895               		.loc 6 64 0
 896 0074 CE01      		movw r24,r28
 897 0076 8196      		adiw r24,33
 898 0078 BE01      		movw r22,r28
 899 007a 6F5F      		subi r22,lo8(-(1))
 900 007c 7F4F      		sbci r23,hi8(-(1))
 901 007e 0E94 0000 		call nmea_info2pos
  66:main.c        ****         printf(
 902               		.loc 6 66 0
 903 0082 8DB7      		in r24,__SP_L__
 904 0084 9EB7      		in r25,__SP_H__
 905 0086 4097      		sbiw r24,16
 906 0088 8DBF      		out __SP_L__,r24
 907 008a 9EBF      		out __SP_H__,r25
 908 008c EDB7      		in r30,__SP_L__
 909 008e FEB7      		in r31,__SP_H__
 910 0090 3196      		adiw r30,1
 911 0092 00E0      		ldi r16,lo8(.LC8)
 912 0094 10E0      		ldi r17,hi8(.LC8)
 913 0096 ADB7      		in r26,__SP_L__
 914 0098 BEB7      		in r27,__SP_H__
 915 009a 1196      		adiw r26,1
 916 009c 0D93      		st X+,r16
 917 009e 1C93      		st X,r17
 918 00a0 1297      		sbiw r26,1+1
 919 00a2 1282      		std Z+2,__zero_reg__
 920 00a4 1382      		std Z+3,__zero_reg__
 921 00a6 8981      		ldd r24,Y+1
 922 00a8 9A81      		ldd r25,Y+2
 923 00aa AB81      		ldd r26,Y+3
 924 00ac BC81      		ldd r27,Y+4
 925 00ae 8483      		std Z+4,r24
 926 00b0 9583      		std Z+5,r25
 927 00b2 A683      		std Z+6,r26
 928 00b4 B783      		std Z+7,r27
 929 00b6 8D81      		ldd r24,Y+5
 930 00b8 9E81      		ldd r25,Y+6
 931 00ba AF81      		ldd r26,Y+7
 932 00bc B885      		ldd r27,Y+8
 933 00be 8087      		std Z+8,r24
 934 00c0 9187      		std Z+9,r25
 935 00c2 A287      		std Z+10,r26
 936 00c4 B387      		std Z+11,r27
 937 00c6 89A9      		ldd r24,Y+49
 938 00c8 9AA9      		ldd r25,Y+50
 939 00ca 8487      		std Z+12,r24
 940 00cc 9587      		std Z+13,r25
 941 00ce 8BA9      		ldd r24,Y+51
 942 00d0 9CA9      		ldd r25,Y+52
 943 00d2 8687      		std Z+14,r24
 944 00d4 9787      		std Z+15,r25
 945               		.cfi_escape 0x2e,0x10
 946 00d6 0E94 0000 		call printf
 947               	.LVL39:
  63:main.c        ****         nmea_parse(&parser, buff[it], (int)strlen(buff[it]), &info);
 948               		.loc 6 63 0
 949 00da 6D89      		ldd r22,Y+21
 950 00dc 7E89      		ldd r23,Y+22
 951 00de FB01      		movw r30,r22
 952 00e0 DF01      		movw r26,r30
 953 00e2 0D90      		ld __tmp_reg__,X+
 954 00e4 0020      		tst __tmp_reg__
 955 00e6 01F4      		brne .-6
 956 00e8 AD01      		movw r20,r26
 957 00ea 4150      		subi r20,lo8(-(-1))
 958 00ec 5040      		sbci r21,hi8(-(-1))
 959 00ee 4E1B      		sub r20,r30
 960 00f0 5F0B      		sbc r21,r31
 961 00f2 8DB7      		in r24,__SP_L__
 962 00f4 9EB7      		in r25,__SP_H__
 963 00f6 4096      		adiw r24,16
 964 00f8 8DBF      		out __SP_L__,r24
 965 00fa 9EBF      		out __SP_H__,r25
 966 00fc CE01      		movw r24,r28
 967 00fe 0996      		adiw r24,9
 968 0100 9E01      		movw r18,r28
 969 0102 2F5D      		subi r18,lo8(-(33))
 970 0104 3F4F      		sbci r19,hi8(-(33))
 971               		.cfi_escape 0x2e,0
 972 0106 0E94 0000 		call nmea_parse
  64:main.c        ****         nmea_info2pos(&info, &dpos);
 973               		.loc 6 64 0
 974 010a CE01      		movw r24,r28
 975 010c 8196      		adiw r24,33
 976 010e BE01      		movw r22,r28
 977 0110 6F5F      		subi r22,lo8(-(1))
 978 0112 7F4F      		sbci r23,hi8(-(1))
 979 0114 0E94 0000 		call nmea_info2pos
  66:main.c        ****         printf(
 980               		.loc 6 66 0
 981 0118 ADB7      		in r26,__SP_L__
 982 011a BEB7      		in r27,__SP_H__
 983 011c 5097      		sbiw r26,16
 984 011e ADBF      		out __SP_L__,r26
 985 0120 BEBF      		out __SP_H__,r27
 986 0122 EDB7      		in r30,__SP_L__
 987 0124 FEB7      		in r31,__SP_H__
 988 0126 3196      		adiw r30,1
 989 0128 1196      		adiw r26,1
 990 012a 0D93      		st X+,r16
 991 012c 1C93      		st X,r17
 992 012e 1297      		sbiw r26,1+1
 993 0130 81E0      		ldi r24,lo8(1)
 994 0132 90E0      		ldi r25,hi8(1)
 995 0134 8283      		std Z+2,r24
 996 0136 9383      		std Z+3,r25
 997 0138 8981      		ldd r24,Y+1
 998 013a 9A81      		ldd r25,Y+2
 999 013c AB81      		ldd r26,Y+3
 1000 013e BC81      		ldd r27,Y+4
 1001 0140 8483      		std Z+4,r24
 1002 0142 9583      		std Z+5,r25
 1003 0144 A683      		std Z+6,r26
 1004 0146 B783      		std Z+7,r27
 1005 0148 8D81      		ldd r24,Y+5
 1006 014a 9E81      		ldd r25,Y+6
 1007 014c AF81      		ldd r26,Y+7
 1008 014e B885      		ldd r27,Y+8
 1009 0150 8087      		std Z+8,r24
 1010 0152 9187      		std Z+9,r25
 1011 0154 A287      		std Z+10,r26
 1012 0156 B387      		std Z+11,r27
 1013 0158 89A9      		ldd r24,Y+49
 1014 015a 9AA9      		ldd r25,Y+50
 1015 015c 8487      		std Z+12,r24
 1016 015e 9587      		std Z+13,r25
 1017 0160 8BA9      		ldd r24,Y+51
 1018 0162 9CA9      		ldd r25,Y+52
 1019 0164 8687      		std Z+14,r24
 1020 0166 9787      		std Z+15,r25
 1021               		.cfi_escape 0x2e,0x10
 1022 0168 0E94 0000 		call printf
 1023               	.LVL40:
  63:main.c        ****         nmea_parse(&parser, buff[it], (int)strlen(buff[it]), &info);
 1024               		.loc 6 63 0
 1025 016c 6F89      		ldd r22,Y+23
 1026 016e 788D      		ldd r23,Y+24
 1027 0170 FB01      		movw r30,r22
 1028 0172 DF01      		movw r26,r30
 1029 0174 0D90      		ld __tmp_reg__,X+
 1030 0176 0020      		tst __tmp_reg__
 1031 0178 01F4      		brne .-6
 1032 017a AD01      		movw r20,r26
 1033 017c 4150      		subi r20,lo8(-(-1))
 1034 017e 5040      		sbci r21,hi8(-(-1))
 1035 0180 4E1B      		sub r20,r30
 1036 0182 5F0B      		sbc r21,r31
 1037 0184 8DB7      		in r24,__SP_L__
 1038 0186 9EB7      		in r25,__SP_H__
 1039 0188 4096      		adiw r24,16
 1040 018a 8DBF      		out __SP_L__,r24
 1041 018c 9EBF      		out __SP_H__,r25
 1042 018e CE01      		movw r24,r28
 1043 0190 0996      		adiw r24,9
 1044 0192 9E01      		movw r18,r28
 1045 0194 2F5D      		subi r18,lo8(-(33))
 1046 0196 3F4F      		sbci r19,hi8(-(33))
 1047               		.cfi_escape 0x2e,0
 1048 0198 0E94 0000 		call nmea_parse
  64:main.c        ****         nmea_info2pos(&info, &dpos);
 1049               		.loc 6 64 0
 1050 019c CE01      		movw r24,r28
 1051 019e 8196      		adiw r24,33
 1052 01a0 BE01      		movw r22,r28
 1053 01a2 6F5F      		subi r22,lo8(-(1))
 1054 01a4 7F4F      		sbci r23,hi8(-(1))
 1055 01a6 0E94 0000 		call nmea_info2pos
  66:main.c        ****         printf(
 1056               		.loc 6 66 0
 1057 01aa ADB7      		in r26,__SP_L__
 1058 01ac BEB7      		in r27,__SP_H__
 1059 01ae 5097      		sbiw r26,16
 1060 01b0 ADBF      		out __SP_L__,r26
 1061 01b2 BEBF      		out __SP_H__,r27
 1062 01b4 EDB7      		in r30,__SP_L__
 1063 01b6 FEB7      		in r31,__SP_H__
 1064 01b8 3196      		adiw r30,1
 1065 01ba 1196      		adiw r26,1
 1066 01bc 0D93      		st X+,r16
 1067 01be 1C93      		st X,r17
 1068 01c0 1297      		sbiw r26,1+1
 1069 01c2 82E0      		ldi r24,lo8(2)
 1070 01c4 90E0      		ldi r25,hi8(2)
 1071 01c6 8283      		std Z+2,r24
 1072 01c8 9383      		std Z+3,r25
 1073 01ca 8981      		ldd r24,Y+1
 1074 01cc 9A81      		ldd r25,Y+2
 1075 01ce AB81      		ldd r26,Y+3
 1076 01d0 BC81      		ldd r27,Y+4
 1077 01d2 8483      		std Z+4,r24
 1078 01d4 9583      		std Z+5,r25
 1079 01d6 A683      		std Z+6,r26
 1080 01d8 B783      		std Z+7,r27
 1081 01da 8D81      		ldd r24,Y+5
 1082 01dc 9E81      		ldd r25,Y+6
 1083 01de AF81      		ldd r26,Y+7
 1084 01e0 B885      		ldd r27,Y+8
 1085 01e2 8087      		std Z+8,r24
 1086 01e4 9187      		std Z+9,r25
 1087 01e6 A287      		std Z+10,r26
 1088 01e8 B387      		std Z+11,r27
 1089 01ea 89A9      		ldd r24,Y+49
 1090 01ec 9AA9      		ldd r25,Y+50
 1091 01ee 8487      		std Z+12,r24
 1092 01f0 9587      		std Z+13,r25
 1093 01f2 8BA9      		ldd r24,Y+51
 1094 01f4 9CA9      		ldd r25,Y+52
 1095 01f6 8687      		std Z+14,r24
 1096 01f8 9787      		std Z+15,r25
 1097               		.cfi_escape 0x2e,0x10
 1098 01fa 0E94 0000 		call printf
 1099               	.LVL41:
  63:main.c        ****         nmea_parse(&parser, buff[it], (int)strlen(buff[it]), &info);
 1100               		.loc 6 63 0
 1101 01fe 698D      		ldd r22,Y+25
 1102 0200 7A8D      		ldd r23,Y+26
 1103 0202 FB01      		movw r30,r22
 1104 0204 DF01      		movw r26,r30
 1105 0206 0D90      		ld __tmp_reg__,X+
 1106 0208 0020      		tst __tmp_reg__
 1107 020a 01F4      		brne .-6
 1108 020c AD01      		movw r20,r26
 1109 020e 4150      		subi r20,lo8(-(-1))
 1110 0210 5040      		sbci r21,hi8(-(-1))
 1111 0212 4E1B      		sub r20,r30
 1112 0214 5F0B      		sbc r21,r31
 1113 0216 8DB7      		in r24,__SP_L__
 1114 0218 9EB7      		in r25,__SP_H__
 1115 021a 4096      		adiw r24,16
 1116 021c 8DBF      		out __SP_L__,r24
 1117 021e 9EBF      		out __SP_H__,r25
 1118 0220 CE01      		movw r24,r28
 1119 0222 0996      		adiw r24,9
 1120 0224 9E01      		movw r18,r28
 1121 0226 2F5D      		subi r18,lo8(-(33))
 1122 0228 3F4F      		sbci r19,hi8(-(33))
 1123               		.cfi_escape 0x2e,0
 1124 022a 0E94 0000 		call nmea_parse
  64:main.c        ****         nmea_info2pos(&info, &dpos);
 1125               		.loc 6 64 0
 1126 022e CE01      		movw r24,r28
 1127 0230 8196      		adiw r24,33
 1128 0232 BE01      		movw r22,r28
 1129 0234 6F5F      		subi r22,lo8(-(1))
 1130 0236 7F4F      		sbci r23,hi8(-(1))
 1131 0238 0E94 0000 		call nmea_info2pos
  66:main.c        ****         printf(
 1132               		.loc 6 66 0
 1133 023c ADB7      		in r26,__SP_L__
 1134 023e BEB7      		in r27,__SP_H__
 1135 0240 5097      		sbiw r26,16
 1136 0242 ADBF      		out __SP_L__,r26
 1137 0244 BEBF      		out __SP_H__,r27
 1138 0246 EDB7      		in r30,__SP_L__
 1139 0248 FEB7      		in r31,__SP_H__
 1140 024a 3196      		adiw r30,1
 1141 024c 1196      		adiw r26,1
 1142 024e 0D93      		st X+,r16
 1143 0250 1C93      		st X,r17
 1144 0252 1297      		sbiw r26,1+1
 1145 0254 83E0      		ldi r24,lo8(3)
 1146 0256 90E0      		ldi r25,hi8(3)
 1147 0258 8283      		std Z+2,r24
 1148 025a 9383      		std Z+3,r25
 1149 025c 8981      		ldd r24,Y+1
 1150 025e 9A81      		ldd r25,Y+2
 1151 0260 AB81      		ldd r26,Y+3
 1152 0262 BC81      		ldd r27,Y+4
 1153 0264 8483      		std Z+4,r24
 1154 0266 9583      		std Z+5,r25
 1155 0268 A683      		std Z+6,r26
 1156 026a B783      		std Z+7,r27
 1157 026c 8D81      		ldd r24,Y+5
 1158 026e 9E81      		ldd r25,Y+6
 1159 0270 AF81      		ldd r26,Y+7
 1160 0272 B885      		ldd r27,Y+8
 1161 0274 8087      		std Z+8,r24
 1162 0276 9187      		std Z+9,r25
 1163 0278 A287      		std Z+10,r26
 1164 027a B387      		std Z+11,r27
 1165 027c 89A9      		ldd r24,Y+49
 1166 027e 9AA9      		ldd r25,Y+50
 1167 0280 8487      		std Z+12,r24
 1168 0282 9587      		std Z+13,r25
 1169 0284 8BA9      		ldd r24,Y+51
 1170 0286 9CA9      		ldd r25,Y+52
 1171 0288 8687      		std Z+14,r24
 1172 028a 9787      		std Z+15,r25
 1173               		.cfi_escape 0x2e,0x10
 1174 028c 0E94 0000 		call printf
 1175               	.LVL42:
  63:main.c        ****         nmea_parse(&parser, buff[it], (int)strlen(buff[it]), &info);
 1176               		.loc 6 63 0
 1177 0290 6B8D      		ldd r22,Y+27
 1178 0292 7C8D      		ldd r23,Y+28
 1179 0294 FB01      		movw r30,r22
 1180 0296 DF01      		movw r26,r30
 1181 0298 0D90      		ld __tmp_reg__,X+
 1182 029a 0020      		tst __tmp_reg__
 1183 029c 01F4      		brne .-6
 1184 029e AD01      		movw r20,r26
 1185 02a0 4150      		subi r20,lo8(-(-1))
 1186 02a2 5040      		sbci r21,hi8(-(-1))
 1187 02a4 4E1B      		sub r20,r30
 1188 02a6 5F0B      		sbc r21,r31
 1189 02a8 8DB7      		in r24,__SP_L__
 1190 02aa 9EB7      		in r25,__SP_H__
 1191 02ac 4096      		adiw r24,16
 1192 02ae 8DBF      		out __SP_L__,r24
 1193 02b0 9EBF      		out __SP_H__,r25
 1194 02b2 CE01      		movw r24,r28
 1195 02b4 0996      		adiw r24,9
 1196 02b6 9E01      		movw r18,r28
 1197 02b8 2F5D      		subi r18,lo8(-(33))
 1198 02ba 3F4F      		sbci r19,hi8(-(33))
 1199               		.cfi_escape 0x2e,0
 1200 02bc 0E94 0000 		call nmea_parse
  64:main.c        ****         nmea_info2pos(&info, &dpos);
 1201               		.loc 6 64 0
 1202 02c0 CE01      		movw r24,r28
 1203 02c2 8196      		adiw r24,33
 1204 02c4 BE01      		movw r22,r28
 1205 02c6 6F5F      		subi r22,lo8(-(1))
 1206 02c8 7F4F      		sbci r23,hi8(-(1))
 1207 02ca 0E94 0000 		call nmea_info2pos
  66:main.c        ****         printf(
 1208               		.loc 6 66 0
 1209 02ce ADB7      		in r26,__SP_L__
 1210 02d0 BEB7      		in r27,__SP_H__
 1211 02d2 5097      		sbiw r26,16
 1212 02d4 ADBF      		out __SP_L__,r26
 1213 02d6 BEBF      		out __SP_H__,r27
 1214 02d8 EDB7      		in r30,__SP_L__
 1215 02da FEB7      		in r31,__SP_H__
 1216 02dc 3196      		adiw r30,1
 1217 02de 1196      		adiw r26,1
 1218 02e0 0D93      		st X+,r16
 1219 02e2 1C93      		st X,r17
 1220 02e4 1297      		sbiw r26,1+1
 1221 02e6 84E0      		ldi r24,lo8(4)
 1222 02e8 90E0      		ldi r25,hi8(4)
 1223 02ea 8283      		std Z+2,r24
 1224 02ec 9383      		std Z+3,r25
 1225 02ee 8981      		ldd r24,Y+1
 1226 02f0 9A81      		ldd r25,Y+2
 1227 02f2 AB81      		ldd r26,Y+3
 1228 02f4 BC81      		ldd r27,Y+4
 1229 02f6 8483      		std Z+4,r24
 1230 02f8 9583      		std Z+5,r25
 1231 02fa A683      		std Z+6,r26
 1232 02fc B783      		std Z+7,r27
 1233 02fe 8D81      		ldd r24,Y+5
 1234 0300 9E81      		ldd r25,Y+6
 1235 0302 AF81      		ldd r26,Y+7
 1236 0304 B885      		ldd r27,Y+8
 1237 0306 8087      		std Z+8,r24
 1238 0308 9187      		std Z+9,r25
 1239 030a A287      		std Z+10,r26
 1240 030c B387      		std Z+11,r27
 1241 030e 89A9      		ldd r24,Y+49
 1242 0310 9AA9      		ldd r25,Y+50
 1243 0312 8487      		std Z+12,r24
 1244 0314 9587      		std Z+13,r25
 1245 0316 8BA9      		ldd r24,Y+51
 1246 0318 9CA9      		ldd r25,Y+52
 1247 031a 8687      		std Z+14,r24
 1248 031c 9787      		std Z+15,r25
 1249               		.cfi_escape 0x2e,0x10
 1250 031e 0E94 0000 		call printf
 1251               	.LVL43:
  63:main.c        ****         nmea_parse(&parser, buff[it], (int)strlen(buff[it]), &info);
 1252               		.loc 6 63 0
 1253 0322 6D8D      		ldd r22,Y+29
 1254 0324 7E8D      		ldd r23,Y+30
 1255 0326 FB01      		movw r30,r22
 1256 0328 DF01      		movw r26,r30
 1257 032a 0D90      		ld __tmp_reg__,X+
 1258 032c 0020      		tst __tmp_reg__
 1259 032e 01F4      		brne .-6
 1260 0330 AD01      		movw r20,r26
 1261 0332 4150      		subi r20,lo8(-(-1))
 1262 0334 5040      		sbci r21,hi8(-(-1))
 1263 0336 4E1B      		sub r20,r30
 1264 0338 5F0B      		sbc r21,r31
 1265 033a 8DB7      		in r24,__SP_L__
 1266 033c 9EB7      		in r25,__SP_H__
 1267 033e 4096      		adiw r24,16
 1268 0340 8DBF      		out __SP_L__,r24
 1269 0342 9EBF      		out __SP_H__,r25
 1270 0344 CE01      		movw r24,r28
 1271 0346 0996      		adiw r24,9
 1272 0348 9E01      		movw r18,r28
 1273 034a 2F5D      		subi r18,lo8(-(33))
 1274 034c 3F4F      		sbci r19,hi8(-(33))
 1275               		.cfi_escape 0x2e,0
 1276 034e 0E94 0000 		call nmea_parse
  64:main.c        ****         nmea_info2pos(&info, &dpos);
 1277               		.loc 6 64 0
 1278 0352 CE01      		movw r24,r28
 1279 0354 8196      		adiw r24,33
 1280 0356 BE01      		movw r22,r28
 1281 0358 6F5F      		subi r22,lo8(-(1))
 1282 035a 7F4F      		sbci r23,hi8(-(1))
 1283 035c 0E94 0000 		call nmea_info2pos
  66:main.c        ****         printf(
 1284               		.loc 6 66 0
 1285 0360 ADB7      		in r26,__SP_L__
 1286 0362 BEB7      		in r27,__SP_H__
 1287 0364 5097      		sbiw r26,16
 1288 0366 ADBF      		out __SP_L__,r26
 1289 0368 BEBF      		out __SP_H__,r27
 1290 036a EDB7      		in r30,__SP_L__
 1291 036c FEB7      		in r31,__SP_H__
 1292 036e 3196      		adiw r30,1
 1293 0370 1196      		adiw r26,1
 1294 0372 0D93      		st X+,r16
 1295 0374 1C93      		st X,r17
 1296 0376 1297      		sbiw r26,1+1
 1297 0378 85E0      		ldi r24,lo8(5)
 1298 037a 90E0      		ldi r25,hi8(5)
 1299 037c 8283      		std Z+2,r24
 1300 037e 9383      		std Z+3,r25
 1301 0380 8981      		ldd r24,Y+1
 1302 0382 9A81      		ldd r25,Y+2
 1303 0384 AB81      		ldd r26,Y+3
 1304 0386 BC81      		ldd r27,Y+4
 1305 0388 8483      		std Z+4,r24
 1306 038a 9583      		std Z+5,r25
 1307 038c A683      		std Z+6,r26
 1308 038e B783      		std Z+7,r27
 1309 0390 8D81      		ldd r24,Y+5
 1310 0392 9E81      		ldd r25,Y+6
 1311 0394 AF81      		ldd r26,Y+7
 1312 0396 B885      		ldd r27,Y+8
 1313 0398 8087      		std Z+8,r24
 1314 039a 9187      		std Z+9,r25
 1315 039c A287      		std Z+10,r26
 1316 039e B387      		std Z+11,r27
 1317 03a0 89A9      		ldd r24,Y+49
 1318 03a2 9AA9      		ldd r25,Y+50
 1319 03a4 8487      		std Z+12,r24
 1320 03a6 9587      		std Z+13,r25
 1321 03a8 8BA9      		ldd r24,Y+51
 1322 03aa 9CA9      		ldd r25,Y+52
 1323 03ac 8687      		std Z+14,r24
 1324 03ae 9787      		std Z+15,r25
 1325               		.cfi_escape 0x2e,0x10
 1326 03b0 0E94 0000 		call printf
 1327               	.LVL44:
  72:main.c        ****     nmea_parser_destroy(&parser);
 1328               		.loc 6 72 0
 1329 03b4 8DB7      		in r24,__SP_L__
 1330 03b6 9EB7      		in r25,__SP_H__
 1331 03b8 4096      		adiw r24,16
 1332 03ba 8DBF      		out __SP_L__,r24
 1333 03bc 9EBF      		out __SP_H__,r25
 1334 03be CE01      		movw r24,r28
 1335 03c0 0996      		adiw r24,9
 1336               		.cfi_escape 0x2e,0
 1337 03c2 0E94 0000 		call nmea_parser_destroy
 1338               	.LBE334:
 1339               	.LBE333:
 101:main.c        **** 	message = "012345678901234567";
 1340               		.loc 6 101 0
 1341 03c6 80E0      		ldi r24,lo8(.LC9)
 1342 03c8 90E0      		ldi r25,hi8(.LC9)
 1343 03ca 8093 0000 		sts message,r24
 1344 03ce 9093 0000 		sts message+1,r25
 1345               	.L35:
 1346 03d2 00C0      		rjmp .L35
 1347               		.cfi_endproc
 1348               	.LFE63:
 1350               		.text
 1351               	.global	EVENT_USB_Device_ControlRequest
 1353               	EVENT_USB_Device_ControlRequest:
 1354               	.LFB64:
 126:main.c        **** bool EVENT_USB_Device_ControlRequest(USB_Request_Header_t* req){
 1355               		.loc 6 126 0
 1356               		.cfi_startproc
 1357               	.LVL45:
 1358 02ec 0F93      		push r16
 1359               	.LCFI32:
 1360               		.cfi_def_cfa_offset 3
 1361               		.cfi_offset 16, -2
 1362 02ee 1F93      		push r17
 1363               	.LCFI33:
 1364               		.cfi_def_cfa_offset 4
 1365               		.cfi_offset 17, -3
 1366 02f0 CF93      		push r28
 1367               	.LCFI34:
 1368               		.cfi_def_cfa_offset 5
 1369               		.cfi_offset 28, -4
 1370 02f2 DF93      		push r29
 1371               	.LCFI35:
 1372               		.cfi_def_cfa_offset 6
 1373               		.cfi_offset 29, -5
 1374               	/* prologue: function */
 1375               	/* frame size = 0 */
 1376               	/* stack size = 4 */
 1377               	.L__stack_usage = 4
 1378 02f4 9C01      		movw r18,r24
 1379               	.LVL46:
 186:main.c        **** 	return false;
 1380               		.loc 6 186 0
 1381 02f6 A0E0      		ldi r26,lo8(ep0_buf_in)
 1382 02f8 B0E0      		ldi r27,hi8(ep0_buf_in)
 126:main.c        **** bool EVENT_USB_Device_ControlRequest(USB_Request_Header_t* req){
 1383               		.loc 6 126 0
 1384 02fa 8D01      		movw r16,r26
 1385 02fc 80E0      		ldi r24,lo8(ep0_buf_in+64)
 1386 02fe 90E0      		ldi r25,hi8(ep0_buf_in+64)
 1387               	.LVL47:
 1388 0300 FD01      		movw r30,r26
 1389               	.LVL48:
 1390               	.L38:
 1391               	.LBB335:
 128:main.c        **** 	for (uint8_t i = 0; i < 64; i++) ep0_buf_in[i] = 0;
 1392               		.loc 6 128 0 discriminator 2
 1393 0302 1192      		st Z+,__zero_reg__
 1394 0304 40E0      		ldi r20,hi8(ep0_buf_in+64)
 1395 0306 E030      		cpi r30,lo8(ep0_buf_in+64)
 1396 0308 F407      		cpc r31,r20
 1397 030a 01F4      		brne .L38
 1398               	.LBE335:
 129:main.c        **** 	usb_cmd = 0;
 1399               		.loc 6 129 0
 1400 030c 1092 0000 		sts usb_cmd,__zero_reg__
 130:main.c        **** 	if ((req->bmRequestType & CONTROL_REQTYPE_TYPE) == REQTYPE_VENDOR){
 1401               		.loc 6 130 0
 1402 0310 F901      		movw r30,r18
 1403 0312 C081      		ld r28,Z
 1404 0314 D0E0      		ldi r29,lo8(0)
 1405 0316 C076      		andi r28,lo8(96)
 1406 0318 D070      		andi r29,hi8(96)
 1407 031a C034      		cpi r28,64
 1408 031c D105      		cpc r29,__zero_reg__
 1409 031e 01F0      		breq .L62
 1410               	.L56:
 186:main.c        **** 	return false;
 1411               		.loc 6 186 0
 1412 0320 80E0      		ldi r24,lo8(0)
 1413               	.LVL49:
 1414               	.L39:
 1415               	/* epilogue start */
 187:main.c        **** }
 1416               		.loc 6 187 0
 1417 0322 DF91      		pop r29
 1418 0324 CF91      		pop r28
 1419 0326 1F91      		pop r17
 1420 0328 0F91      		pop r16
 1421 032a 0895      		ret
 1422               	.LVL50:
 1423               	.L62:
 131:main.c        **** 		switch(req->bRequest){
 1424               		.loc 6 131 0
 1425 032c 4181      		ldd r20,Z+1
 1426 032e 4631      		cpi r20,lo8(22)
 1427 0330 01F4      		brne .+2
 1428 0332 00C0      		rjmp .L44
 1429 0334 4731      		cpi r20,lo8(23)
 1430 0336 00F0      		brlo .L63
 1431 0338 4B3B      		cpi r20,lo8(-69)
 1432 033a 01F4      		brne .+2
 1433 033c 00C0      		rjmp .L46
 1434 033e 4C3B      		cpi r20,lo8(-68)
 1435 0340 00F0      		brlo .+2
 1436 0342 00C0      		rjmp .L51
 1437 0344 4731      		cpi r20,lo8(23)
 1438 0346 01F4      		brne .L56
 1439               	.LBB336:
 162:main.c        **** 				addr = (uint16_t *) req->wIndex;
 1440               		.loc 6 162 0
 1441 0348 0480      		ldd __tmp_reg__,Z+4
 1442 034a F581      		ldd r31,Z+5
 1443 034c E02D      		mov r30,__tmp_reg__
 1444               	.LVL51:
 163:main.c        **** 				ep0_buf_in[0] = *addr & 0xFF;
 1445               		.loc 6 163 0
 1446 034e 8081      		ld r24,Z
 1447 0350 8093 0000 		sts ep0_buf_in,r24
 164:main.c        **** 				ep0_buf_in[1] = *addr >> 8;
 1448               		.loc 6 164 0
 1449 0354 8181      		ldd r24,Z+1
 1450 0356 8093 0000 		sts ep0_buf_in+1,r24
 1451               	.LVL52:
 1452               	.LBB337:
 1453               	.LBB338:
 1454               	.LBB339:
 1455               	.LBB340:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1456               		.loc 5 168 0
 1457 035a 0093 0000 		sts endpoints+12,r16
 1458 035e 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1459               		.loc 5 169 0
 1460 0362 82E0      		ldi r24,lo8(2)
 1461 0364 90E0      		ldi r25,hi8(2)
 1462 0366 8093 0000 		sts endpoints+10,r24
 1463 036a 9093 0000 		sts endpoints+10+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1464               		.loc 5 174 0
 1465 036e E0E0      		ldi r30,lo8(endpoints+8)
 1466 0370 F0E0      		ldi r31,hi8(endpoints+8)
 1467               	/* #APP */
 1468               	 ;  174 "usb/usb.h" 1
 1469 0372 02E2      		ldi r16, 34
 1470 0374 0693      		.dc.w 0x9306
 1471               		
 1472               	 ;  0 "" 2
 1473               	/* #NOAPP */
 1474               	.LBE340:
 1475               	.LBE339:
 1476               	.LBE338:
 1477               	.LBE337:
 1478               	.LBE336:
 166:main.c        **** 				return true;
 1479               		.loc 6 166 0
 1480 0376 81E0      		ldi r24,lo8(1)
 1481 0378 00C0      		rjmp .L39
 1482               	.LVL53:
 1483               	.L63:
 131:main.c        **** 		switch(req->bRequest){
 1484               		.loc 6 131 0
 1485 037a 4230      		cpi r20,lo8(2)
 1486 037c 01F4      		brne .+2
 1487 037e 00C0      		rjmp .L41
 1488 0380 4330      		cpi r20,lo8(3)
 1489 0382 00F4      		brsh .L50
 1490 0384 4423      		tst r20
 1491 0386 01F4      		brne .L56
 133:main.c        **** 				if (req->wIndex == 0){
 1492               		.loc 6 133 0
 1493 0388 8481      		ldd r24,Z+4
 1494 038a 9581      		ldd r25,Z+5
 1495 038c 0097      		sbiw r24,0
 1496 038e 01F4      		brne .+2
 1497 0390 00C0      		rjmp .L64
 135:main.c        **** 				}else if (req->wIndex == 1){
 1498               		.loc 6 135 0
 1499 0392 8130      		cpi r24,1
 1500 0394 9105      		cpc r25,__zero_reg__
 1501 0396 01F4      		brne .+2
 1502 0398 00C0      		rjmp .L65
 138:main.c        **** 				return true;
 1503               		.loc 6 138 0
 1504 039a 81E0      		ldi r24,lo8(1)
 1505 039c 00C0      		rjmp .L39
 1506               	.L50:
 131:main.c        **** 		switch(req->bRequest){
 1507               		.loc 6 131 0
 1508 039e 4830      		cpi r20,lo8(8)
 1509 03a0 01F0      		breq .L42
 1510 03a2 4930      		cpi r20,lo8(9)
 1511 03a4 01F0      		breq .+2
 1512 03a6 00C0      		rjmp .L56
 153:main.c        **** 				ep0_buf_in[0] = * ((uint8_t *) req->wIndex);
 1513               		.loc 6 153 0
 1514 03a8 0480      		ldd __tmp_reg__,Z+4
 1515 03aa F581      		ldd r31,Z+5
 1516 03ac E02D      		mov r30,__tmp_reg__
 1517 03ae 8081      		ld r24,Z
 1518 03b0 8093 0000 		sts ep0_buf_in,r24
 1519               	.LVL54:
 1520               	.LBB341:
 1521               	.LBB342:
 1522               	.LBB343:
 1523               	.LBB344:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1524               		.loc 5 168 0
 1525 03b4 0093 0000 		sts endpoints+12,r16
 1526 03b8 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1527               		.loc 5 169 0
 1528 03bc 81E0      		ldi r24,lo8(1)
 1529 03be 90E0      		ldi r25,hi8(1)
 1530 03c0 8093 0000 		sts endpoints+10,r24
 1531 03c4 9093 0000 		sts endpoints+10+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1532               		.loc 5 174 0
 1533 03c8 E0E0      		ldi r30,lo8(endpoints+8)
 1534 03ca F0E0      		ldi r31,hi8(endpoints+8)
 1535               	.LVL55:
 1536               	/* #APP */
 1537               	 ;  174 "usb/usb.h" 1
 1538 03cc 02E2      		ldi r16, 34
 1539 03ce 0693      		.dc.w 0x9306
 1540               		
 1541               	 ;  0 "" 2
 1542               	/* #NOAPP */
 1543               	.LBE344:
 1544               	.LBE343:
 1545               	.LBE342:
 1546               	.LBE341:
 155:main.c        **** 				return true;
 1547               		.loc 6 155 0
 1548 03d0 81E0      		ldi r24,lo8(1)
 1549 03d2 00C0      		rjmp .L39
 1550               	.LVL56:
 1551               	.L51:
 131:main.c        **** 		switch(req->bRequest){
 1552               		.loc 6 131 0
 1553 03d4 403E      		cpi r20,lo8(-32)
 1554 03d6 01F0      		breq .L47
 1555 03d8 413E      		cpi r20,lo8(-31)
 1556 03da 01F0      		breq .+2
 1557 03dc 00C0      		rjmp .L56
 175:main.c        **** 				usb_cmd = req->bRequest;
 1558               		.loc 6 175 0
 1559 03de 4093 0000 		sts usb_cmd,r20
 176:main.c        **** 				cmd_data = req->wIndex;
 1560               		.loc 6 176 0
 1561 03e2 8481      		ldd r24,Z+4
 1562 03e4 8093 0000 		sts cmd_data,r24
 1563               	.LVL57:
 1564               	.L61:
 1565               	.LBB345:
 1566               	.LBB346:
 1567               	.LBB347:
 1568               	.LBB348:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1569               		.loc 5 168 0
 1570 03e8 0093 0000 		sts endpoints+12,r16
 1571 03ec 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1572               		.loc 5 169 0
 1573 03f0 1092 0000 		sts endpoints+10,__zero_reg__
 1574 03f4 1092 0000 		sts endpoints+10+1,__zero_reg__
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1575               		.loc 5 174 0
 1576 03f8 E0E0      		ldi r30,lo8(endpoints+8)
 1577 03fa F0E0      		ldi r31,hi8(endpoints+8)
 1578               	.LVL58:
 1579               	/* #APP */
 1580               	 ;  174 "usb/usb.h" 1
 1581 03fc 02E2      		ldi r16, 34
 1582 03fe 0693      		.dc.w 0x9306
 1583               		
 1584               	 ;  0 "" 2
 1585               	/* #NOAPP */
 1586               	.LBE348:
 1587               	.LBE347:
 1588               	.LBE346:
 1589               	.LBE345:
 159:main.c        **** 				return true;
 1590               		.loc 6 159 0
 1591 0400 81E0      		ldi r24,lo8(1)
 1592               	/* epilogue start */
 187:main.c        **** }
 1593               		.loc 6 187 0
 1594 0402 DF91      		pop r29
 1595 0404 CF91      		pop r28
 1596 0406 1F91      		pop r17
 1597 0408 0F91      		pop r16
 1598 040a 0895      		ret
 1599               	.LVL59:
 1600               	.L42:
 149:main.c        **** 				* ((uint8_t *) req->wIndex) = req->wValue;
 1601               		.loc 6 149 0
 1602 040c D901      		movw r26,r18
 1603 040e 0480      		ldd __tmp_reg__,Z+4
 1604 0410 F581      		ldd r31,Z+5
 1605 0412 E02D      		mov r30,__tmp_reg__
 1606 0414 1296      		adiw r26,2
 1607 0416 8C91      		ld r24,X
 1608 0418 1297      		sbiw r26,2
 1609 041a 8083      		st Z,r24
 1610               	.LVL60:
 1611 041c 00C0      		rjmp .L61
 1612               	.LVL61:
 1613               	.L47:
 169:main.c        **** 				eeprom_read_block(ep0_buf_in, (void*)(req->wIndex*64), 64);
 1614               		.loc 6 169 0
 1615 041e F901      		movw r30,r18
 1616 0420 6481      		ldd r22,Z+4
 1617 0422 7581      		ldd r23,Z+5
 1618 0424 0024      		clr __tmp_reg__
 1619 0426 7695      		lsr r23
 1620 0428 6795      		ror r22
 1621 042a 0794      		ror __tmp_reg__
 1622 042c 7695      		lsr r23
 1623 042e 6795      		ror r22
 1624 0430 0794      		ror __tmp_reg__
 1625 0432 762F      		mov r23,r22
 1626 0434 602D      		mov r22,__tmp_reg__
 1627 0436 80E0      		ldi r24,lo8(ep0_buf_in)
 1628 0438 90E0      		ldi r25,hi8(ep0_buf_in)
 1629 043a 40E4      		ldi r20,lo8(64)
 1630 043c 50E0      		ldi r21,hi8(64)
 1631 043e 0E94 0000 		call __eerd_block_x32a4u
 1632               	.LVL62:
 1633               	.LBB349:
 1634               	.LBB350:
 1635               	.LBB351:
 1636               	.LBB352:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1637               		.loc 5 168 0
 1638 0442 0093 0000 		sts endpoints+12,r16
 1639 0446 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1640               		.loc 5 169 0
 1641 044a C093 0000 		sts endpoints+10,r28
 1642 044e D093 0000 		sts endpoints+10+1,r29
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1643               		.loc 5 174 0
 1644 0452 E0E0      		ldi r30,lo8(endpoints+8)
 1645 0454 F0E0      		ldi r31,hi8(endpoints+8)
 1646               	.LVL63:
 1647               	/* #APP */
 1648               	 ;  174 "usb/usb.h" 1
 1649 0456 02E2      		ldi r16, 34
 1650 0458 0693      		.dc.w 0x9306
 1651               		
 1652               	 ;  0 "" 2
 1653               	/* #NOAPP */
 1654               	.LBE352:
 1655               	.LBE351:
 1656               	.LBE350:
 1657               	.LBE349:
 171:main.c        **** 				return true;
 1658               		.loc 6 171 0
 1659 045a 81E0      		ldi r24,lo8(1)
 1660 045c 00C0      		rjmp .L39
 1661               	.LVL64:
 1662               	.L46:
 1663               	.LBB353:
 1664               	.LBB354:
 330:usb/usb.h     **** 		USB_ep0_enableOut();
 331:usb/usb.h     **** 	}
 332:usb/usb.h     **** }
 333:usb/usb.h     **** 
 334:usb/usb.h     **** static inline void USB_enter_bootloader(void){
 335:usb/usb.h     **** 	cli();
 1665               		.loc 5 335 0
 1666               	/* #APP */
 1667               	 ;  335 "usb/usb.h" 1
 1668 045e F894      		cli
 1669               	 ;  0 "" 2
 1670               	.LVL65:
 1671               	/* #NOAPP */
 1672               	.LBB355:
 1673               	.LBB356:
 1674               	.LBB357:
 1675               	.LBB358:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1676               		.loc 5 168 0
 1677 0460 0093 0000 		sts endpoints+12,r16
 1678 0464 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1679               		.loc 5 169 0
 1680 0468 1092 0000 		sts endpoints+10,__zero_reg__
 1681 046c 1092 0000 		sts endpoints+10+1,__zero_reg__
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1682               		.loc 5 174 0
 1683 0470 E0E0      		ldi r30,lo8(endpoints+8)
 1684 0472 F0E0      		ldi r31,hi8(endpoints+8)
 1685               	.LVL66:
 1686               	/* #APP */
 1687               	 ;  174 "usb/usb.h" 1
 1688 0474 02E2      		ldi r16, 34
 1689 0476 0693      		.dc.w 0x9306
 1690               		
 1691               	 ;  0 "" 2
 1692               	/* #NOAPP */
 1693               	.LBE358:
 1694               	.LBE357:
 1695               	.LBE356:
 1696               	.LBE355:
 1697               	.LBB359:
 1698               	.LBB360:
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 1699               		.loc 5 280 0
 1700 0478 3897      		sbiw r30,8
 1701               	.LVL67:
 1702               	/* #APP */
 1703               	 ;  280 "usb/usb.h" 1
 1704 047a 02E7      		ldi r16, 114
 1705 047c 0693      		.dc.w 0x9306
 1706               		
 1707               	 ;  0 "" 2
 1708               	.LVL68:
 1709               	/* #NOAPP */
 1710               	.L54:
 1711               	.LBE360:
 1712               	.LBE359:
 1713               	.LBB361:
 1714               	.LBB362:
 1715               	.LBB363:
 1716               	.LBB364:
 202:usb/usb.h     **** 		return e->STATUS & USB_EP_TRNCOMPL0_bm;
 1717               		.loc 5 202 0
 1718 047e 8091 0000 		lds r24,endpoints
 1719               	.LBE364:
 1720               	.LBE363:
 253:usb/usb.h     **** 	while (!USB_ep_done(ep)){};
 1721               		.loc 5 253 0
 1722 0482 85FF      		sbrs r24,5
 1723 0484 00C0      		rjmp .L54
 1724               	.LVL69:
 1725               	.LBE362:
 1726               	.LBE361:
 1727               	.LBB365:
 1728               	.LBB366:
 1729               		.file 7 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h"
   1:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
 103:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 104:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /**
 105:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 109:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 112:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 120:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 129:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 132:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 140:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** {
 144:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 156:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 159:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 164:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1730               		.loc 7 164 0
 1731 0486 8FEF      		 ldi r24,lo8(63999)
 1732 0488 99EF      	    ldi r25,hi8(63999)
 1733 048a A0E0      	    ldi r26,hlo8(63999)
 1734 048c 8150      	    1:subi r24,1
 1735 048e 9040      	    sbci r25,0
 1736 0490 A040      	    sbci r26,0
 1737 0492 01F4      	    brne 1b
 1738 0494 00C0      		rjmp .
 1739 0496 0000      		nop
 1740               	.LBE366:
 1741               	.LBE365:
 1742               	.LBB367:
 1743               	.LBB368:
 296:usb/usb.h     **** 	USB.CTRLB &= ~USB_ATTACH_bm;
 1744               		.loc 5 296 0
 1745 0498 8091 C104 		lds r24,1217
 1746 049c 8E7F      		andi r24,lo8(-2)
 1747 049e E0EC      		ldi r30,lo8(1216)
 1748 04a0 F4E0      		ldi r31,hi8(1216)
 1749               	.LVL70:
 1750 04a2 8183      		std Z+1,r24
 1751               	.LVL71:
 1752               	.LBE368:
 1753               	.LBE367:
 1754               	.LBB369:
 1755               	.LBB370:
 1756               		.loc 7 164 0
 1757 04a4 8FEF      		 ldi r24,lo8(639999)
 1758 04a6 93EC      	    ldi r25,hi8(639999)
 1759 04a8 A9E0      	    ldi r26,hlo8(639999)
 1760 04aa 8150      	    1:subi r24,1
 1761 04ac 9040      	    sbci r25,0
 1762 04ae A040      	    sbci r26,0
 1763 04b0 01F4      	    brne 1b
 1764 04b2 00C0      		rjmp .
 1765 04b4 0000      		nop
 1766               	.LVL72:
 1767               	.LBE370:
 1768               	.LBE369:
 336:usb/usb.h     **** 	USB_ep0_send(0);
 337:usb/usb.h     **** 	USB_ep0_enableOut();
 338:usb/usb.h     **** 	USB_ep_wait(0x00); // Wait for the status stage to complete
 339:usb/usb.h     **** 	_delay_ms(10);
 340:usb/usb.h     **** 	USB_Detach();
 341:usb/usb.h     **** 	_delay_ms(100);
 342:usb/usb.h     **** 	void (*enter_bootloader)(void) = (void*) 0x47fc /*0x8ff8/2*/;
 343:usb/usb.h     **** 	enter_bootloader();
 1769               		.loc 5 343 0
 1770 04b6 ECEF      		ldi r30,lo8(18428)
 1771 04b8 F7E4      		ldi r31,hi8(18428)
 1772 04ba 0995      		icall
 1773               	.LVL73:
 1774               	.LBE354:
 1775               	.LBE353:
 183:main.c        **** 				return true;
 1776               		.loc 6 183 0
 1777 04bc 81E0      		ldi r24,lo8(1)
 1778 04be 00C0      		rjmp .L39
 1779               	.LVL74:
 1780               	.L41:
 1781               	.LBB371:
 141:main.c        **** 					int l = strlen(message);
 1782               		.loc 6 141 0
 1783 04c0 3091 0000 		lds r19,message
 1784 04c4 2091 0000 		lds r18,message+1
 1785               	.LVL75:
 1786 04c8 C32F      		mov r28,r19
 1787 04ca D22F      		mov r29,r18
 1788 04cc FE01      		movw r30,r28
 1789               	.LVL76:
 1790 04ce 0190      		ld __tmp_reg__,Z+
 1791 04d0 0020      		tst __tmp_reg__
 1792 04d2 01F4      		brne .-6
 1793 04d4 3197      		sbiw r30,1
 1794 04d6 E31B      		sub r30,r19
 1795               	.LVL77:
 1796               	.L53:
 1797               	.LBB372:
 143:main.c        **** 						ep0_buf_in[i] = message[i];
 1798               		.loc 6 143 0 discriminator 2
 1799 04d8 2991      		ld r18,Y+
 1800 04da 2D93      		st X+,r18
 142:main.c        **** 					for (uint8_t i=0; i<64; i++) {
 1801               		.loc 6 142 0 discriminator 2
 1802 04dc 8A17      		cp r24,r26
 1803 04de 9B07      		cpc r25,r27
 1804 04e0 01F4      		brne .L53
 1805               	.LVL78:
 1806               	.LBE372:
 1807               	.LBB373:
 1808               	.LBB374:
 247:usb/usb.h     **** 	USB_ep_in_start(0x80, ep0_buf_in, size);
 1809               		.loc 5 247 0
 1810 04e2 8E2F      		mov r24,r30
 1811 04e4 90E0      		ldi r25,lo8(0)
 1812               	.LVL79:
 1813               	.LBB375:
 1814               	.LBB376:
 1815               	.LBB377:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1816               		.loc 5 168 0
 1817 04e6 0093 0000 		sts endpoints+12,r16
 1818 04ea 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1819               		.loc 5 169 0
 1820 04ee 8093 0000 		sts endpoints+10,r24
 1821 04f2 9093 0000 		sts endpoints+10+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1822               		.loc 5 174 0
 1823 04f6 E0E0      		ldi r30,lo8(endpoints+8)
 1824 04f8 F0E0      		ldi r31,hi8(endpoints+8)
 1825               	.LVL80:
 1826               	/* #APP */
 1827               	 ;  174 "usb/usb.h" 1
 1828 04fa 02E2      		ldi r16, 34
 1829 04fc 0693      		.dc.w 0x9306
 1830               		
 1831               	 ;  0 "" 2
 1832               	/* #NOAPP */
 1833               	.LBE377:
 1834               	.LBE376:
 1835               	.LBE375:
 1836               	.LBE374:
 1837               	.LBE373:
 146:main.c        **** 					return true;
 1838               		.loc 6 146 0
 1839 04fe 81E0      		ldi r24,lo8(1)
 1840               	.LVL81:
 1841 0500 00C0      		rjmp .L39
 1842               	.LVL82:
 1843               	.L44:
 1844               	.LBE371:
 157:main.c        **** 				* ((uint16_t *) req->wIndex) = req->wValue;
 1845               		.loc 6 157 0
 1846 0502 F901      		movw r30,r18
 1847 0504 8281      		ldd r24,Z+2
 1848 0506 9381      		ldd r25,Z+3
 1849 0508 0480      		ldd __tmp_reg__,Z+4
 1850 050a F581      		ldd r31,Z+5
 1851 050c E02D      		mov r30,__tmp_reg__
 1852 050e 8083      		st Z,r24
 1853 0510 9183      		std Z+1,r25
 1854 0512 00C0      		rjmp .L61
 1855               	.L65:
 136:main.c        **** 					USB_ep0_send_progmem((uint8_t*)fwversion, sizeof(fwversion));
 1856               		.loc 6 136 0
 1857 0514 80E0      		ldi r24,lo8(fwversion)
 1858 0516 90E0      		ldi r25,hi8(fwversion)
 1859 0518 6BE0      		ldi r22,lo8(11)
 1860 051a 70E0      		ldi r23,hi8(11)
 1861 051c 0E94 0000 		call USB_ep0_send_progmem
 1862               	.LVL83:
 138:main.c        **** 				return true;
 1863               		.loc 6 138 0
 1864 0520 81E0      		ldi r24,lo8(1)
 1865 0522 00C0      		rjmp .L39
 1866               	.LVL84:
 1867               	.L64:
 134:main.c        **** 					USB_ep0_send_progmem((uint8_t*)hwversion, sizeof(hwversion));
 1868               		.loc 6 134 0
 1869 0524 80E0      		ldi r24,lo8(hwversion)
 1870 0526 90E0      		ldi r25,hi8(hwversion)
 1871 0528 6BE0      		ldi r22,lo8(11)
 1872 052a 70E0      		ldi r23,hi8(11)
 1873 052c 0E94 0000 		call USB_ep0_send_progmem
 1874               	.LVL85:
 138:main.c        **** 				return true;
 1875               		.loc 6 138 0
 1876 0530 81E0      		ldi r24,lo8(1)
 1877 0532 00C0      		rjmp .L39
 1878               		.cfi_endproc
 1879               	.LFE64:
 1881               	.global	EVENT_USB_Device_ControlOUT
 1883               	EVENT_USB_Device_ControlOUT:
 1884               	.LFB65:
 189:main.c        **** void EVENT_USB_Device_ControlOUT(uint8_t* buf, uint8_t count){
 1885               		.loc 6 189 0
 1886               		.cfi_startproc
 1887               	.LVL86:
 1888               	/* prologue: function */
 1889               	/* frame size = 0 */
 1890               	/* stack size = 0 */
 1891               	.L__stack_usage = 0
 1892 0534 462F      		mov r20,r22
 190:main.c        **** 	switch (usb_cmd){
 1893               		.loc 6 190 0
 1894 0536 2091 0000 		lds r18,usb_cmd
 1895 053a 213E      		cpi r18,lo8(-31)
 1896 053c 01F0      		breq .L69
 1897               	.LVL87:
 1898 053e 0895      		ret
 1899               	.L69:
 1900               		.loc 6 192 0
 1901 0540 2091 0000 		lds r18,cmd_data
 1902 0544 30E0      		ldi r19,lo8(0)
 1903 0546 0024      		clr __tmp_reg__
 1904 0548 3695      		lsr r19
 1905 054a 2795      		ror r18
 1906 054c 0794      		ror __tmp_reg__
 1907 054e 3695      		lsr r19
 1908 0550 2795      		ror r18
 1909 0552 0794      		ror __tmp_reg__
 1910 0554 322F      		mov r19,r18
 1911 0556 202D      		mov r18,__tmp_reg__
 1912 0558 B901      		movw r22,r18
 1913 055a 50E0      		ldi r21,lo8(0)
 1914 055c 0E94 0000 		call __eeupd_block_x32a4u
 1915               	.LVL88:
 1916 0560 0895      		ret
 1917               		.cfi_endproc
 1918               	.LFE65:
 1920               	.global	cmd_data
 1921               	.global	cmd_data
 1922               		.section .bss
 1925               	cmd_data:
 1926 0000 00        		.skip 1,0
 1927               	.global	usb_cmd
 1928               	.global	usb_cmd
 1931               	usb_cmd:
 1932 0001 00        		.skip 1,0
 1933               	.global	fwversion
 1934               		.section	.progmem.data,"a",@progbits
 1937               	fwversion:
 1938 0000 4657 5F56 		.string	"FW_VERSION"
 1938      4552 5349 
 1938      4F4E 00
 1939               	.global	hwversion
 1942               	hwversion:
 1943 000b 4857 5F56 		.string	"HW_VERSION"
 1943      4552 5349 
 1943      4F4E 00
 1944               		.comm message,2,1
 1945               	.global	updating
 1946               	.global	updating
 1947               		.section .bss
 1950               	updating:
 1951 0002 00        		.skip 1,0
 1952               	.global	timeout_or_sampling_no_longer_enabled
 1953               	.global	timeout_or_sampling_no_longer_enabled
 1956               	timeout_or_sampling_no_longer_enabled:
 1957 0003 00        		.skip 1,0
 1958               	.global	ep_in_data
 1959               	.global	ep_in_data
 1962               	ep_in_data:
 1963 0004 0000 0000 		.skip 4,0
 1964               	.global	ep_in_pipe_data
 1965               		.data
 1968               	ep_in_pipe_data:
 1969 0219 0000      		.word	ep_in_pipe_buffer
 1970 021b 0000      		.word	ep_in_pipe_buffer
 1971 021d 00        		.byte	0
 1972               		.comm ep_in_pipe_buffer,512,1
 1973               		.text
 1974               	.Letext0:
 1975               		.file 8 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/stdint.h"
 1976               		.file 9 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/avr/iox32a4u.h"
 1977               		.file 10 "usb/StdRequestType.h"
 1978               		.file 11 "nmea/./time.h"
 1979               		.file 12 "nmea/./info.h"
 1980               		.file 13 "nmea/./parser.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc9nIcij.s:2      *ABS*:000000000000003f __SREG__
     /tmp/cc9nIcij.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/cc9nIcij.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/cc9nIcij.s:5      *ABS*:0000000000000034 __CCP__
     /tmp/cc9nIcij.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc9nIcij.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc9nIcij.s:15     .text:0000000000000000 EVENT_USB_Device_ConfigurationChanged
     /tmp/cc9nIcij.s:1968   .data:0000000000000219 ep_in_pipe_data
                            *COM*:0000000000000200 ep_in_pipe_buffer
     /tmp/cc9nIcij.s:1962   .bss:0000000000000004 ep_in_data
     /tmp/cc9nIcij.s:108    .text:000000000000004e __vector_125
     /tmp/cc9nIcij.s:246    .text:00000000000000d8 __vector_126
     /tmp/cc9nIcij.s:1931   .bss:0000000000000001 usb_cmd
     /tmp/cc9nIcij.s:1925   .bss:0000000000000000 cmd_data
     /tmp/cc9nIcij.s:808    .text.startup:0000000000000000 main
                            *COM*:0000000000000002 message
     /tmp/cc9nIcij.s:1353   .text:00000000000002ec EVENT_USB_Device_ControlRequest
     /tmp/cc9nIcij.s:1937   .progmem.data:0000000000000000 fwversion
     /tmp/cc9nIcij.s:1942   .progmem.data:000000000000000b hwversion
     /tmp/cc9nIcij.s:1883   .text:0000000000000534 EVENT_USB_Device_ControlOUT
     /tmp/cc9nIcij.s:1950   .bss:0000000000000002 updating
     /tmp/cc9nIcij.s:1956   .bss:0000000000000003 timeout_or_sampling_no_longer_enabled

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
endpoints
USB_Init
USB_HandleSetup
ep0_buf_out
__eeupd_block_x32a4u
USB_ConfigureClock
nmea_zero_INFO
nmea_parser_init
nmea_parse
nmea_info2pos
printf
nmea_parser_destroy
ep0_buf_in
__eerd_block_x32a4u
USB_ep0_send_progmem
