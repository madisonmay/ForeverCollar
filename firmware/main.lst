   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  14               	break_and_flush:
  15               	.LFB56:
  16               		.file 1 "Framework.h"
   1:Framework.h   **** #pragma once
   2:Framework.h   **** #define F_CPU 32000000UL
   3:Framework.h   **** 
   4:Framework.h   **** // includes
   5:Framework.h   **** #include <avr/interrupt.h>
   6:Framework.h   **** #include <util/delay.h>
   7:Framework.h   **** #include "Descriptors.h"
   8:Framework.h   **** #include "usb/usb.h"
   9:Framework.h   **** #include "usb/usb_pipe.h"
  10:Framework.h   **** #include <avr/eeprom.h>
  11:Framework.h   **** #include <avr/io.h>
  12:Framework.h   **** 
  13:Framework.h   **** USB_PIPE(ep_in, 0x81 | USB_EP_PP, USB_EP_TYPE_BULK_gc, 64, 8, PIPE_ENABLE_FLUSH);
  14:Framework.h   **** 
  15:Framework.h   **** bool timeout_or_sampling_no_longer_enabled = 0;
  16:Framework.h   **** 
  17:Framework.h   **** // Queue a byte to be sent over the bulk EP. Blocks if the buffer is full
  18:Framework.h   **** static inline void send_byte(uint8_t byte){
  19:Framework.h   ****     // this should never actually block if your buffer is big enough
  20:Framework.h   ****     while (!usb_pipe_can_write(&ep_in));
  21:Framework.h   **** 	usb_pipe_write_byte(&ep_in, byte);
  22:Framework.h   **** }
  23:Framework.h   **** 
  24:Framework.h   **** // Sends a break to end the USB read and flushes the USB pipe
  25:Framework.h   **** static inline void break_and_flush(){
  17               		.loc 1 25 0
  18               		.cfi_startproc
  19 0000 0F93      		push r16
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 3
  22               		.cfi_offset 16, -2
  23               	/* prologue: function */
  24               	/* frame size = 0 */
  25               	/* stack size = 1 */
  26               	.L__stack_usage = 1
  27               	.LVL0:
  28               	.LBB430:
  29               	.LBB431:
  30               		.file 2 "usb/usb_pipe.h"
   1:usb/usb_pipe.h **** #include "pipe.h"
   2:usb/usb_pipe.h **** #include "usb.h"
   3:usb/usb_pipe.h **** 
   4:usb/usb_pipe.h **** #include <util/atomic.h>
   5:usb/usb_pipe.h **** #ifndef PIPE_ATOMIC
   6:usb/usb_pipe.h **** #define PIPE_ATOMIC ATOMIC_RESTORESTATE
   7:usb/usb_pipe.h **** #endif 
   8:usb/usb_pipe.h **** 
   9:usb/usb_pipe.h **** typedef struct USB_Pipe_data{
  10:usb/usb_pipe.h **** 	bool bank;
  11:usb/usb_pipe.h **** 	uint8_t flush;
  12:usb/usb_pipe.h **** 	uint16_t packet_offset; // Index into current packet for byte mode
  13:usb/usb_pipe.h **** } USB_Pipe_data;
  14:usb/usb_pipe.h **** 
  15:usb/usb_pipe.h **** // Immutable part, constant-folded at compile time
  16:usb/usb_pipe.h **** typedef struct USB_Pipe{
  17:usb/usb_pipe.h **** 	uint8_t ep;
  18:usb/usb_pipe.h **** 	uint8_t type;
  19:usb/usb_pipe.h **** 	USB_Pipe_data* data;
  20:usb/usb_pipe.h **** 	const Pipe* pipe;
  21:usb/usb_pipe.h **** 	uint8_t features;
  22:usb/usb_pipe.h **** } USB_Pipe;
  23:usb/usb_pipe.h **** 
  24:usb/usb_pipe.h **** #define PIPE_ENABLE_FLUSH (1<<0)
  25:usb/usb_pipe.h **** 
  26:usb/usb_pipe.h **** #define USB_PIPE(NAME, EPNO, TYPE, PACKET_SIZE, BUFFER_PACKETS, FEATURES) \
  27:usb/usb_pipe.h **** 	PIPE(NAME##_pipe, (BUFFER_PACKETS), (PACKET_SIZE),               \
  28:usb/usb_pipe.h **** 		((EPNO)&USB_EP_IN)?0:2,                      \
  29:usb/usb_pipe.h **** 		((EPNO)&USB_EP_IN)?2:0                       \
  30:usb/usb_pipe.h **** 	);                                               \
  31:usb/usb_pipe.h **** 	USB_Pipe_data NAME##_data = {      \
  32:usb/usb_pipe.h **** 		.bank = 0,                   \
  33:usb/usb_pipe.h **** 		.flush = 0,                    \
  34:usb/usb_pipe.h **** 	};                                 \
  35:usb/usb_pipe.h **** 	const static USB_Pipe NAME = {     \
  36:usb/usb_pipe.h **** 		.ep = (EPNO),                  \
  37:usb/usb_pipe.h **** 		.type = (TYPE),                \
  38:usb/usb_pipe.h **** 		.data = &(NAME##_data),        \
  39:usb/usb_pipe.h **** 		.pipe = &(NAME##_pipe),        \
  40:usb/usb_pipe.h **** 		.features = (FEATURES),        \
  41:usb/usb_pipe.h **** 	};                                 \
  42:usb/usb_pipe.h **** 
  43:usb/usb_pipe.h **** static inline void usb_pipe_init(const USB_Pipe* p){
  44:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
  45:usb/usb_pipe.h **** 		pipe_reset(p->pipe);
  46:usb/usb_pipe.h **** 		USB_ep_init(p->ep, p->type, p->pipe->size);
  47:usb/usb_pipe.h **** 		p->data->bank = 0;
  48:usb/usb_pipe.h **** 		p->data->flush = 0;
  49:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
  50:usb/usb_pipe.h **** 	}
  51:usb/usb_pipe.h **** }
  52:usb/usb_pipe.h **** 
  53:usb/usb_pipe.h **** static inline void usb_pipe_reset(const USB_Pipe* p){
  54:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
  55:usb/usb_pipe.h **** 		pipe_reset(p->pipe);
  56:usb/usb_pipe.h **** 		USB_ep_cancel(p->ep);
  57:usb/usb_pipe.h **** 		p->data->flush = 0;
  58:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
  59:usb/usb_pipe.h **** 		p->data->bank = 0;
  60:usb/usb_pipe.h **** 	}
  61:usb/usb_pipe.h **** }
  62:usb/usb_pipe.h **** 
  63:usb/usb_pipe.h **** static inline void _usb_pipe_ep_start(const USB_Pipe* p, uint8_t* data, uint16_t size) ATTR_ALWAYS_
  64:usb/usb_pipe.h **** static inline void _usb_pipe_ep_start(const USB_Pipe* p, uint8_t* data, uint16_t size){
  65:usb/usb_pipe.h **** 	bool bank = 0;
  66:usb/usb_pipe.h **** 
  67:usb/usb_pipe.h **** 	if (p->ep & USB_EP_PP){
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
  70:usb/usb_pipe.h **** 	}
  71:usb/usb_pipe.h **** 
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
  73:usb/usb_pipe.h **** 		USB_ep_start_bank(p->ep, 0, data, size);
  74:usb/usb_pipe.h **** 	}else{
  75:usb/usb_pipe.h **** 		USB_ep_start_bank(p->ep, 1, data, size);
  76:usb/usb_pipe.h **** 	}
  77:usb/usb_pipe.h **** }
  78:usb/usb_pipe.h **** 
  79:usb/usb_pipe.h **** static inline void usb_pipe_handle(const USB_Pipe* p){
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
  81:usb/usb_pipe.h **** 		if (p->ep & USB_EP_IN){
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
  84:usb/usb_pipe.h **** 					_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->pipe->size);
  85:usb/usb_pipe.h **** 					pipe_done_read(p->pipe);
  86:usb/usb_pipe.h **** 				}else if (p->features & PIPE_ENABLE_FLUSH){
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
  89:usb/usb_pipe.h **** 						// Send short packet
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
  94:usb/usb_pipe.h **** 						pipe_reset(p->pipe);
  95:usb/usb_pipe.h **** 					}
  96:usb/usb_pipe.h **** 				}
  97:usb/usb_pipe.h **** 			}
  98:usb/usb_pipe.h **** 		}else{
  99:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep) && pipe_can_write(p->pipe) >= 1){
 100:usb/usb_pipe.h **** 				_usb_pipe_ep_start(p, pipe_write_ptr(p->pipe), p->pipe->size);
 101:usb/usb_pipe.h **** 				pipe_done_write(p->pipe);
 102:usb/usb_pipe.h **** 			}
 103:usb/usb_pipe.h **** 		}
 104:usb/usb_pipe.h **** 	}
 105:usb/usb_pipe.h **** }
 106:usb/usb_pipe.h **** 
 107:usb/usb_pipe.h **** static inline void usb_pipe_flush(const USB_Pipe* p) ATTR_ALWAYS_INLINE;
 108:usb/usb_pipe.h **** static inline void usb_pipe_flush(const USB_Pipe* p){
 109:usb/usb_pipe.h **** 	GCC_ASSERT(p->features&PIPE_ENABLE_FLUSH && p->ep&USB_EP_IN);
 110:usb/usb_pipe.h **** 	p->data->flush = 1;
  31               		.loc 2 110 0
  32 0002 81E0      		ldi r24,lo8(1)
  33 0004 8093 0000 		sts ep_in_data+1,r24
  34               	.LVL1:
  35               	.LBB432:
  36               	.LBB433:
  37               	.LBB434:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
  38               		.loc 2 80 0
  39 0008 2FB7      		in r18,__SREG__
  40               	.LVL2:
  41               	.LBB435:
  42               	.LBB436:
  43               		.file 3 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h"
   1:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    All rights reserved.
   3:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
   4:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
   7:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  10:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      distribution.
  14:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  15:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      from this software without specific prior written permission.
  18:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  19:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** */
  31:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  32:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** /* $Id: atomic.h 2158 2010-06-10 15:48:28Z joerg_wunsch $ */
  33:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  34:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  37:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #include <avr/io.h>
  38:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #include <avr/interrupt.h>
  39:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  40:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #if !defined(__DOXYGEN__)
  41:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** /* Internal helper functions. */
  42:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  44:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     sei();
  45:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     return 1;
  46:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** }
  47:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  48:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
  49:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
  44               		.loc 3 50 0
  45               	/* #APP */
  46               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
  47 000a F894      		cli
  48               	 ;  0 "" 2
  49               	.LVL3:
  50               	/* #NOAPP */
  51               	.LBE436:
  52               	.LBE435:
  53               	.LBB437:
  54               	.LBB438:
  55               		.file 4 "usb/usb.h"
   1:usb/usb.h     **** // Minimal USB Stack for ATxmega32a4u and related
   2:usb/usb.h     **** // http://nonolithlabs.com
   3:usb/usb.h     **** // (C) 2011 Kevin Mehall (Nonolith Labs) <km@kevinmehall.net>
   4:usb/usb.h     **** //
   5:usb/usb.h     **** // Heavily borrows from LUFA
   6:usb/usb.h     **** // Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
   7:usb/usb.h     **** //
   8:usb/usb.h     **** // Licensed under the terms of the GNU GPLv3+
   9:usb/usb.h     **** 
  10:usb/usb.h     **** #pragma once
  11:usb/usb.h     **** 
  12:usb/usb.h     **** #include <avr/io.h>
  13:usb/usb.h     **** 
  14:usb/usb.h     **** #define CPU_TO_LE16(x) x
  15:usb/usb.h     **** 
  16:usb/usb.h     **** struct USB_Request_Header;
  17:usb/usb.h     **** typedef struct USB_Request_Header USB_Requst_Header_t;
  18:usb/usb.h     **** 
  19:usb/usb.h     **** #include "StdDescriptors.h"
  20:usb/usb.h     **** #include "StdRequestType.h"
  21:usb/usb.h     **** #include "Events.h"
  22:usb/usb.h     **** 
  23:usb/usb.h     **** #ifndef USB_MAXEP
  24:usb/usb.h     **** 	#define USB_MAXEP 1
  25:usb/usb.h     **** #endif
  26:usb/usb.h     **** 
  27:usb/usb.h     **** #ifndef USB_EP0SIZE
  28:usb/usb.h     **** 	#define EP0SIZE 64
  29:usb/usb.h     **** #endif
  30:usb/usb.h     **** 
  31:usb/usb.h     **** typedef union USB_EP_pair{
  32:usb/usb.h     **** 	union{
  33:usb/usb.h     **** 		struct{
  34:usb/usb.h     **** 			USB_EP_t out;
  35:usb/usb.h     **** 			USB_EP_t in;
  36:usb/usb.h     **** 		};
  37:usb/usb.h     **** 		USB_EP_t ep[2];
  38:usb/usb.h     **** 	};
  39:usb/usb.h     **** } ATTR_PACKED USB_EP_pair_t;
  40:usb/usb.h     **** 
  41:usb/usb.h     **** extern uint8_t ep0_buf_in[USB_EP0SIZE];
  42:usb/usb.h     **** extern uint8_t ep0_buf_out[USB_EP0SIZE];
  43:usb/usb.h     **** extern USB_EP_pair_t endpoints[USB_MAXEP+1];
  44:usb/usb.h     **** 
  45:usb/usb.h     **** /** String descriptor index for the device's unique serial number string descriptor within the devi
  46:usb/usb.h     ****  *  This unique serial number is used by the host to associate resources to the device (such as dri
  47:usb/usb.h     ****  *  number allocations) to a device regardless of the port it is plugged in to on the host. Some mi
  48:usb/usb.h     ****  *  a unique serial number internally, and setting the device descriptors serial number string inde
  49:usb/usb.h     ****  *  will cause it to use the internal serial number.
  50:usb/usb.h     ****  *
  51:usb/usb.h     ****  *  On unsupported devices, this will evaluate to \ref NO_DESCRIPTOR and so will force the host to 
  52:usb/usb.h     ****  *  number for the device.
  53:usb/usb.h     ****  */
  54:usb/usb.h     **** #define USE_INTERNAL_SERIAL            0xDC
  55:usb/usb.h     **** 
  56:usb/usb.h     **** /** Length of the device's unique internal serial number, in bits, if present on the selected micro
  57:usb/usb.h     ****  *  model.
  58:usb/usb.h     ****  */
  59:usb/usb.h     **** #define INTERNAL_SERIAL_LENGTH_BITS    (8 * (1 + (offsetof(NVM_PROD_SIGNATURES_t, COORDY1) - offset
  60:usb/usb.h     **** 
  61:usb/usb.h     **** /** Start address of the internal serial number, in the appropriate address space, if present on th
  62:usb/usb.h     ****  *  model.
  63:usb/usb.h     ****  */
  64:usb/usb.h     **** #define INTERNAL_SERIAL_START_ADDRESS  offsetof(NVM_PROD_SIGNATURES_t, LOTNUM0)
  65:usb/usb.h     **** 
  66:usb/usb.h     **** /* Enums: */
  67:usb/usb.h     **** 	/** Enum for the various states of the USB Device state machine. Only some states are
  68:usb/usb.h     **** 	 *  implemented in the LUFA library - other states are left to the user to implement.
  69:usb/usb.h     **** 	 *
  70:usb/usb.h     **** 	 *  For information on each possible USB device state, refer to the USB 2.0 specification.
  71:usb/usb.h     **** 	 *
  72:usb/usb.h     **** 	 *  \see \ref USB_DeviceState, which stores the current device state machine state.
  73:usb/usb.h     **** 	 */
  74:usb/usb.h     **** 	enum USB_Device_States_t
  75:usb/usb.h     **** 	{
  76:usb/usb.h     **** 		DEVICE_STATE_Unattached                   = 0, /**< Internally implemented by the library. This s
  77:usb/usb.h     **** 		                                                *   that the device is not currently connected to
  78:usb/usb.h     **** 		                                                */
  79:usb/usb.h     **** 		DEVICE_STATE_Powered                      = 1, /**< Internally implemented by the library. This s
  80:usb/usb.h     **** 		                                                *   that the device is connected to a host, but e
  81:usb/usb.h     **** 		                                                *   yet begun.
  82:usb/usb.h     **** 		                                                */
  83:usb/usb.h     **** 		DEVICE_STATE_Default                      = 2, /**< Internally implemented by the library. This s
  84:usb/usb.h     **** 		                                                *   that the device's USB bus has been reset by t
  85:usb/usb.h     **** 		                                                *   now waiting for the host to begin the enumera
  86:usb/usb.h     **** 		                                                */
  87:usb/usb.h     **** 		DEVICE_STATE_Addressed                    = 3, /**< Internally implemented by the library. This s
  88:usb/usb.h     **** 		                                                *   that the device has been addressed by the USB
  89:usb/usb.h     **** 		                                                *   yet configured.
  90:usb/usb.h     **** 		                                                */
  91:usb/usb.h     **** 		DEVICE_STATE_Configured                   = 4, /**< May be implemented by the user project. This 
  92:usb/usb.h     **** 		                                                *   that the device has been enumerated by the ho
  93:usb/usb.h     **** 		                                                *   for USB communications to begin.
  94:usb/usb.h     **** 		                                                */
  95:usb/usb.h     **** 		DEVICE_STATE_Suspended                    = 5, /**< May be implemented by the user project. This 
  96:usb/usb.h     **** 		                                                *   that the USB bus has been suspended by the ho
  97:usb/usb.h     **** 		                                                *   should power down to a minimal power level un
  98:usb/usb.h     **** 		                                                *   resumed.
  99:usb/usb.h     **** 		                                                */
 100:usb/usb.h     **** 	};
 101:usb/usb.h     **** 
 102:usb/usb.h     **** #define USB_EP_size_to_gc(x)  ((x <= 8   )?USB_EP_BUFSIZE_8_gc:\
 103:usb/usb.h     ****                                (x <= 16  )?USB_EP_BUFSIZE_16_gc:\
 104:usb/usb.h     ****                                (x <= 32  )?USB_EP_BUFSIZE_32_gc:\
 105:usb/usb.h     ****                                (x <= 64  )?USB_EP_BUFSIZE_64_gc:\
 106:usb/usb.h     ****                                (x <= 128 )?USB_EP_BUFSIZE_128_gc:\
 107:usb/usb.h     ****                                (x <= 256 )?USB_EP_BUFSIZE_256_gc:\
 108:usb/usb.h     ****                                (x <= 512 )?USB_EP_BUFSIZE_512_gc:\
 109:usb/usb.h     ****                                            USB_EP_BUFSIZE_1023_gc)
 110:usb/usb.h     **** 
 111:usb/usb.h     **** #define USB_EP_IN 0x80
 112:usb/usb.h     **** 
 113:usb/usb.h     **** // Flag in the endpoint address to indicate that the endpoint should use
 114:usb/usb.h     **** // PingPong (double buffer) mode. This is not actually part of the endpoint
 115:usb/usb.h     **** // address as seen by the host. If PP is enabled, this flag needs to be part
 116:usb/usb.h     **** // of the address passed to all USB_EP_* functions.
 117:usb/usb.h     **** #define USB_EP_PP 0x40
 118:usb/usb.h     **** 	
 119:usb/usb.h     **** extern volatile uint8_t USB_DeviceState;
 120:usb/usb.h     **** extern volatile uint8_t USB_Device_ConfigurationNumber;
 121:usb/usb.h     **** 
 122:usb/usb.h     **** /** Configure the XMEGA's clock for use with USB.  */
 123:usb/usb.h     **** void USB_ConfigureClock(void);
 124:usb/usb.h     **** 
 125:usb/usb.h     **** /** Initialize USB functionality */
 126:usb/usb.h     **** void USB_Init(void);
 127:usb/usb.h     **** void USB_ResetInterface(void);
 128:usb/usb.h     **** 
 129:usb/usb.h     **** #define _USB_EP(epaddr) \
 130:usb/usb.h     **** 	USB_EP_pair_t* pair = &endpoints[(epaddr & 0x3F)]; \
 131:usb/usb.h     **** 	USB_EP_t* e __attribute__ ((unused)) = &pair->ep[!!(epaddr&0x80)]; \
 132:usb/usb.h     **** 	
 133:usb/usb.h     **** #define _USB_EP_OTHER(epaddr) \
 134:usb/usb.h     **** 	USB_EP_t* other = &pair->ep[!(epaddr&0x80)]
 135:usb/usb.h     **** 	
 136:usb/usb.h     **** #define _USB_EP_BANK(epaddr, bank) \
 137:usb/usb.h     **** 	USB_EP_t* b = &pair->ep[!!(epaddr&0x80) != bank]
 138:usb/usb.h     **** 
 139:usb/usb.h     **** inline void USB_ep_init(uint8_t ep, uint8_t type, uint16_t bufsize) ATTR_ALWAYS_INLINE;
 140:usb/usb.h     **** inline void USB_ep_init(uint8_t ep, uint8_t type, uint16_t bufsize){
 141:usb/usb.h     **** 	_USB_EP(ep);
 142:usb/usb.h     **** 	if (ep & USB_EP_PP){
 143:usb/usb.h     **** 		_USB_EP_OTHER(ep);
 144:usb/usb.h     **** 		e->STATUS = USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm;
 145:usb/usb.h     **** 		e->CTRL = type | USB_EP_size_to_gc(bufsize) | USB_EP_PINGPONG_bm;
 146:usb/usb.h     **** 		other->CTRL = 0;
 147:usb/usb.h     **** 		other->STATUS = USB_EP_BUSNACK0_bm;
 148:usb/usb.h     **** 	}else{
 149:usb/usb.h     **** 		e->STATUS = USB_EP_BUSNACK0_bm;
 150:usb/usb.h     **** 		e->CTRL = type | USB_EP_size_to_gc(bufsize);
 151:usb/usb.h     **** 	}
 152:usb/usb.h     **** }
 153:usb/usb.h     **** 
 154:usb/usb.h     **** inline void USB_ep_cancel(uint8_t ep) ATTR_ALWAYS_INLINE;
 155:usb/usb.h     **** inline void USB_ep_cancel(uint8_t ep){
 156:usb/usb.h     **** 	_USB_EP(ep);
 157:usb/usb.h     **** 	if (ep & USB_EP_PP){
 158:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 159:usb/usb.h     **** 		LACR16(&e->STATUS, USB_EP_BANK_bm);
 160:usb/usb.h     **** 	}else{
 161:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm);
 162:usb/usb.h     **** 	}
 163:usb/usb.h     **** }
 164:usb/usb.h     **** 
 165:usb/usb.h     **** inline void USB_ep_start_bank(uint8_t ep, uint8_t bank, uint8_t* addr, uint16_t size){
 166:usb/usb.h     **** 	_USB_EP(ep);
 167:usb/usb.h     **** 	_USB_EP_BANK(ep, bank);
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 170:usb/usb.h     **** 	
 171:usb/usb.h     **** 	//TODO: the OVF, STALL, and TRNCOMPL flags are in b->STATUS. Clear them if anyone cares.
 172:usb/usb.h     **** 
 173:usb/usb.h     **** 	if (bank==0){
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 175:usb/usb.h     **** 	}else{
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 177:usb/usb.h     **** 	}
 178:usb/usb.h     **** }
 179:usb/usb.h     **** 
 180:usb/usb.h     **** inline void USB_ep_out_start(uint8_t ep, uint8_t* addr) ATTR_ALWAYS_INLINE;
 181:usb/usb.h     **** inline void USB_ep_out_start(uint8_t ep, uint8_t* addr){
 182:usb/usb.h     **** 	USB_ep_start_bank(ep, 0, addr, 0);
 183:usb/usb.h     **** }
 184:usb/usb.h     **** 
 185:usb/usb.h     **** inline void USB_ep_in_start(uint8_t ep, uint8_t* addr, uint16_t size) ATTR_ALWAYS_INLINE;
 186:usb/usb.h     **** inline void USB_ep_in_start(uint8_t ep, uint8_t* addr, uint16_t size){
 187:usb/usb.h     **** 	USB_ep_start_bank(ep, 0, addr, size);
 188:usb/usb.h     **** }
 189:usb/usb.h     **** 
 190:usb/usb.h     **** inline bool USB_ep_done_bank(uint8_t ep, uint8_t bank){
 191:usb/usb.h     **** 	_USB_EP(ep);
 192:usb/usb.h     **** 	return e->STATUS & (bank?USB_EP_TRNCOMPL1_bm:USB_EP_TRNCOMPL0_bm);
 193:usb/usb.h     **** }
 194:usb/usb.h     **** 
 195:usb/usb.h     **** inline bool USB_ep_done(uint8_t ep) ATTR_ALWAYS_INLINE;
 196:usb/usb.h     **** inline bool USB_ep_done(uint8_t ep){
 197:usb/usb.h     **** 	_USB_EP(ep);
 198:usb/usb.h     **** 	if (ep & USB_EP_PP){
 199:usb/usb.h     **** 		return e->STATUS & (USB_EP_TRNCOMPL0_bm|USB_EP_TRNCOMPL1_bm);
 200:usb/usb.h     **** 	}else{
 201:usb/usb.h     **** 		// Because for ep0, TRNCOMPL1 is SETUP
 202:usb/usb.h     **** 		return e->STATUS & USB_EP_TRNCOMPL0_bm;
 203:usb/usb.h     **** 	}
 204:usb/usb.h     **** }
 205:usb/usb.h     **** 
 206:usb/usb.h     **** inline void USB_ep_clear_done(uint8_t ep) ATTR_ALWAYS_INLINE;
 207:usb/usb.h     **** inline void USB_ep_clear_done(uint8_t ep){
 208:usb/usb.h     **** 	_USB_EP(ep);
 209:usb/usb.h     **** 	if (ep & USB_EP_PP){
 210:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_TRNCOMPL0_bm|USB_EP_TRNCOMPL1_bm);
 211:usb/usb.h     **** 	}else{
 212:usb/usb.h     **** 		// Because for ep0, TRNCOMPL1 is SETUP
 213:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_TRNCOMPL0_bm);
 214:usb/usb.h     **** 	}
 215:usb/usb.h     **** }
 216:usb/usb.h     **** 
 217:usb/usb.h     **** inline bool USB_ep_ready(uint8_t ep) ATTR_ALWAYS_INLINE;
 218:usb/usb.h     **** inline bool USB_ep_ready(uint8_t ep){
 219:usb/usb.h     **** 	_USB_EP(ep);
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
  56               		.loc 4 220 0
  57 000c 8091 0000 		lds r24,endpoints+24
  58 0010 8670      		andi r24,lo8(6)
  59               	.LBE438:
  60               	.LBE437:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
  61               		.loc 2 82 0
  62 0012 01F0      		breq .+2
  63 0014 00C0      		rjmp .L19
  64               	.LVL4:
  65               	.L2:
  66               	.LBB439:
  67               	.LBB440:
  51:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     return 1;
  52:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** }
  53:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  54:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
  55:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  56:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     sei();
  57:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  58:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     (void)__s;
  59:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** }
  60:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  61:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ void __iCliParam(const uint8_t *__s)
  62:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  63:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
  64:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  65:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     (void)__s;
  66:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** }
  67:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  68:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ void __iRestore(const  uint8_t *__s)
  69:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
  68               		.loc 3 70 0
  69 0016 2FBF      		out __SREG__,r18
  71:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  70               		.loc 3 71 0
  71               	.LBE440:
  72               	.LBE439:
  73               	.LBE434:
  74               	.LBE433:
  75               	.LBE432:
  76               	.LBE431:
  77               	.LBE430:
  26:Framework.h   ****     usb_pipe_flush(&ep_in);
  27:Framework.h   ****     USB.INTFLAGSBSET = USB_TRNIF_bm;
  78               		.loc 1 27 0
  79 0018 82E0      		ldi r24,lo8(2)
  80 001a E0EC      		ldi r30,lo8(1216)
  81 001c F4E0      		ldi r31,hi8(1216)
  82 001e 8587      		std Z+13,r24
  83               	.LBB472:
  84               	.LBB473:
  85               	.LBB474:
  86               	.LBB475:
  87               	.LBB476:
  88               		.file 5 "usb/pipe.h"
   1:usb/pipe.h    **** // Ring buffer that takes heavy advantage of constant folding
   2:usb/pipe.h    **** #pragma once
   3:usb/pipe.h    **** 
   4:usb/pipe.h    **** #include "Common.h"
   5:usb/pipe.h    **** 
   6:usb/pipe.h    **** // Mutable part, becomes an actual struct
   7:usb/pipe.h    **** typedef struct Pipe_data{
   8:usb/pipe.h    **** 	uint8_t* read_ptr;
   9:usb/pipe.h    **** 	uint8_t* write_ptr;
  10:usb/pipe.h    **** 	int8_t count; // available slots
  11:usb/pipe.h    **** } Pipe_data;
  12:usb/pipe.h    **** 
  13:usb/pipe.h    **** // Immutable part, constant-folded at compile time
  14:usb/pipe.h    **** typedef struct Pipe{
  15:usb/pipe.h    **** 	Pipe_data* data;
  16:usb/pipe.h    **** 	uint8_t* buffer;
  17:usb/pipe.h    **** 	uint8_t  slots;         // Number of slots in the buffer
  18:usb/pipe.h    **** 	uint8_t reserve_read;  // Slots to prevent reading so they are available to writer
  19:usb/pipe.h    **** 	uint8_t reserve_write; // Slots to prevent writing so they are available to reader
  20:usb/pipe.h    **** 	uint16_t size;          // Size of a buffer slot in bytes
  21:usb/pipe.h    **** } Pipe;
  22:usb/pipe.h    **** 
  23:usb/pipe.h    **** #define PIPE_H(NAME, SLOTS, SIZE, RESERVE_READ, RESERVE_WRITE)       \
  24:usb/pipe.h    **** 	extern Pipe_data NAME##_data;         \
  25:usb/pipe.h    **** 	extern uint8_t NAME##_buffer[(SLOTS)*(SIZE)]; \
  26:usb/pipe.h    **** 	const static Pipe NAME = {            \
  27:usb/pipe.h    **** 		.data = &(NAME##_data),           \
  28:usb/pipe.h    **** 		.buffer = &((NAME##_buffer)[0]),  \
  29:usb/pipe.h    **** 		.slots = (SLOTS),                 \
  30:usb/pipe.h    **** 		.size = (SIZE),                   \
  31:usb/pipe.h    **** 		.reserve_read = (RESERVE_READ),   \
  32:usb/pipe.h    **** 		.reserve_write = (RESERVE_WRITE), \
  33:usb/pipe.h    **** 	};
  34:usb/pipe.h    **** 
  35:usb/pipe.h    **** 
  36:usb/pipe.h    **** #define PIPE_C(NAME, SLOTS, SIZE)                   \
  37:usb/pipe.h    **** 	uint8_t NAME##_buffer[(SLOTS)*(SIZE)];           \
  38:usb/pipe.h    **** 	Pipe_data NAME##_data = {                \
  39:usb/pipe.h    **** 		.count = 0,                          \
  40:usb/pipe.h    **** 		.read_ptr = &((NAME##_buffer)[0]),                       \
  41:usb/pipe.h    **** 		.write_ptr = &((NAME##_buffer)[0]),                      \
  42:usb/pipe.h    **** 	};
  43:usb/pipe.h    **** 
  44:usb/pipe.h    **** #define PIPE(NAME, SLOTS, SIZE, RESERVE_READ, RESERVE_WRITE) \
  45:usb/pipe.h    **** 	PIPE_H(NAME, SLOTS, SIZE, RESERVE_READ, RESERVE_WRITE)   \
  46:usb/pipe.h    **** 	PIPE_C(NAME, SLOTS, SIZE)
  47:usb/pipe.h    **** 
  48:usb/pipe.h    **** // Number of slots available to read
  49:usb/pipe.h    **** static inline int8_t pipe_can_read(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  50:usb/pipe.h    **** static inline int8_t pipe_can_read(const Pipe* pipe){
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
  52:usb/pipe.h    **** }
  53:usb/pipe.h    **** 
  54:usb/pipe.h    **** // Number of slots available to write
  55:usb/pipe.h    **** static inline int8_t pipe_can_write(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  56:usb/pipe.h    **** static inline int8_t pipe_can_write(const Pipe* pipe){
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
  89               		.loc 5 57 0
  90 0020 36E0      		ldi r19,lo8(6)
  91               	.LVL5:
  92               	.L11:
  93               	.LBE476:
  94               	.LBE475:
 111:usb/usb_pipe.h **** 	usb_pipe_handle(p);
 112:usb/usb_pipe.h **** }
 113:usb/usb_pipe.h **** 
 114:usb/usb_pipe.h **** static inline bool usb_pipe_flush_done(const USB_Pipe* p) ATTR_ALWAYS_INLINE;
 115:usb/usb_pipe.h **** static inline bool usb_pipe_flush_done(const USB_Pipe* p){
 116:usb/usb_pipe.h **** 	GCC_ASSERT(p->features&PIPE_ENABLE_FLUSH);
 117:usb/usb_pipe.h **** 	return p->data->flush;
 118:usb/usb_pipe.h **** }
 119:usb/usb_pipe.h **** 
 120:usb/usb_pipe.h **** static inline bool usb_pipe_can_write(const USB_Pipe* p) ATTR_ALWAYS_INLINE;
 121:usb/usb_pipe.h **** static inline bool usb_pipe_can_write(const USB_Pipe* p){
 122:usb/usb_pipe.h **** 	bool r;
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
  95               		.loc 2 123 0 discriminator 1
  96 0022 9FB7      		in r25,__SREG__
  97               	.LVL6:
  98               	.LBB478:
  99               	.LBB479:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 100               		.loc 3 50 0 discriminator 1
 101               	/* #APP */
 102               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 103 0024 F894      		cli
 104               	 ;  0 "" 2
 105               	.LVL7:
 106               	/* #NOAPP */
 107               	.LBE479:
 108               	.LBE478:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 109               		.loc 2 124 0 discriminator 1
 110 0026 8091 0000 		lds r24,ep_in_data+1
 111 002a 8823      		tst r24
 112 002c 01F0      		breq .L20
 113               	.L16:
 125:usb/usb_pipe.h **** 			r = false;
 114               		.loc 2 125 0
 115 002e 80E0      		ldi r24,lo8(0)
 116               	.L13:
 117               	.LBB480:
 118               	.LBB481:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 119               		.loc 3 70 0
 120 0030 9FBF      		out __SREG__,r25
 121               		.loc 3 71 0
 122               	.LBE481:
 123               	.LBE480:
 124               	.LBE474:
 125               	.LBE473:
 126               	.LBE472:
  28:Framework.h   ****     while (!usb_pipe_can_write(&ep_in)){
 127               		.loc 1 28 0
 128 0032 8823      		tst r24
 129 0034 01F4      		brne .L1
  29:Framework.h   ****         if (timeout_or_sampling_no_longer_enabled){
 130               		.loc 1 29 0
 131 0036 8091 0000 		lds r24,timeout_or_sampling_no_longer_enabled
 132 003a 8823      		tst r24
 133 003c 01F0      		breq .L11
 134               	.LVL8:
 135               	.LBB485:
 136               	.LBB486:
 137               	.LBB487:
  54:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 138               		.loc 2 54 0
 139 003e 2FB7      		in r18,__SREG__
 140               	.LVL9:
 141               	.LBB488:
 142               	.LBB489:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 143               		.loc 3 50 0
 144               	/* #APP */
 145               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 146 0040 F894      		cli
 147               	 ;  0 "" 2
 148               	.LVL10:
 149               	/* #NOAPP */
 150               	.LBE489:
 151               	.LBE488:
 152               	.LBB490:
 153               	.LBB491:
  58:usb/pipe.h    **** }
  59:usb/pipe.h    **** 
  60:usb/pipe.h    **** static inline uint8_t* pipe_read_ptr(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  61:usb/pipe.h    **** static inline uint8_t* pipe_read_ptr(const Pipe* pipe){
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
  63:usb/pipe.h    **** }
  64:usb/pipe.h    **** 
  65:usb/pipe.h    **** static inline uint8_t* pipe_write_ptr(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  66:usb/pipe.h    **** static inline uint8_t* pipe_write_ptr(const Pipe* pipe){
  67:usb/pipe.h    **** 	return pipe->data->write_ptr;
  68:usb/pipe.h    **** }
  69:usb/pipe.h    **** 
  70:usb/pipe.h    **** static inline void pipe_done_read(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  71:usb/pipe.h    **** static inline void pipe_done_read(const Pipe* pipe){
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
  74:usb/pipe.h    **** 	// Assumes buffer_size % slot_size == 0 and all accesses aligned
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
  77:usb/pipe.h    **** }
  78:usb/pipe.h    **** 
  79:usb/pipe.h    **** static inline void pipe_done_write(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  80:usb/pipe.h    **** static inline void pipe_done_write(const Pipe* pipe){
  81:usb/pipe.h    **** 	pipe->data->count += 1;
  82:usb/pipe.h    **** 	pipe->data->write_ptr += pipe->size;
  83:usb/pipe.h    **** 	// Assumes buffer_size % slot_size == 0 and all accesses aligned
  84:usb/pipe.h    **** 	if (pipe->data->write_ptr == &pipe->buffer[pipe->slots*pipe->size])
  85:usb/pipe.h    **** 		pipe->data->write_ptr = &pipe->buffer[0];
  86:usb/pipe.h    **** }
  87:usb/pipe.h    **** 
  88:usb/pipe.h    **** static inline void pipe_reset(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  89:usb/pipe.h    **** static inline void pipe_reset(const Pipe* pipe){
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 154               		.loc 5 90 0
 155 0042 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
  91:usb/pipe.h    **** 	pipe->data->read_ptr = pipe->data->write_ptr = pipe->buffer;
 156               		.loc 5 91 0
 157 0046 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 158 0048 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 159 004a 8093 0000 		sts ep_in_pipe_data+2,r24
 160 004e 9093 0000 		sts ep_in_pipe_data+2+1,r25
 161 0052 8093 0000 		sts ep_in_pipe_data,r24
 162 0056 9093 0000 		sts ep_in_pipe_data+1,r25
 163               	.LVL11:
 164               	.LBE491:
 165               	.LBE490:
 166               	.LBB492:
 167               	.LBB493:
 158:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 168               		.loc 4 158 0
 169 005a E0E0      		ldi r30,lo8(endpoints+24)
 170 005c F0E0      		ldi r31,hi8(endpoints+24)
 171               	/* #APP */
 172               	 ;  158 "usb/usb.h" 1
 173 005e 06E0      		ldi r16, 6
 174 0060 0593      		.dc.w 0x9305
 175               		
 176               	 ;  0 "" 2
 159:usb/usb.h     **** 		LACR16(&e->STATUS, USB_EP_BANK_bm);
 177               		.loc 4 159 0
 178               	 ;  159 "usb/usb.h" 1
 179 0062 08E0      		ldi r16, 8
 180 0064 0693      		.dc.w 0x9306
 181               		
 182               	 ;  0 "" 2
 183               	/* #NOAPP */
 184               	.LBE493:
 185               	.LBE492:
  57:usb/usb_pipe.h **** 		p->data->flush = 0;
 186               		.loc 2 57 0
 187 0066 1092 0000 		sts ep_in_data+1,__zero_reg__
  58:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
 188               		.loc 2 58 0
 189 006a 1092 0000 		sts ep_in_data+2,__zero_reg__
 190 006e 1092 0000 		sts ep_in_data+2+1,__zero_reg__
  59:usb/usb_pipe.h **** 		p->data->bank = 0;
 191               		.loc 2 59 0
 192 0072 1092 0000 		sts ep_in_data,__zero_reg__
 193               	.LVL12:
 194               	.LBB494:
 195               	.LBB495:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 196               		.loc 3 70 0
 197 0076 2FBF      		out __SREG__,r18
 198               		.loc 3 71 0
 199               	.LVL13:
 200               	.L1:
 201               	/* epilogue start */
 202               	.LBE495:
 203               	.LBE494:
 204               	.LBE487:
 205               	.LBE486:
 206               	.LBE485:
  30:Framework.h   ****             usb_pipe_reset(&ep_in);
  31:Framework.h   ****             return;
  32:Framework.h   ****         }
  33:Framework.h   ****     }
  34:Framework.h   **** } 
 207               		.loc 1 34 0
 208 0078 0F91      		pop r16
 209 007a 0895      		ret
 210               	.L20:
 211               	.LBB496:
 212               	.LBB484:
 213               	.LBB483:
 214               	.LBB482:
 215               	.LBB477:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 216               		.loc 5 57 0
 217 007c 8091 0000 		lds r24,ep_in_pipe_data+4
 218 0080 232F      		mov r18,r19
 219 0082 281B      		sub r18,r24
 220               	.LBE477:
 221               	.LBE482:
 126:usb/usb_pipe.h **** 		}else{
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 222               		.loc 2 127 0
 223 0084 81E0      		ldi r24,lo8(1)
 224 0086 1216      		cp __zero_reg__,r18
 225 0088 04F0      		brlt .L13
 226 008a 00C0      		rjmp .L16
 227               	.LVL14:
 228               	.L19:
 229               	.LBE483:
 230               	.LBE484:
 231               	.LBE496:
 232               	.LBB497:
 233               	.LBB471:
 234               	.LBB470:
 235               	.LBB469:
 236               	.LBB468:
 237               	.LBB441:
 238               	.LBB442:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 239               		.loc 5 51 0
 240 008c 3091 0000 		lds r19,ep_in_pipe_data+4
 241               	.LBE442:
 242               	.LBE441:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 243               		.loc 2 83 0
 244 0090 1316      		cp __zero_reg__,r19
 245 0092 04F0      		brlt .+2
 246 0094 00C0      		rjmp .L3
 247               	.LBB443:
 248               	.LBB444:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 249               		.loc 5 62 0
 250 0096 8091 0000 		lds r24,ep_in_pipe_data
 251 009a 9091 0000 		lds r25,ep_in_pipe_data+1
 252               	.LVL15:
 253               	.LBE444:
 254               	.LBE443:
 255               	.LBB445:
 256               	.LBB446:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 257               		.loc 2 68 0
 258 009e 4091 0000 		lds r20,ep_in_data
 259               	.LVL16:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 260               		.loc 2 69 0
 261 00a2 51E0      		ldi r21,lo8(1)
 262 00a4 4130      		cpi r20,lo8(1)
 263 00a6 01F4      		brne .L4
 264 00a8 50E0      		ldi r21,lo8(0)
 265               	.L4:
 266 00aa 5093 0000 		sts ep_in_data,r21
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 267               		.loc 2 72 0
 268 00ae 4423      		tst r20
 269 00b0 01F4      		brne .L5
 270               	.LVL17:
 271               	.LBB447:
 272               	.LBB448:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 273               		.loc 4 168 0
 274 00b2 8093 0000 		sts endpoints+28,r24
 275 00b6 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 276               		.loc 4 169 0
 277 00ba 40E4      		ldi r20,lo8(64)
 278 00bc 50E0      		ldi r21,hi8(64)
 279 00be 4093 0000 		sts endpoints+26,r20
 280 00c2 5093 0000 		sts endpoints+26+1,r21
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 281               		.loc 4 174 0
 282 00c6 E0E0      		ldi r30,lo8(endpoints+24)
 283 00c8 F0E0      		ldi r31,hi8(endpoints+24)
 284               	.LVL18:
 285               	/* #APP */
 286               	 ;  174 "usb/usb.h" 1
 287 00ca 02E2      		ldi r16, 34
 288 00cc 0693      		.dc.w 0x9306
 289               		
 290               	 ;  0 "" 2
 291               	.LVL19:
 292               	/* #NOAPP */
 293               	.L6:
 294               	.LBE448:
 295               	.LBE447:
 296               	.LBE446:
 297               	.LBE445:
 298               	.LBB452:
 299               	.LBB453:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 300               		.loc 5 72 0
 301 00ce 3150      		subi r19,lo8(-(-1))
 302 00d0 3093 0000 		sts ep_in_pipe_data+4,r19
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 303               		.loc 5 73 0
 304 00d4 805C      		subi r24,lo8(-(64))
 305 00d6 9F4F      		sbci r25,hi8(-(64))
 306 00d8 8093 0000 		sts ep_in_pipe_data,r24
 307 00dc 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 308               		.loc 5 75 0
 309 00e0 30E0      		ldi r19,hi8(ep_in_pipe_buffer+512)
 310 00e2 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 311 00e4 9307      		cpc r25,r19
 312 00e6 01F0      		breq .+2
 313 00e8 00C0      		rjmp .L2
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
 314               		.loc 5 76 0
 315 00ea 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 316 00ec 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 317 00ee 8093 0000 		sts ep_in_pipe_data,r24
 318 00f2 9093 0000 		sts ep_in_pipe_data+1,r25
 319 00f6 00C0      		rjmp .L2
 320               	.LVL20:
 321               	.L5:
 322               	.LBE453:
 323               	.LBE452:
 324               	.LBB454:
 325               	.LBB451:
 326               	.LBB449:
 327               	.LBB450:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 328               		.loc 4 168 0
 329 00f8 8093 0000 		sts endpoints+20,r24
 330 00fc 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 331               		.loc 4 169 0
 332 0100 40E4      		ldi r20,lo8(64)
 333 0102 50E0      		ldi r21,hi8(64)
 334 0104 4093 0000 		sts endpoints+18,r20
 335 0108 5093 0000 		sts endpoints+18+1,r21
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 336               		.loc 4 176 0
 337 010c E0E0      		ldi r30,lo8(endpoints+24)
 338 010e F0E0      		ldi r31,hi8(endpoints+24)
 339               	/* #APP */
 340               	 ;  176 "usb/usb.h" 1
 341 0110 04E1      		ldi r16, 20
 342 0112 0693      		.dc.w 0x9306
 343               		
 344               	 ;  0 "" 2
 345               	/* #NOAPP */
 346 0114 00C0      		rjmp .L6
 347               	.LVL21:
 348               	.L3:
 349               	.LBE450:
 350               	.LBE449:
 351               	.LBE451:
 352               	.LBE454:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 353               		.loc 2 87 0
 354 0116 8091 0000 		lds r24,ep_in_data+1
 355 011a 8130      		cpi r24,lo8(1)
 356 011c 01F0      		breq .L21
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 357               		.loc 2 91 0
 358 011e 8230      		cpi r24,lo8(2)
 359 0120 01F0      		breq .+2
 360 0122 00C0      		rjmp .L2
 361               	.LVL22:
 362               	.LBB455:
 363               	.LBB456:
 364               	.LBB457:
 221:usb/usb.h     **** }
 222:usb/usb.h     **** 
 223:usb/usb.h     **** inline bool USB_ep_empty(uint8_t ep) ATTR_ALWAYS_INLINE;
 224:usb/usb.h     **** inline bool USB_ep_empty(uint8_t ep){
 225:usb/usb.h     **** 	_USB_EP(ep);
 226:usb/usb.h     **** 	if (ep & USB_EP_PP){
 227:usb/usb.h     **** 		const uint8_t mask = (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 365               		.loc 4 228 0
 366 0124 8091 0000 		lds r24,endpoints+24
 367 0128 8670      		andi r24,lo8(6)
 368               	.LBE457:
 369               	.LBE456:
 370               	.LBE455:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 371               		.loc 2 91 0
 372 012a 8630      		cpi r24,lo8(6)
 373 012c 01F0      		breq .+2
 374 012e 00C0      		rjmp .L2
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 375               		.loc 2 92 0
 376 0130 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 377               		.loc 2 93 0
 378 0134 1092 0000 		sts ep_in_data+2,__zero_reg__
 379 0138 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 380               	.LBB458:
 381               	.LBB459:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 382               		.loc 5 90 0
 383 013c 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 384               		.loc 5 91 0
 385 0140 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 386 0142 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 387 0144 8093 0000 		sts ep_in_pipe_data+2,r24
 388 0148 9093 0000 		sts ep_in_pipe_data+2+1,r25
 389 014c 8093 0000 		sts ep_in_pipe_data,r24
 390 0150 9093 0000 		sts ep_in_pipe_data+1,r25
 391               	.LVL23:
 392 0154 00C0      		rjmp .L2
 393               	.LVL24:
 394               	.L21:
 395               	.LBE459:
 396               	.LBE458:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 397               		.loc 2 88 0
 398 0156 82E0      		ldi r24,lo8(2)
 399 0158 8093 0000 		sts ep_in_data+1,r24
 400               	.LBB460:
 401               	.LBB461:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 402               		.loc 5 62 0
 403 015c 6091 0000 		lds r22,ep_in_pipe_data
 404 0160 3091 0000 		lds r19,ep_in_pipe_data+1
 405               	.LBE461:
 406               	.LBE460:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 407               		.loc 2 90 0
 408 0164 4091 0000 		lds r20,ep_in_data+2
 409 0168 5091 0000 		lds r21,ep_in_data+2+1
 410               	.LVL25:
 411               	.LBB462:
 412               	.LBB463:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 413               		.loc 2 68 0
 414 016c 8091 0000 		lds r24,ep_in_data
 415               	.LVL26:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 416               		.loc 2 69 0
 417 0170 91E0      		ldi r25,lo8(1)
 418 0172 8130      		cpi r24,lo8(1)
 419 0174 01F0      		breq .L22
 420               	.L9:
 421 0176 9093 0000 		sts ep_in_data,r25
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 422               		.loc 2 72 0
 423 017a 8823      		tst r24
 424 017c 01F4      		brne .L10
 425               	.LVL27:
 426               	.LBB464:
 427               	.LBB465:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 428               		.loc 4 168 0
 429 017e 862F      		mov r24,r22
 430 0180 932F      		mov r25,r19
 431 0182 8093 0000 		sts endpoints+28,r24
 432 0186 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 433               		.loc 4 169 0
 434 018a 4093 0000 		sts endpoints+26,r20
 435 018e 5093 0000 		sts endpoints+26+1,r21
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 436               		.loc 4 174 0
 437 0192 E0E0      		ldi r30,lo8(endpoints+24)
 438 0194 F0E0      		ldi r31,hi8(endpoints+24)
 439               	.LVL28:
 440               	/* #APP */
 441               	 ;  174 "usb/usb.h" 1
 442 0196 02E2      		ldi r16, 34
 443 0198 0693      		.dc.w 0x9306
 444               		
 445               	 ;  0 "" 2
 446               	/* #NOAPP */
 447 019a 00C0      		rjmp .L2
 448               	.LVL29:
 449               	.L10:
 450               	.LBE465:
 451               	.LBE464:
 452               	.LBB466:
 453               	.LBB467:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 454               		.loc 4 168 0
 455 019c 862F      		mov r24,r22
 456 019e 932F      		mov r25,r19
 457 01a0 8093 0000 		sts endpoints+20,r24
 458 01a4 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 459               		.loc 4 169 0
 460 01a8 4093 0000 		sts endpoints+18,r20
 461 01ac 5093 0000 		sts endpoints+18+1,r21
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 462               		.loc 4 176 0
 463 01b0 E0E0      		ldi r30,lo8(endpoints+24)
 464 01b2 F0E0      		ldi r31,hi8(endpoints+24)
 465               	/* #APP */
 466               	 ;  176 "usb/usb.h" 1
 467 01b4 04E1      		ldi r16, 20
 468 01b6 0693      		.dc.w 0x9306
 469               		
 470               	 ;  0 "" 2
 471               	/* #NOAPP */
 472 01b8 00C0      		rjmp .L2
 473               	.LVL30:
 474               	.L22:
 475               	.LBE467:
 476               	.LBE466:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 477               		.loc 2 69 0
 478 01ba 90E0      		ldi r25,lo8(0)
 479 01bc 00C0      		rjmp .L9
 480               	.LBE463:
 481               	.LBE462:
 482               	.LBE468:
 483               	.LBE469:
 484               	.LBE470:
 485               	.LBE471:
 486               	.LBE497:
 487               		.cfi_endproc
 488               	.LFE56:
 490               	.global	EVENT_USB_Device_ConfigurationChanged
 492               	EVENT_USB_Device_ConfigurationChanged:
 493               	.LFB57:
  35:Framework.h   **** 
  36:Framework.h   **** void EVENT_USB_Device_ConfigurationChanged(uint8_t config){
 494               		.loc 1 36 0
 495               		.cfi_startproc
 496               	.LVL31:
 497               	/* prologue: function */
 498               	/* frame size = 0 */
 499               	/* stack size = 0 */
 500               	.L__stack_usage = 0
 501               	.LBB498:
 502               	.LBB499:
  44:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 503               		.loc 2 44 0
 504 01be 2FB7      		in r18,__SREG__
 505               	.LVL32:
 506               	.LBB500:
 507               	.LBB501:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 508               		.loc 3 50 0
 509               	/* #APP */
 510               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 511 01c0 F894      		cli
 512               	 ;  0 "" 2
 513               	.LVL33:
 514               	/* #NOAPP */
 515               	.LBE501:
 516               	.LBE500:
 517               	.LBB502:
 518               	.LBB503:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 519               		.loc 5 90 0
 520 01c2 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 521               		.loc 5 91 0
 522 01c6 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 523 01c8 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 524               	.LVL34:
 525 01ca 8093 0000 		sts ep_in_pipe_data+2,r24
 526 01ce 9093 0000 		sts ep_in_pipe_data+2+1,r25
 527 01d2 8093 0000 		sts ep_in_pipe_data,r24
 528 01d6 9093 0000 		sts ep_in_pipe_data+1,r25
 529               	.LVL35:
 530               	.LBE503:
 531               	.LBE502:
 532               	.LBB504:
 533               	.LBB505:
 534               	.LBB506:
 144:usb/usb.h     **** 		e->STATUS = USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm;
 535               		.loc 4 144 0
 536 01da 80E0      		ldi r24,lo8(endpoints+24)
 537 01dc 90E0      		ldi r25,hi8(endpoints+24)
 538 01de 36E0      		ldi r19,lo8(6)
 539 01e0 3093 0000 		sts endpoints+24,r19
 145:usb/usb.h     **** 		e->CTRL = type | USB_EP_size_to_gc(bufsize) | USB_EP_PINGPONG_bm;
 540               		.loc 4 145 0
 541 01e4 33E9      		ldi r19,lo8(-109)
 542 01e6 3093 0000 		sts endpoints+25,r19
 146:usb/usb.h     **** 		other->CTRL = 0;
 543               		.loc 4 146 0
 544 01ea FC01      		movw r30,r24
 545 01ec 3797      		sbiw r30,7
 546 01ee 1082      		st Z,__zero_reg__
 147:usb/usb.h     **** 		other->STATUS = USB_EP_BUSNACK0_bm;
 547               		.loc 4 147 0
 548 01f0 0897      		sbiw r24,8
 549 01f2 32E0      		ldi r19,lo8(2)
 550 01f4 FC01      		movw r30,r24
 551 01f6 3083      		st Z,r19
 552               	.LBE506:
 553               	.LBE505:
 554               	.LBE504:
  47:usb/usb_pipe.h **** 		p->data->bank = 0;
 555               		.loc 2 47 0
 556 01f8 1092 0000 		sts ep_in_data,__zero_reg__
  48:usb/usb_pipe.h **** 		p->data->flush = 0;
 557               		.loc 2 48 0
 558 01fc 1092 0000 		sts ep_in_data+1,__zero_reg__
  49:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
 559               		.loc 2 49 0
 560 0200 1092 0000 		sts ep_in_data+2,__zero_reg__
 561 0204 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 562               	.LVL36:
 563               	.LBB507:
 564               	.LBB508:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 565               		.loc 3 70 0
 566 0208 2FBF      		out __SREG__,r18
 567               		.loc 3 71 0
 568               	/* epilogue start */
 569               	.LBE508:
 570               	.LBE507:
 571               	.LBE499:
 572               	.LBE498:
  37:Framework.h   **** 	usb_pipe_init(&ep_in);
  38:Framework.h   **** }
 573               		.loc 1 38 0
 574 020a 0895      		ret
 575               		.cfi_endproc
 576               	.LFE57:
 578               	.global	__vector_125
 580               	__vector_125:
 581               	.LFB58:
  39:Framework.h   **** 
  40:Framework.h   **** ISR(USB_BUSEVENT_vect){
 582               		.loc 1 40 0
 583               		.cfi_startproc
 584 020c 1F92      		push r1
 585               	.LCFI1:
 586               		.cfi_def_cfa_offset 3
 587               		.cfi_offset 1, -2
 588 020e 0F92      		push r0
 589               	.LCFI2:
 590               		.cfi_def_cfa_offset 4
 591               		.cfi_offset 0, -3
 592 0210 0FB6      		in r0,__SREG__
 593 0212 0F92      		push r0
 594 0214 1124      		clr __zero_reg__
 595 0216 2F93      		push r18
 596               	.LCFI3:
 597               		.cfi_def_cfa_offset 5
 598               		.cfi_offset 18, -4
 599 0218 3F93      		push r19
 600               	.LCFI4:
 601               		.cfi_def_cfa_offset 6
 602               		.cfi_offset 19, -5
 603 021a 4F93      		push r20
 604               	.LCFI5:
 605               		.cfi_def_cfa_offset 7
 606               		.cfi_offset 20, -6
 607 021c 5F93      		push r21
 608               	.LCFI6:
 609               		.cfi_def_cfa_offset 8
 610               		.cfi_offset 21, -7
 611 021e 6F93      		push r22
 612               	.LCFI7:
 613               		.cfi_def_cfa_offset 9
 614               		.cfi_offset 22, -8
 615 0220 7F93      		push r23
 616               	.LCFI8:
 617               		.cfi_def_cfa_offset 10
 618               		.cfi_offset 23, -9
 619 0222 8F93      		push r24
 620               	.LCFI9:
 621               		.cfi_def_cfa_offset 11
 622               		.cfi_offset 24, -10
 623 0224 9F93      		push r25
 624               	.LCFI10:
 625               		.cfi_def_cfa_offset 12
 626               		.cfi_offset 25, -11
 627 0226 AF93      		push r26
 628               	.LCFI11:
 629               		.cfi_def_cfa_offset 13
 630               		.cfi_offset 26, -12
 631 0228 BF93      		push r27
 632               	.LCFI12:
 633               		.cfi_def_cfa_offset 14
 634               		.cfi_offset 27, -13
 635 022a EF93      		push r30
 636               	.LCFI13:
 637               		.cfi_def_cfa_offset 15
 638               		.cfi_offset 30, -14
 639 022c FF93      		push r31
 640               	.LCFI14:
 641               		.cfi_def_cfa_offset 16
 642               		.cfi_offset 31, -15
 643               	/* prologue: Signal */
 644               	/* frame size = 0 */
 645               	/* stack size = 15 */
 646               	.L__stack_usage = 15
  41:Framework.h   **** 	if (USB.INTFLAGSACLR & USB_SOFIF_bm){
 647               		.loc 1 41 0
 648 022e E0EC      		ldi r30,lo8(1216)
 649 0230 F4E0      		ldi r31,hi8(1216)
 650 0232 8091 CA04 		lds r24,1226
 651 0236 87FD      		sbrc r24,7
 652 0238 00C0      		rjmp .L29
  42:Framework.h   **** 		USB.INTFLAGSACLR = USB_SOFIF_bm;
  43:Framework.h   **** 	}else if (USB.INTFLAGSACLR & (USB_CRCIF_bm | USB_UNFIF_bm | USB_OVFIF_bm)){
 653               		.loc 1 43 0
 654 023a 8091 CA04 		lds r24,1226
 655 023e 8E70      		andi r24,lo8(14)
 656 0240 01F4      		brne .L30
  44:Framework.h   **** 		USB.INTFLAGSACLR = (USB_CRCIF_bm | USB_UNFIF_bm | USB_OVFIF_bm);
  45:Framework.h   **** 	}else if (USB.INTFLAGSACLR & USB_STALLIF_bm){
 657               		.loc 1 45 0
 658 0242 8091 CA04 		lds r24,1226
 659 0246 80FD      		sbrc r24,0
 660 0248 00C0      		rjmp .L31
  46:Framework.h   **** 		USB.INTFLAGSACLR = USB_STALLIF_bm;
  47:Framework.h   **** 	}else{
  48:Framework.h   **** 		USB.INTFLAGSACLR = USB_SUSPENDIF_bm | USB_RESUMEIF_bm | USB_RSTIF_bm;
 661               		.loc 1 48 0
 662 024a 80E7      		ldi r24,lo8(112)
 663 024c 8287      		std Z+10,r24
 664               	.LBB509:
 665               	.LBB510:
 229:usb/usb.h     **** 	}else{
 230:usb/usb.h     **** 		return e->STATUS & USB_EP_BUSNACK0_bm;
 231:usb/usb.h     **** 	}
 232:usb/usb.h     **** }
 233:usb/usb.h     **** 
 234:usb/usb.h     **** inline uint16_t USB_ep_count_bank(uint8_t ep, uint8_t bank) ATTR_ALWAYS_INLINE;
 235:usb/usb.h     **** inline uint16_t USB_ep_count_bank(uint8_t ep, uint8_t bank){
 236:usb/usb.h     **** 	_USB_EP(ep);
 237:usb/usb.h     **** 	_USB_EP_BANK(ep, bank);
 238:usb/usb.h     **** 	return b->CNT;
 239:usb/usb.h     **** }
 240:usb/usb.h     **** 
 241:usb/usb.h     **** inline uint16_t USB_ep_count(uint8_t ep) ATTR_ALWAYS_INLINE;
 242:usb/usb.h     **** inline uint16_t USB_ep_count(uint8_t ep){
 243:usb/usb.h     **** 	return USB_ep_count_bank(ep, 0);
 244:usb/usb.h     **** }
 245:usb/usb.h     **** 
 246:usb/usb.h     **** inline void USB_ep0_send(uint8_t size){
 247:usb/usb.h     **** 	USB_ep_in_start(0x80, ep0_buf_in, size);
 248:usb/usb.h     **** }
 249:usb/usb.h     **** void USB_ep0_send_progmem(const uint8_t* addr, uint16_t size);
 250:usb/usb.h     **** 
 251:usb/usb.h     **** inline void USB_ep_wait(uint8_t ep) ATTR_ALWAYS_INLINE;
 252:usb/usb.h     **** inline void USB_ep_wait(uint8_t ep){
 253:usb/usb.h     **** 	while (!USB_ep_done(ep)){};
 254:usb/usb.h     **** }
 255:usb/usb.h     **** 
 256:usb/usb.h     **** /// Select a certain bank of an endpoint for the next transfer
 257:usb/usb.h     **** inline void USB_ep_set_bank(uint8_t ep, uint8_t bank) ATTR_ALWAYS_INLINE;
 258:usb/usb.h     **** inline void USB_ep_set_bank(uint8_t ep, uint8_t bank){
 259:usb/usb.h     **** 	_USB_EP(ep);
 260:usb/usb.h     **** 	if (bank){
 261:usb/usb.h     **** 		LASR16(&(e->STATUS), USB_EP_BANK_bm);
 262:usb/usb.h     **** 	}else{
 263:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BANK_bm);
 264:usb/usb.h     **** 	}
 265:usb/usb.h     **** }
 266:usb/usb.h     **** 
 267:usb/usb.h     **** /// Get the bank 0/1 which will handle the next request on this endpoint
 268:usb/usb.h     **** inline uint8_t USB_ep_get_bank(uint8_t ep) ATTR_ALWAYS_INLINE;
 269:usb/usb.h     **** inline uint8_t USB_ep_get_bank(uint8_t ep){
 270:usb/usb.h     **** 	_USB_EP(ep);
 271:usb/usb.h     **** 	return !!(e->STATUS & USB_EP_BANK_bm);
 272:usb/usb.h     **** }
 273:usb/usb.h     **** 
 274:usb/usb.h     **** 
 275:usb/usb.h     **** // Enable the OUT stage on the default control pipe. This happens automatically
 276:usb/usb.h     **** // upon the return of HandleSetup, but use this function if it needs to happen
 277:usb/usb.h     **** // before returning (e.g. with USB_ep_wait()).
 278:usb/usb.h     **** inline void USB_ep0_enableOut(void) ATTR_ALWAYS_INLINE;
 279:usb/usb.h     **** inline void USB_ep0_enableOut(void){
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 281:usb/usb.h     **** }
 282:usb/usb.h     **** 
 283:usb/usb.h     **** bool USB_HandleSetup(void);
 284:usb/usb.h     **** 
 285:usb/usb.h     **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 286:usb/usb.h     ****                                     const uint8_t wIndex,
 287:usb/usb.h     ****                                     const void** const DescriptorAddress);
 288:usb/usb.h     **** 
 289:usb/usb.h     **** /** Detaches the device from the USB bus. This has the effect of removing the device from any
 290:usb/usb.h     ****  *  attached host, ceasing USB communications. If no host is present, this prevents any host from
 291:usb/usb.h     ****  *  enumerating the device once attached until \ref USB_Attach() is called.
 292:usb/usb.h     ****  */
 293:usb/usb.h     **** static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
 294:usb/usb.h     **** static inline void USB_Detach(void)
 295:usb/usb.h     **** {
 296:usb/usb.h     **** 	USB.CTRLB &= ~USB_ATTACH_bm;
 297:usb/usb.h     **** }
 298:usb/usb.h     **** 
 299:usb/usb.h     **** /** Attaches the device to the USB bus. This announces the device's presence to any attached
 300:usb/usb.h     ****  *  USB host, starting the enumeration process. If no host is present, attaching the device
 301:usb/usb.h     ****  *  will allow for enumeration once a host is connected to the device.
 302:usb/usb.h     ****  */
 303:usb/usb.h     **** static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
 304:usb/usb.h     **** static inline void USB_Attach(void)
 305:usb/usb.h     **** {
 306:usb/usb.h     **** 	USB.CTRLB |= USB_ATTACH_bm;
 307:usb/usb.h     **** }
 308:usb/usb.h     **** 
 309:usb/usb.h     **** inline void USB_Evt_Task(void) ATTR_ALWAYS_INLINE;
 310:usb/usb.h     **** inline void USB_Evt_Task(void){
 311:usb/usb.h     **** 	if (USB.STATUS & USB_BUSRST_bm){
 666               		.loc 4 311 0
 667 024e 8091 C204 		lds r24,1218
 668 0252 80FF      		sbrs r24,0
 669 0254 00C0      		rjmp .L24
 312:usb/usb.h     **** 		USB.STATUS &= ~USB_BUSRST_bm;
 670               		.loc 4 312 0
 671 0256 8091 C204 		lds r24,1218
 672 025a 8E7F      		andi r24,lo8(-2)
 673 025c 8283      		std Z+2,r24
 313:usb/usb.h     **** 		USB_Init();
 674               		.loc 4 313 0
 675 025e 0E94 0000 		call USB_Init
 676 0262 00C0      		rjmp .L24
 677               	.L30:
 678               	.LBE510:
 679               	.LBE509:
  44:Framework.h   **** 		USB.INTFLAGSACLR = (USB_CRCIF_bm | USB_UNFIF_bm | USB_OVFIF_bm);
 680               		.loc 1 44 0
 681 0264 8EE0      		ldi r24,lo8(14)
 682 0266 8287      		std Z+10,r24
 683               	.L24:
 684               	/* epilogue start */
  49:Framework.h   **** 		USB_Evt_Task();
  50:Framework.h   **** 	}
  51:Framework.h   **** }
 685               		.loc 1 51 0
 686 0268 FF91      		pop r31
 687 026a EF91      		pop r30
 688 026c BF91      		pop r27
 689 026e AF91      		pop r26
 690 0270 9F91      		pop r25
 691 0272 8F91      		pop r24
 692 0274 7F91      		pop r23
 693 0276 6F91      		pop r22
 694 0278 5F91      		pop r21
 695 027a 4F91      		pop r20
 696 027c 3F91      		pop r19
 697 027e 2F91      		pop r18
 698 0280 0F90      		pop r0
 699 0282 0FBE      		out __SREG__,r0
 700 0284 0F90      		pop r0
 701 0286 1F90      		pop r1
 702 0288 1895      		reti
 703               	.L31:
  46:Framework.h   **** 		USB.INTFLAGSACLR = USB_STALLIF_bm;
 704               		.loc 1 46 0
 705 028a 81E0      		ldi r24,lo8(1)
 706 028c 8287      		std Z+10,r24
 707 028e 00C0      		rjmp .L24
 708               	.L29:
  42:Framework.h   **** 		USB.INTFLAGSACLR = USB_SOFIF_bm;
 709               		.loc 1 42 0
 710 0290 80E8      		ldi r24,lo8(-128)
 711 0292 8287      		std Z+10,r24
 712 0294 00C0      		rjmp .L24
 713               		.cfi_endproc
 714               	.LFE58:
 716               	.global	__vector_126
 718               	__vector_126:
 719               	.LFB59:
  52:Framework.h   **** 
  53:Framework.h   **** ISR(USB_TRNCOMPL_vect){
 720               		.loc 1 53 0
 721               		.cfi_startproc
 722 0296 1F92      		push r1
 723               	.LCFI15:
 724               		.cfi_def_cfa_offset 3
 725               		.cfi_offset 1, -2
 726 0298 0F92      		push r0
 727               	.LCFI16:
 728               		.cfi_def_cfa_offset 4
 729               		.cfi_offset 0, -3
 730 029a 0FB6      		in r0,__SREG__
 731 029c 0F92      		push r0
 732 029e 1124      		clr __zero_reg__
 733 02a0 0F93      		push r16
 734               	.LCFI17:
 735               		.cfi_def_cfa_offset 5
 736               		.cfi_offset 16, -4
 737 02a2 2F93      		push r18
 738               	.LCFI18:
 739               		.cfi_def_cfa_offset 6
 740               		.cfi_offset 18, -5
 741 02a4 3F93      		push r19
 742               	.LCFI19:
 743               		.cfi_def_cfa_offset 7
 744               		.cfi_offset 19, -6
 745 02a6 4F93      		push r20
 746               	.LCFI20:
 747               		.cfi_def_cfa_offset 8
 748               		.cfi_offset 20, -7
 749 02a8 5F93      		push r21
 750               	.LCFI21:
 751               		.cfi_def_cfa_offset 9
 752               		.cfi_offset 21, -8
 753 02aa 6F93      		push r22
 754               	.LCFI22:
 755               		.cfi_def_cfa_offset 10
 756               		.cfi_offset 22, -9
 757 02ac 7F93      		push r23
 758               	.LCFI23:
 759               		.cfi_def_cfa_offset 11
 760               		.cfi_offset 23, -10
 761 02ae 8F93      		push r24
 762               	.LCFI24:
 763               		.cfi_def_cfa_offset 12
 764               		.cfi_offset 24, -11
 765 02b0 9F93      		push r25
 766               	.LCFI25:
 767               		.cfi_def_cfa_offset 13
 768               		.cfi_offset 25, -12
 769 02b2 AF93      		push r26
 770               	.LCFI26:
 771               		.cfi_def_cfa_offset 14
 772               		.cfi_offset 26, -13
 773 02b4 BF93      		push r27
 774               	.LCFI27:
 775               		.cfi_def_cfa_offset 15
 776               		.cfi_offset 27, -14
 777 02b6 EF93      		push r30
 778               	.LCFI28:
 779               		.cfi_def_cfa_offset 16
 780               		.cfi_offset 30, -15
 781 02b8 FF93      		push r31
 782               	.LCFI29:
 783               		.cfi_def_cfa_offset 17
 784               		.cfi_offset 31, -16
 785               	/* prologue: Signal */
 786               	/* frame size = 0 */
 787               	/* stack size = 16 */
 788               	.L__stack_usage = 16
  54:Framework.h   **** 	USB.FIFOWP = 0;
 789               		.loc 1 54 0
 790 02ba E0EC      		ldi r30,lo8(1216)
 791 02bc F4E0      		ldi r31,hi8(1216)
 792 02be 1482      		std Z+4,__zero_reg__
  55:Framework.h   **** 	USB.INTFLAGSBCLR = USB_SETUPIF_bm | USB_TRNIF_bm;
 793               		.loc 1 55 0
 794 02c0 83E0      		ldi r24,lo8(3)
 795 02c2 8487      		std Z+12,r24
 796               	.LVL37:
 797               	.LBB567:
 798               	.LBB568:
 799               	.LBB569:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 800               		.loc 2 80 0
 801 02c4 2FB7      		in r18,__SREG__
 802               	.LVL38:
 803               	.LBB570:
 804               	.LBB571:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 805               		.loc 3 50 0
 806               	/* #APP */
 807               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 808 02c6 F894      		cli
 809               	 ;  0 "" 2
 810               	.LVL39:
 811               	/* #NOAPP */
 812               	.LBE571:
 813               	.LBE570:
 814               	.LBB572:
 815               	.LBB573:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 816               		.loc 4 220 0
 817 02c8 8091 0000 		lds r24,endpoints+24
 818 02cc 8670      		andi r24,lo8(6)
 819               	.LBE573:
 820               	.LBE572:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 821               		.loc 2 82 0
 822 02ce 01F4      		brne .L47
 823               	.LVL40:
 824               	.L33:
 825               	.LBB574:
 826               	.LBB575:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 827               		.loc 3 70 0
 828 02d0 2FBF      		out __SREG__,r18
 829               		.loc 3 71 0
 830               	.LBE575:
 831               	.LBE574:
 832               	.LBE569:
 833               	.LBE568:
 834               	.LBE567:
 835               	.LBB613:
 836               	.LBB614:
 314:usb/usb.h     **** 	}
 315:usb/usb.h     **** }
 316:usb/usb.h     **** 
 317:usb/usb.h     **** inline void USB_Task(void) ATTR_ALWAYS_INLINE;
 318:usb/usb.h     **** inline void USB_Task(void){
 319:usb/usb.h     **** 	// Read once to prevent race condition where SETUP packet is interpreted as OUT
 320:usb/usb.h     **** 	uint8_t status = endpoints[0].out.STATUS;
 837               		.loc 4 320 0
 838 02d2 8091 0000 		lds r24,endpoints
 839               	.LVL41:
 321:usb/usb.h     **** 
 322:usb/usb.h     **** 	if (status & USB_EP_SETUP_bm){
 840               		.loc 4 322 0
 841 02d6 84FD      		sbrc r24,4
 842 02d8 00C0      		rjmp .L48
 843               	.L42:
 323:usb/usb.h     **** 		if (!USB_HandleSetup()){
 324:usb/usb.h     **** 			endpoints[0].out.CTRL |= USB_EP_STALL_bm;
 325:usb/usb.h     **** 			endpoints[0].in.CTRL |= USB_EP_STALL_bm; 
 326:usb/usb.h     **** 		}
 327:usb/usb.h     **** 		USB_ep0_enableOut();
 328:usb/usb.h     **** 	}else if(status & USB_EP_TRNCOMPL0_bm){
 844               		.loc 4 328 0
 845 02da 85FD      		sbrc r24,5
 846 02dc 00C0      		rjmp .L49
 847               	.LVL42:
 848               	.L32:
 849               	/* epilogue start */
 850               	.LBE614:
 851               	.LBE613:
  56:Framework.h   **** 	usb_pipe_handle(&ep_in);
  57:Framework.h   **** 	USB_Task();
  58:Framework.h   **** }
 852               		.loc 1 58 0
 853 02de FF91      		pop r31
 854 02e0 EF91      		pop r30
 855 02e2 BF91      		pop r27
 856 02e4 AF91      		pop r26
 857 02e6 9F91      		pop r25
 858 02e8 8F91      		pop r24
 859 02ea 7F91      		pop r23
 860 02ec 6F91      		pop r22
 861 02ee 5F91      		pop r21
 862 02f0 4F91      		pop r20
 863 02f2 3F91      		pop r19
 864 02f4 2F91      		pop r18
 865 02f6 0F91      		pop r16
 866 02f8 0F90      		pop r0
 867 02fa 0FBE      		out __SREG__,r0
 868 02fc 0F90      		pop r0
 869 02fe 1F90      		pop r1
 870 0300 1895      		reti
 871               	.LVL43:
 872               	.L47:
 873               	.LBB623:
 874               	.LBB610:
 875               	.LBB607:
 876               	.LBB577:
 877               	.LBB578:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 878               		.loc 5 51 0
 879 0302 3091 0000 		lds r19,ep_in_pipe_data+4
 880               	.LBE578:
 881               	.LBE577:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 882               		.loc 2 83 0
 883 0306 1316      		cp __zero_reg__,r19
 884 0308 04F0      		brlt .+2
 885 030a 00C0      		rjmp .L34
 886               	.LBB579:
 887               	.LBB580:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 888               		.loc 5 62 0
 889 030c 8091 0000 		lds r24,ep_in_pipe_data
 890 0310 9091 0000 		lds r25,ep_in_pipe_data+1
 891               	.LVL44:
 892               	.LBE580:
 893               	.LBE579:
 894               	.LBB581:
 895               	.LBB582:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 896               		.loc 2 68 0
 897 0314 4091 0000 		lds r20,ep_in_data
 898               	.LVL45:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 899               		.loc 2 69 0
 900 0318 51E0      		ldi r21,lo8(1)
 901 031a 4130      		cpi r20,lo8(1)
 902 031c 01F4      		brne .+2
 903 031e 00C0      		rjmp .L50
 904 0320 5093 0000 		sts ep_in_data,r21
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 905               		.loc 2 72 0
 906 0324 4423      		tst r20
 907 0326 01F4      		brne .+2
 908 0328 00C0      		rjmp .L51
 909               	.L36:
 910               	.LVL46:
 911               	.LBB583:
 912               	.LBB584:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 913               		.loc 4 168 0
 914 032a 8093 0000 		sts endpoints+20,r24
 915 032e 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 916               		.loc 4 169 0
 917 0332 40E4      		ldi r20,lo8(64)
 918 0334 50E0      		ldi r21,hi8(64)
 919 0336 4093 0000 		sts endpoints+18,r20
 920 033a 5093 0000 		sts endpoints+18+1,r21
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 921               		.loc 4 176 0
 922 033e E0E0      		ldi r30,lo8(endpoints+24)
 923 0340 F0E0      		ldi r31,hi8(endpoints+24)
 924               	/* #APP */
 925               	 ;  176 "usb/usb.h" 1
 926 0342 04E1      		ldi r16, 20
 927 0344 0693      		.dc.w 0x9306
 928               		
 929               	 ;  0 "" 2
 930               	.LVL47:
 931               	/* #NOAPP */
 932               	.L37:
 933               	.LBE584:
 934               	.LBE583:
 935               	.LBE582:
 936               	.LBE581:
 937               	.LBB588:
 938               	.LBB589:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 939               		.loc 5 72 0
 940 0346 3150      		subi r19,lo8(-(-1))
 941 0348 3093 0000 		sts ep_in_pipe_data+4,r19
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 942               		.loc 5 73 0
 943 034c 805C      		subi r24,lo8(-(64))
 944 034e 9F4F      		sbci r25,hi8(-(64))
 945 0350 8093 0000 		sts ep_in_pipe_data,r24
 946 0354 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 947               		.loc 5 75 0
 948 0358 30E0      		ldi r19,hi8(ep_in_pipe_buffer+512)
 949 035a 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 950 035c 9307      		cpc r25,r19
 951 035e 01F0      		breq .+2
 952 0360 00C0      		rjmp .L33
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
 953               		.loc 5 76 0
 954 0362 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 955 0364 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 956 0366 8093 0000 		sts ep_in_pipe_data,r24
 957 036a 9093 0000 		sts ep_in_pipe_data+1,r25
 958               	.LBE589:
 959               	.LBE588:
 960               	.LBB590:
 961               	.LBB576:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 962               		.loc 3 70 0
 963 036e 2FBF      		out __SREG__,r18
 964               		.loc 3 71 0
 965               	.LBE576:
 966               	.LBE590:
 967               	.LBE607:
 968               	.LBE610:
 969               	.LBE623:
 970               	.LBB624:
 971               	.LBB621:
 320:usb/usb.h     **** 	uint8_t status = endpoints[0].out.STATUS;
 972               		.loc 4 320 0
 973 0370 8091 0000 		lds r24,endpoints
 974               	.LVL48:
 322:usb/usb.h     **** 	if (status & USB_EP_SETUP_bm){
 975               		.loc 4 322 0
 976 0374 84FF      		sbrs r24,4
 977 0376 00C0      		rjmp .L42
 978               	.LVL49:
 979               	.L48:
 323:usb/usb.h     **** 		if (!USB_HandleSetup()){
 980               		.loc 4 323 0
 981 0378 0E94 0000 		call USB_HandleSetup
 982               	.LVL50:
 983 037c 8823      		tst r24
 984 037e 01F4      		brne .L45
 324:usb/usb.h     **** 			endpoints[0].out.CTRL |= USB_EP_STALL_bm;
 985               		.loc 4 324 0
 986 0380 8091 0000 		lds r24,endpoints+1
 987 0384 8460      		ori r24,lo8(4)
 988 0386 8093 0000 		sts endpoints+1,r24
 325:usb/usb.h     **** 			endpoints[0].in.CTRL |= USB_EP_STALL_bm; 
 989               		.loc 4 325 0
 990 038a 8091 0000 		lds r24,endpoints+9
 991 038e 8460      		ori r24,lo8(4)
 992 0390 8093 0000 		sts endpoints+9,r24
 993               	.L45:
 994               	.LBB615:
 995               	.LBB616:
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 996               		.loc 4 280 0
 997 0394 E0E0      		ldi r30,lo8(endpoints)
 998 0396 F0E0      		ldi r31,hi8(endpoints)
 999               	/* #APP */
 1000               	 ;  280 "usb/usb.h" 1
 1001 0398 02E7      		ldi r16, 114
 1002 039a 0693      		.dc.w 0x9306
 1003               		
 1004               	 ;  0 "" 2
 1005               	/* #NOAPP */
 1006 039c 00C0      		rjmp .L32
 1007               	.LVL51:
 1008               	.L50:
 1009               	.LBE616:
 1010               	.LBE615:
 1011               	.LBE621:
 1012               	.LBE624:
 1013               	.LBB625:
 1014               	.LBB611:
 1015               	.LBB608:
 1016               	.LBB591:
 1017               	.LBB587:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 1018               		.loc 2 69 0
 1019 039e 50E0      		ldi r21,lo8(0)
 1020 03a0 5093 0000 		sts ep_in_data,r21
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 1021               		.loc 2 72 0
 1022 03a4 4423      		tst r20
 1023 03a6 01F0      		breq .+2
 1024 03a8 00C0      		rjmp .L36
 1025               	.L51:
 1026               	.LVL52:
 1027               	.LBB585:
 1028               	.LBB586:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1029               		.loc 4 168 0
 1030 03aa 8093 0000 		sts endpoints+28,r24
 1031 03ae 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1032               		.loc 4 169 0
 1033 03b2 40E4      		ldi r20,lo8(64)
 1034 03b4 50E0      		ldi r21,hi8(64)
 1035               	.LVL53:
 1036 03b6 4093 0000 		sts endpoints+26,r20
 1037 03ba 5093 0000 		sts endpoints+26+1,r21
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1038               		.loc 4 174 0
 1039 03be E0E0      		ldi r30,lo8(endpoints+24)
 1040 03c0 F0E0      		ldi r31,hi8(endpoints+24)
 1041               	.LVL54:
 1042               	/* #APP */
 1043               	 ;  174 "usb/usb.h" 1
 1044 03c2 02E2      		ldi r16, 34
 1045 03c4 0693      		.dc.w 0x9306
 1046               		
 1047               	 ;  0 "" 2
 1048               	/* #NOAPP */
 1049 03c6 00C0      		rjmp .L37
 1050               	.LVL55:
 1051               	.L49:
 1052               	.LBE586:
 1053               	.LBE585:
 1054               	.LBE587:
 1055               	.LBE591:
 1056               	.LBE608:
 1057               	.LBE611:
 1058               	.LBE625:
 1059               	.LBB626:
 1060               	.LBB622:
 329:usb/usb.h     **** 		EVENT_USB_Device_ControlOUT((uint8_t *) ep0_buf_out, endpoints[0].out.CNT);
 1061               		.loc 4 329 0
 1062 03c8 4091 0000 		lds r20,endpoints+2
 1063 03cc 5091 0000 		lds r21,endpoints+2+1
 1064               	.LVL56:
 1065               	.LBB618:
 1066               	.LBB619:
 1067               		.file 6 "main.c"
   1:main.c        **** #include "Framework.h"
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <inttypes.h>
   4:main.c        **** #include <stdio.h> 
   5:main.c        **** #include <stdlib.h>
   6:main.c        **** #include <util/delay.h>
   7:main.c        **** #include <string.h> 
   8:main.c        **** #include "nmea/nmea.h"
   9:main.c        **** #define USART_BAUD 4800L
  10:main.c        **** 
  11:main.c        **** typedef struct _latlng {
  12:main.c        ****   char *lat;
  13:main.c        ****   char *lng;
  14:main.c        **** } latlng;
  15:main.c        **** 
  16:main.c        **** // static int uart_putchar(char c); 
  17:main.c        **** static void uart_init (void); 
  18:main.c        **** void send_usb_data(char *s);
  19:main.c        **** bool updating = false;
  20:main.c        **** static void parse_nmea(void);
  21:main.c        **** extern void parse_nmea_string(char *s, latlng *gps);
  22:main.c        **** 
  23:main.c        **** char *message;
  24:main.c        **** static void uart_init(void) {
  25:main.c        **** 
  26:main.c        **** 	// Set the TxD pin high - set PORTC DIR register bit 3 to 1 
  27:main.c        ****   PORTD.OUTSET = PIN3_bm; 
  28:main.c        **** 
  29:main.c        ****   // Set the TxD pin as an output - set PORTC OUT register bit 3 to 1 
  30:main.c        ****   PORTD.DIRSET = PIN3_bm; 
  31:main.c        **** 
  32:main.c        **** 	//Baud rate of 4800
  33:main.c        **** 	uint16_t BSEL = 12;
  34:main.c        **** 	uint8_t BSCALE = 1;
  35:main.c        **** 	USARTD0_BAUDCTRLA = BSEL & 0XFF;
  36:main.c        **** 	USARTD0_BAUDCTRLB = (BSCALE << 4) | (BSEL & 0xF000) >> 8;
  37:main.c        **** 
  38:main.c        **** 	// no interrupts
  39:main.c        **** 	// can't overwrite bits 7:6
  40:main.c        **** 	USARTD0.CTRLA = 0x00;
  41:main.c        **** 
  42:main.c        ****   // Enable transmitter and receiver
  43:main.c        ****   USARTD0.CTRLB = USART_TXEN_bm | USART_RXEN_bm;  
  44:main.c        **** 
  45:main.c        **** 	// async, no parity, 1 stop bit, 8 bit data,
  46:main.c        **** 	// 00     00         00          11    
  47:main.c        ****   USARTD0.CTRLC = 0x03;  
  48:main.c        **** }
  49:main.c        **** 
  50:main.c        **** char* concat(char *s1, char *s2)
  51:main.c        **** {
  52:main.c        ****     char *result = malloc(strlen(s1)+strlen(s2)+1);//+1 for the zero-terminator
  53:main.c        ****     //in real code you would check for errors in malloc here
  54:main.c        ****     strcpy(result, s1);
  55:main.c        ****     strcat(result, s2);
  56:main.c        ****     return result;
  57:main.c        **** }
  58:main.c        **** 
  59:main.c        **** void parse_nmea_string(char *s, latlng *gps)
  60:main.c        **** {
  61:main.c        ****   int i=0; // used to iterate through array
  62:main.c        ****   // int j;
  63:main.c        **** 
  64:main.c        ****   char *token[80]; //user input and array to hold max possible tokens, aka 80.
  65:main.c        **** 
  66:main.c        ****   token[0] = strtok(s, ","); //get pointer to first token found and store in 0
  67:main.c        ****                                      //place in array
  68:main.c        ****   while(token[i]!= NULL) {   //ensure a pointer was found
  69:main.c        ****       i++;
  70:main.c        ****       token[i] = strtok(NULL, ","); //continue to tokenize the string
  71:main.c        ****   }
  72:main.c        **** 
  73:main.c        ****   gps->lat = token[3];
  74:main.c        ****   gps->lng = token[5];
  75:main.c        ****   
  76:main.c        ****   // for(j = 0; j <= i-1; j++) {
  77:main.c        ****   //   int l = strlen(token[j]);
  78:main.c        ****   //   for (int k=0; k<l; k++) {
  79:main.c        ****   //     send_byte(token[j][k]);
  80:main.c        ****   //   }
  81:main.c        ****   //   send_byte('\n');
  82:main.c        ****   // }
  83:main.c        **** }
  84:main.c        **** 
  85:main.c        **** static void parse_nmea(void) {
  86:main.c        **** 
  87:main.c        ****     char *buff[] = {
  88:main.c        ****         // "$GPGGA,111609.14,5001.27,N,3613.06,E,3,08,0.0,10.2,M,0.0,M,0.0,0000*70\r\n",
  89:main.c        ****         "$GPRMC,173843,A,3349.896,N,11808.521,W,000.0,360.0,230108,013.4,E*69\r\n",
  90:main.c        ****         // "$GPGSV,2,1,08,01,05,005,80,02,05,050,80,03,05,095,80,04,05,140,80*7f\r\n",
  91:main.c        ****         // "$GPGSA,A,3,01,02,03,04,05,06,07,08,00,00,00,00,0.0,0.0,0.0*3a\r\n",
  92:main.c        ****         // "$GPGSV,2,2,08,05,05,185,80,06,05,230,80,07,05,275,80,08,05,320,80*71\r\n",
  93:main.c        ****         "$GPRMC,111609.14,A,5001.27,N,3613.06,E,11.2,0.0,261206,0.0,E*50\r\n",
  94:main.c        ****         // "$GPVTG,217.5,T,208.8,M,000.00,N,000.01,K*4C\r\n"
  95:main.c        ****     };
  96:main.c        **** 
  97:main.c        ****     int it = 0;
  98:main.c        ****     // nmea_gprmc_t data;
  99:main.c        ****     latlng gps;
 100:main.c        **** 
 101:main.c        ****     // char lat[50]; 
 102:main.c        ****     // char lng[50];
 103:main.c        **** 
 104:main.c        ****     // double latitude = 5.2242515;
 105:main.c        ****     // double longitude = 12.322352;
 106:main.c        ****     for(it = 0; it < 2; ++it){
 107:main.c        **** 
 108:main.c        ****       // int error_code = nmea_parse_gprmc(buff[it], &data);
 109:main.c        ****       // if (error_code) {
 110:main.c        ****       //   send_byte(error_code);
 111:main.c        ****       //   send_byte('\n');
 112:main.c        ****       // }
 113:main.c        ****       parse_nmea_string(buff[it], &gps);
 114:main.c        **** 
 115:main.c        ****       // sprintf(lat, "%lf", gps.lat);
 116:main.c        ****       // sprintf(lng, "%lf", gps.lng);
 117:main.c        ****       int len_lat = strlen(gps.lat);
 118:main.c        ****       int len_lng = strlen(gps.lng);
 119:main.c        **** 
 120:main.c        ****       for (int i=0; i<len_lat; i++) {
 121:main.c        ****         send_byte(gps.lat[i]);  
 122:main.c        ****       }
 123:main.c        ****       send_byte(' ');  
 124:main.c        ****       for (int j=0; j<len_lng; j++) {
 125:main.c        ****         send_byte(gps.lng[j]);  
 126:main.c        ****       }
 127:main.c        ****       send_byte('\n');
 128:main.c        ****     }
 129:main.c        ****     break_and_flush();
 130:main.c        **** }
 131:main.c        **** 
 132:main.c        **** // static int uart_putchar (char c) { 
 133:main.c        **** //     if (c == '\n') 
 134:main.c        **** //         uart_putchar('\r'); 
 135:main.c        **** 
 136:main.c        **** //     // Wait for the transmit buffer to be empty 
 137:main.c        **** //     while ( !( USARTD0.STATUS & USART_DREIF_bm) ); 
 138:main.c        **** 
 139:main.c        **** //     // Put our character into the transmit buffer 
 140:main.c        **** //     USARTD0.DATA = c; 
 141:main.c        **** 
 142:main.c        **** //     return 0; 
 143:main.c        **** // } 
 144:main.c        **** int main(void){
 145:main.c        **** 	USB_ConfigureClock();
 146:main.c        **** 	USB_Init();
 147:main.c        **** 	USB.INTCTRLA = USB_BUSEVIE_bm | USB_INTLVL_MED_gc;
 148:main.c        **** 	USB.INTCTRLB = USB_TRNIE_bm | USB_SETUPIE_bm;
 149:main.c        **** 	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
 150:main.c        **** 	sei();
 151:main.c        **** 	if (false) {
 152:main.c        **** 		uart_init();
 153:main.c        **** 	}
 154:main.c        **** 
 155:main.c        **** 	break_and_flush();
 156:main.c        ****   parse_nmea();
 157:main.c        **** 	for (;;){
 158:main.c        **** 
 159:main.c        **** 		// uart_putchar('a');
 160:main.c        **** 	}
 161:main.c        **** 
 162:main.c        **** }
 163:main.c        **** #define stringify(s) #s
 164:main.c        **** 
 165:main.c        **** const char PROGMEM hwversion[] = stringify(HW_VERSION);
 166:main.c        **** const char PROGMEM fwversion[] = stringify(FW_VERSION);
 167:main.c        **** 
 168:main.c        **** uint8_t usb_cmd = 0;
 169:main.c        **** uint8_t cmd_data = 0;
 170:main.c        **** 
 171:main.c        **** // void send_usb_data(char *message) {
 172:main.c        **** // 	for (uint8_t = 0; i < 64; i++) ep0_buf_in[i] = 0;
 173:main.c        **** // 	int l = strlen(message);
 174:main.c        **** // 	for (int i=0; i<l; i++) {
 175:main.c        **** // 		ep0_buf_in[i] = message[i];
 176:main.c        **** // 	}
 177:main.c        **** // }
 178:main.c        **** 
 179:main.c        **** /** Event handler for the library USB Control Request reception event. */
 180:main.c        **** bool EVENT_USB_Device_ControlRequest(USB_Request_Header_t* req){
 181:main.c        **** 	// zero out ep0_buf_in
 182:main.c        **** 	for (uint8_t i = 0; i < 64; i++) ep0_buf_in[i] = 0;
 183:main.c        **** 	usb_cmd = 0;
 184:main.c        **** 	if ((req->bmRequestType & CONTROL_REQTYPE_TYPE) == REQTYPE_VENDOR){
 185:main.c        **** 		switch(req->bRequest){
 186:main.c        **** 			case 0x00: // Info
 187:main.c        **** 				if (req->wIndex == 0){
 188:main.c        **** 					USB_ep0_send_progmem((uint8_t*)hwversion, sizeof(hwversion));
 189:main.c        **** 				}else if (req->wIndex == 1){
 190:main.c        **** 					USB_ep0_send_progmem((uint8_t*)fwversion, sizeof(fwversion));
 191:main.c        **** 				}
 192:main.c        **** 				return true;
 193:main.c        **** 			case 0x02:
 194:main.c        **** 				{
 195:main.c        **** 					int l = strlen(message);
 196:main.c        **** 					for (uint8_t i=0; i<64; i++) {
 197:main.c        **** 						ep0_buf_in[i] = message[i];
 198:main.c        **** 					}
 199:main.c        **** 					USB_ep0_send(l);
 200:main.c        **** 					return true;
 201:main.c        **** 				}
 202:main.c        **** 			case 0x08:
 203:main.c        **** 				* ((uint8_t *) req->wIndex) = req->wValue;
 204:main.c        **** 				USB_ep0_send(0);
 205:main.c        **** 				return true;
 206:main.c        **** 			case 0x09:
 207:main.c        **** 				ep0_buf_in[0] = * ((uint8_t *) req->wIndex);
 208:main.c        **** 				USB_ep0_send(1);
 209:main.c        **** 				return true;
 210:main.c        **** 			case 0x16:
 211:main.c        **** 				* ((uint16_t *) req->wIndex) = req->wValue;
 212:main.c        **** 				USB_ep0_send(0);
 213:main.c        **** 				return true;
 214:main.c        **** 			case 0x17:{
 215:main.c        **** 				uint16_t *addr;
 216:main.c        **** 				addr = (uint16_t *) req->wIndex;
 217:main.c        **** 				ep0_buf_in[0] = *addr & 0xFF;
 218:main.c        **** 				ep0_buf_in[1] = *addr >> 8;
 219:main.c        **** 				USB_ep0_send(2);}
 220:main.c        **** 				return true;
 221:main.c        **** 			// read EEPROM	
 222:main.c        **** 			case 0xE0: 
 223:main.c        **** 				eeprom_read_block(ep0_buf_in, (void*)(req->wIndex*64), 64);
 224:main.c        **** 				USB_ep0_send(64);
 225:main.c        **** 				return true;
 226:main.c        **** 
 227:main.c        **** 			// write EEPROM	
 228:main.c        **** 			case 0xE1: 
 229:main.c        **** 				usb_cmd = req->bRequest;
 230:main.c        **** 				cmd_data = req->wIndex;
 231:main.c        **** 				USB_ep0_send(0);
 232:main.c        **** 				return true; // Wait for OUT data (expecting an OUT transfer)
 233:main.c        **** 
 234:main.c        **** 			// disconnect from USB, jump to bootloader	
 235:main.c        **** 			case 0xBB: 
 236:main.c        **** 				USB_enter_bootloader();
 237:main.c        **** 				return true;
 238:main.c        **** 		}
 239:main.c        **** 	}
 240:main.c        **** 	return false;
 241:main.c        **** }
 242:main.c        **** 
 243:main.c        **** void EVENT_USB_Device_ControlOUT(uint8_t* buf, uint8_t count){
 244:main.c        **** 	switch (usb_cmd){
 1068               		.loc 6 244 0
 1069 03d0 8091 0000 		lds r24,usb_cmd
 1070               	.LVL57:
 1071 03d4 813E      		cpi r24,lo8(-31)
 1072 03d6 01F4      		brne .L45
 245:main.c        **** 		case 0xE1: // Write EEPROM
 246:main.c        **** 			eeprom_update_block(buf, (void*)(cmd_data*64), count);
 1073               		.loc 6 246 0
 1074 03d8 6091 0000 		lds r22,cmd_data
 1075 03dc 70E0      		ldi r23,lo8(0)
 1076 03de 0024      		clr __tmp_reg__
 1077 03e0 7695      		lsr r23
 1078 03e2 6795      		ror r22
 1079 03e4 0794      		ror __tmp_reg__
 1080 03e6 7695      		lsr r23
 1081 03e8 6795      		ror r22
 1082 03ea 0794      		ror __tmp_reg__
 1083 03ec 762F      		mov r23,r22
 1084 03ee 602D      		mov r22,__tmp_reg__
 1085 03f0 80E0      		ldi r24,lo8(ep0_buf_out)
 1086 03f2 90E0      		ldi r25,hi8(ep0_buf_out)
 1087 03f4 50E0      		ldi r21,lo8(0)
 1088 03f6 0E94 0000 		call __eeupd_block_x32a4u
 1089               	.LVL58:
 1090               	.LBE619:
 1091               	.LBE618:
 1092               	.LBB620:
 1093               	.LBB617:
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 1094               		.loc 4 280 0
 1095 03fa E0E0      		ldi r30,lo8(endpoints)
 1096 03fc F0E0      		ldi r31,hi8(endpoints)
 1097               	/* #APP */
 1098               	 ;  280 "usb/usb.h" 1
 1099 03fe 02E7      		ldi r16, 114
 1100 0400 0693      		.dc.w 0x9306
 1101               		
 1102               	 ;  0 "" 2
 1103               	/* #NOAPP */
 1104 0402 00C0      		rjmp .L32
 1105               	.LVL59:
 1106               	.L34:
 1107               	.LBE617:
 1108               	.LBE620:
 1109               	.LBE622:
 1110               	.LBE626:
 1111               	.LBB627:
 1112               	.LBB612:
 1113               	.LBB609:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 1114               		.loc 2 87 0
 1115 0404 8091 0000 		lds r24,ep_in_data+1
 1116 0408 8130      		cpi r24,lo8(1)
 1117 040a 01F0      		breq .L52
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 1118               		.loc 2 91 0
 1119 040c 8230      		cpi r24,lo8(2)
 1120 040e 01F0      		breq .+2
 1121 0410 00C0      		rjmp .L33
 1122               	.LVL60:
 1123               	.LBB592:
 1124               	.LBB593:
 1125               	.LBB594:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 1126               		.loc 4 228 0
 1127 0412 8091 0000 		lds r24,endpoints+24
 1128 0416 8670      		andi r24,lo8(6)
 1129               	.LBE594:
 1130               	.LBE593:
 1131               	.LBE592:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 1132               		.loc 2 91 0
 1133 0418 8630      		cpi r24,lo8(6)
 1134 041a 01F0      		breq .+2
 1135 041c 00C0      		rjmp .L33
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 1136               		.loc 2 92 0
 1137 041e 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 1138               		.loc 2 93 0
 1139 0422 1092 0000 		sts ep_in_data+2,__zero_reg__
 1140 0426 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 1141               	.LBB595:
 1142               	.LBB596:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 1143               		.loc 5 90 0
 1144 042a 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 1145               		.loc 5 91 0
 1146 042e 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 1147 0430 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 1148 0432 8093 0000 		sts ep_in_pipe_data+2,r24
 1149 0436 9093 0000 		sts ep_in_pipe_data+2+1,r25
 1150 043a 8093 0000 		sts ep_in_pipe_data,r24
 1151 043e 9093 0000 		sts ep_in_pipe_data+1,r25
 1152               	.LVL61:
 1153 0442 00C0      		rjmp .L33
 1154               	.LVL62:
 1155               	.L52:
 1156               	.LBE596:
 1157               	.LBE595:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 1158               		.loc 2 88 0
 1159 0444 82E0      		ldi r24,lo8(2)
 1160 0446 8093 0000 		sts ep_in_data+1,r24
 1161               	.LBB597:
 1162               	.LBB598:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 1163               		.loc 5 62 0
 1164 044a 7091 0000 		lds r23,ep_in_pipe_data
 1165 044e 6091 0000 		lds r22,ep_in_pipe_data+1
 1166               	.LBE598:
 1167               	.LBE597:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 1168               		.loc 2 90 0
 1169 0452 8091 0000 		lds r24,ep_in_data+2
 1170 0456 9091 0000 		lds r25,ep_in_data+2+1
 1171               	.LVL63:
 1172               	.LBB599:
 1173               	.LBB600:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 1174               		.loc 2 68 0
 1175 045a 3091 0000 		lds r19,ep_in_data
 1176               	.LVL64:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 1177               		.loc 2 69 0
 1178 045e 41E0      		ldi r20,lo8(1)
 1179 0460 3130      		cpi r19,lo8(1)
 1180 0462 01F0      		breq .L53
 1181               	.L40:
 1182 0464 4093 0000 		sts ep_in_data,r20
 1183               	.LBB601:
 1184               	.LBB602:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1185               		.loc 4 168 0
 1186 0468 472F      		mov r20,r23
 1187 046a 562F      		mov r21,r22
 1188               	.LBE602:
 1189               	.LBE601:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 1190               		.loc 2 72 0
 1191 046c 3323      		tst r19
 1192 046e 01F4      		brne .L41
 1193               	.LVL65:
 1194               	.LBB604:
 1195               	.LBB603:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1196               		.loc 4 168 0
 1197 0470 4093 0000 		sts endpoints+28,r20
 1198 0474 5093 0000 		sts endpoints+28+1,r21
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1199               		.loc 4 169 0
 1200 0478 8093 0000 		sts endpoints+26,r24
 1201 047c 9093 0000 		sts endpoints+26+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1202               		.loc 4 174 0
 1203 0480 E0E0      		ldi r30,lo8(endpoints+24)
 1204 0482 F0E0      		ldi r31,hi8(endpoints+24)
 1205               	.LVL66:
 1206               	/* #APP */
 1207               	 ;  174 "usb/usb.h" 1
 1208 0484 02E2      		ldi r16, 34
 1209 0486 0693      		.dc.w 0x9306
 1210               		
 1211               	 ;  0 "" 2
 1212               	/* #NOAPP */
 1213 0488 00C0      		rjmp .L33
 1214               	.LVL67:
 1215               	.L41:
 1216               	.LBE603:
 1217               	.LBE604:
 1218               	.LBB605:
 1219               	.LBB606:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1220               		.loc 4 168 0
 1221 048a 4093 0000 		sts endpoints+20,r20
 1222 048e 5093 0000 		sts endpoints+20+1,r21
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1223               		.loc 4 169 0
 1224 0492 8093 0000 		sts endpoints+18,r24
 1225 0496 9093 0000 		sts endpoints+18+1,r25
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 1226               		.loc 4 176 0
 1227 049a E0E0      		ldi r30,lo8(endpoints+24)
 1228 049c F0E0      		ldi r31,hi8(endpoints+24)
 1229               	/* #APP */
 1230               	 ;  176 "usb/usb.h" 1
 1231 049e 04E1      		ldi r16, 20
 1232 04a0 0693      		.dc.w 0x9306
 1233               		
 1234               	 ;  0 "" 2
 1235               	/* #NOAPP */
 1236 04a2 00C0      		rjmp .L33
 1237               	.LVL68:
 1238               	.L53:
 1239               	.LBE606:
 1240               	.LBE605:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 1241               		.loc 2 69 0
 1242 04a4 40E0      		ldi r20,lo8(0)
 1243 04a6 00C0      		rjmp .L40
 1244               	.LBE600:
 1245               	.LBE599:
 1246               	.LBE609:
 1247               	.LBE612:
 1248               	.LBE627:
 1249               		.cfi_endproc
 1250               	.LFE59:
 1252               	.global	concat
 1254               	concat:
 1255               	.LFB62:
  51:main.c        **** {
 1256               		.loc 6 51 0
 1257               		.cfi_startproc
 1258               	.LVL69:
 1259 04a8 EF92      		push r14
 1260               	.LCFI30:
 1261               		.cfi_def_cfa_offset 3
 1262               		.cfi_offset 14, -2
 1263 04aa FF92      		push r15
 1264               	.LCFI31:
 1265               		.cfi_def_cfa_offset 4
 1266               		.cfi_offset 15, -3
 1267 04ac 0F93      		push r16
 1268               	.LCFI32:
 1269               		.cfi_def_cfa_offset 5
 1270               		.cfi_offset 16, -4
 1271 04ae 1F93      		push r17
 1272               	.LCFI33:
 1273               		.cfi_def_cfa_offset 6
 1274               		.cfi_offset 17, -5
 1275 04b0 CF93      		push r28
 1276               	.LCFI34:
 1277               		.cfi_def_cfa_offset 7
 1278               		.cfi_offset 28, -6
 1279 04b2 DF93      		push r29
 1280               	.LCFI35:
 1281               		.cfi_def_cfa_offset 8
 1282               		.cfi_offset 29, -7
 1283               	/* prologue: function */
 1284               	/* frame size = 0 */
 1285               	/* stack size = 6 */
 1286               	.L__stack_usage = 6
 1287 04b4 F82E      		mov r15,r24
 1288 04b6 E92E      		mov r14,r25
 1289 04b8 162F      		mov r17,r22
 1290 04ba 072F      		mov r16,r23
  52:main.c        ****     char *result = malloc(strlen(s1)+strlen(s2)+1);//+1 for the zero-terminator
 1291               		.loc 6 52 0
 1292 04bc A82F      		mov r26,r24
 1293 04be B92F      		mov r27,r25
 1294 04c0 ED01      		movw r28,r26
 1295 04c2 0990      		ld __tmp_reg__,Y+
 1296 04c4 0020      		tst __tmp_reg__
 1297 04c6 01F4      		brne .-6
 1298 04c8 9E01      		movw r18,r28
 1299 04ca E62F      		mov r30,r22
 1300 04cc F72F      		mov r31,r23
 1301 04ce EF01      		movw r28,r30
 1302 04d0 0990      		ld __tmp_reg__,Y+
 1303 04d2 0020      		tst __tmp_reg__
 1304 04d4 01F4      		brne .-6
 1305 04d6 CE01      		movw r24,r28
 1306               	.LVL70:
 1307 04d8 0197      		sbiw r24,1
 1308 04da 8E1B      		sub r24,r30
 1309 04dc 9F0B      		sbc r25,r31
 1310 04de 8A1B      		sub r24,r26
 1311 04e0 9B0B      		sbc r25,r27
 1312 04e2 820F      		add r24,r18
 1313 04e4 931F      		adc r25,r19
 1314 04e6 0E94 0000 		call malloc
 1315               	.LVL71:
 1316 04ea D82F      		mov r29,r24
 1317 04ec C92F      		mov r28,r25
 1318               	.LVL72:
  54:main.c        ****     strcpy(result, s1);
 1319               		.loc 6 54 0
 1320 04ee 6F2D      		mov r22,r15
 1321 04f0 7E2D      		mov r23,r14
 1322 04f2 0E94 0000 		call strcpy
 1323               	.LVL73:
  55:main.c        ****     strcat(result, s2);
 1324               		.loc 6 55 0
 1325 04f6 8D2F      		mov r24,r29
 1326 04f8 9C2F      		mov r25,r28
 1327 04fa 612F      		mov r22,r17
 1328 04fc 702F      		mov r23,r16
 1329 04fe 0E94 0000 		call strcat
  57:main.c        **** }
 1330               		.loc 6 57 0
 1331 0502 8D2F      		mov r24,r29
 1332 0504 9C2F      		mov r25,r28
 1333               	/* epilogue start */
 1334 0506 DF91      		pop r29
 1335               	.LVL74:
 1336 0508 CF91      		pop r28
 1337               	.LVL75:
 1338 050a 1F91      		pop r17
 1339 050c 0F91      		pop r16
 1340 050e FF90      		pop r15
 1341 0510 EF90      		pop r14
 1342 0512 0895      		ret
 1343               		.cfi_endproc
 1344               	.LFE62:
 1346               		.data
 1347               	.LC0:
 1348 0000 2C00      		.string	","
 1349               		.text
 1350               	.global	parse_nmea_string
 1352               	parse_nmea_string:
 1353               	.LFB63:
  60:main.c        **** {
 1354               		.loc 6 60 0
 1355               		.cfi_startproc
 1356               	.LVL76:
 1357 0514 EF92      		push r14
 1358               	.LCFI36:
 1359               		.cfi_def_cfa_offset 3
 1360               		.cfi_offset 14, -2
 1361 0516 FF92      		push r15
 1362               	.LCFI37:
 1363               		.cfi_def_cfa_offset 4
 1364               		.cfi_offset 15, -3
 1365 0518 0F93      		push r16
 1366               	.LCFI38:
 1367               		.cfi_def_cfa_offset 5
 1368               		.cfi_offset 16, -4
 1369 051a 1F93      		push r17
 1370               	.LCFI39:
 1371               		.cfi_def_cfa_offset 6
 1372               		.cfi_offset 17, -5
 1373 051c CF93      		push r28
 1374               	.LCFI40:
 1375               		.cfi_def_cfa_offset 7
 1376               		.cfi_offset 28, -6
 1377 051e DF93      		push r29
 1378               	.LCFI41:
 1379               		.cfi_def_cfa_offset 8
 1380               		.cfi_offset 29, -7
 1381 0520 CDB7      		in r28,__SP_L__
 1382 0522 DEB7      		in r29,__SP_H__
 1383 0524 C05A      		subi r28,lo8(-(-160))
 1384 0526 D040      		sbci r29,hi8(-(-160))
 1385               	.LCFI42:
 1386               		.cfi_def_cfa 28, 168
 1387 0528 CDBF      		out __SP_L__,r28
 1388 052a DEBF      		out __SP_H__,r29
 1389               	/* prologue: function */
 1390               	/* frame size = 160 */
 1391               	/* stack size = 166 */
 1392               	.L__stack_usage = 166
 1393 052c 7B01      		movw r14,r22
 1394               	.LVL77:
  66:main.c        ****   token[0] = strtok(s, ","); //get pointer to first token found and store in 0
 1395               		.loc 6 66 0
 1396 052e 60E0      		ldi r22,lo8(.LC0)
 1397 0530 70E0      		ldi r23,hi8(.LC0)
 1398               	.LVL78:
 1399 0532 0E94 0000 		call strtok
 1400               	.LVL79:
  68:main.c        ****   while(token[i]!= NULL) {   //ensure a pointer was found
 1401               		.loc 6 68 0
 1402 0536 0097      		sbiw r24,0
 1403 0538 01F0      		breq .L56
 1404 053a 8E01      		movw r16,r28
 1405 053c 0D5F      		subi r16,lo8(-(3))
 1406 053e 1F4F      		sbci r17,hi8(-(3))
 1407               	.LVL80:
 1408               	.L57:
  70:main.c        ****       token[i] = strtok(NULL, ","); //continue to tokenize the string
 1409               		.loc 6 70 0
 1410 0540 80E0      		ldi r24,lo8(0)
 1411 0542 90E0      		ldi r25,hi8(0)
 1412 0544 60E0      		ldi r22,lo8(.LC0)
 1413 0546 70E0      		ldi r23,hi8(.LC0)
 1414 0548 0E94 0000 		call strtok
 1415 054c F801      		movw r30,r16
 1416 054e 8193      		st Z+,r24
 1417 0550 9193      		st Z+,r25
 1418 0552 8F01      		movw r16,r30
  68:main.c        ****   while(token[i]!= NULL) {   //ensure a pointer was found
 1419               		.loc 6 68 0
 1420 0554 0097      		sbiw r24,0
 1421 0556 01F4      		brne .L57
 1422               	.L56:
  73:main.c        ****   gps->lat = token[3];
 1423               		.loc 6 73 0
 1424 0558 8F81      		ldd r24,Y+7
 1425 055a 9885      		ldd r25,Y+8
 1426 055c F701      		movw r30,r14
 1427 055e 8083      		st Z,r24
 1428 0560 9183      		std Z+1,r25
  74:main.c        ****   gps->lng = token[5];
 1429               		.loc 6 74 0
 1430 0562 8B85      		ldd r24,Y+11
 1431 0564 9C85      		ldd r25,Y+12
 1432 0566 8283      		std Z+2,r24
 1433 0568 9383      		std Z+3,r25
 1434               	/* epilogue start */
  83:main.c        **** }
 1435               		.loc 6 83 0
 1436 056a C056      		subi r28,lo8(-(160))
 1437 056c DF4F      		sbci r29,hi8(-(160))
 1438 056e CDBF      		out __SP_L__,r28
 1439 0570 DEBF      		out __SP_H__,r29
 1440 0572 DF91      		pop r29
 1441 0574 CF91      		pop r28
 1442 0576 1F91      		pop r17
 1443 0578 0F91      		pop r16
 1444 057a FF90      		pop r15
 1445 057c EF90      		pop r14
 1446               	.LVL81:
 1447 057e 0895      		ret
 1448               		.cfi_endproc
 1449               	.LFE63:
 1451               		.data
 1452               	.LC1:
 1453 0002 2447 5052 		.ascii	"$GPRMC"
 1453      4D43 
 1454 0008 2C31 3733 		.string	",173843,A,3349.896,N,11808.521,W,000.0,360.0,230108,013.4,E*69\r\n"
 1454      3834 332C 
 1454      412C 3333 
 1454      3439 2E38 
 1454      3936 2C4E 
 1455               	.LC2:
 1456 0049 24        		.ascii	"$"
 1457 004a 4750 524D 		.string	"GPRMC,111609.14,A,5001.27,N,3613.06,E,11.2,0.0,261206,0.0,E*50\r\n"
 1457      432C 3131 
 1457      3136 3039 
 1457      2E31 342C 
 1457      412C 3530 
 1458               		.section	.text.startup,"ax",@progbits
 1459               	.global	main
 1461               	main:
 1462               	.LFB65:
 144:main.c        **** int main(void){
 1463               		.loc 6 144 0
 1464               		.cfi_startproc
 1465 0000 CF93      		push r28
 1466               	.LCFI43:
 1467               		.cfi_def_cfa_offset 3
 1468               		.cfi_offset 28, -2
 1469 0002 DF93      		push r29
 1470               	.LCFI44:
 1471               		.cfi_def_cfa_offset 4
 1472               		.cfi_offset 29, -3
 1473 0004 CDB7      		in r28,__SP_L__
 1474 0006 DEB7      		in r29,__SP_H__
 1475 0008 CC5A      		subi r28,lo8(-(-172))
 1476 000a D040      		sbci r29,hi8(-(-172))
 1477               	.LCFI45:
 1478               		.cfi_def_cfa 28, 176
 1479 000c CDBF      		out __SP_L__,r28
 1480 000e DEBF      		out __SP_H__,r29
 1481               	/* prologue: function */
 1482               	/* frame size = 172 */
 1483               	/* stack size = 174 */
 1484               	.L__stack_usage = 174
 145:main.c        **** 	USB_ConfigureClock();
 1485               		.loc 6 145 0
 1486 0010 0E94 0000 		call USB_ConfigureClock
 146:main.c        **** 	USB_Init();
 1487               		.loc 6 146 0
 1488 0014 0E94 0000 		call USB_Init
 147:main.c        **** 	USB.INTCTRLA = USB_BUSEVIE_bm | USB_INTLVL_MED_gc;
 1489               		.loc 6 147 0
 1490 0018 E0EC      		ldi r30,lo8(1216)
 1491 001a F4E0      		ldi r31,hi8(1216)
 1492 001c 82E4      		ldi r24,lo8(66)
 1493 001e 8087      		std Z+8,r24
 148:main.c        **** 	USB.INTCTRLB = USB_TRNIE_bm | USB_SETUPIE_bm;
 1494               		.loc 6 148 0
 1495 0020 83E0      		ldi r24,lo8(3)
 1496 0022 8187      		std Z+9,r24
 149:main.c        **** 	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
 1497               		.loc 6 149 0
 1498 0024 E0EA      		ldi r30,lo8(160)
 1499 0026 F0E0      		ldi r31,hi8(160)
 1500 0028 8283      		std Z+2,r24
 150:main.c        **** 	sei();
 1501               		.loc 6 150 0
 1502               	/* #APP */
 1503               	 ;  150 "main.c" 1
 1504 002a 7894      		sei
 1505               	 ;  0 "" 2
 155:main.c        **** 	break_and_flush();
 1506               		.loc 6 155 0
 1507               	/* #NOAPP */
 1508 002c 0E94 0000 		call break_and_flush
 1509               	.LBB959:
 1510               	.LBB960:
  87:main.c        ****     char *buff[] = {
 1511               		.loc 6 87 0
 1512 0030 80E0      		ldi r24,lo8(.LC1)
 1513 0032 90E0      		ldi r25,hi8(.LC1)
 1514 0034 8983      		std Y+1,r24
 1515 0036 9A83      		std Y+2,r25
 1516 0038 80E0      		ldi r24,lo8(.LC2)
 1517 003a 90E0      		ldi r25,hi8(.LC2)
 1518 003c 8B83      		std Y+3,r24
 1519 003e 9C83      		std Y+4,r25
 1520               	.LVL82:
 1521 0040 9E01      		movw r18,r28
 1522 0042 2F5F      		subi r18,lo8(-(1))
 1523 0044 3F4F      		sbci r19,hi8(-(1))
 1524 0046 C755      		subi r28,lo8(-169)
 1525 0048 DF4F      		sbci r29,hi8(-169)
 1526 004a 2883      		st Y,r18
 1527 004c 3983      		std Y+1,r19
 1528 004e C95A      		subi r28,lo8(169)
 1529 0050 D040      		sbci r29,hi8(169)
 144:main.c        **** int main(void){
 1530               		.loc 6 144 0
 1531 0052 9E01      		movw r18,r28
 1532 0054 2B5F      		subi r18,lo8(-(5))
 1533 0056 3F4F      		sbci r19,hi8(-(5))
 1534 0058 CB55      		subi r28,lo8(-165)
 1535 005a DF4F      		sbci r29,hi8(-165)
 1536 005c 2883      		st Y,r18
 1537 005e 3983      		std Y+1,r19
 1538 0060 C55A      		subi r28,lo8(165)
 1539 0062 D040      		sbci r29,hi8(165)
 1540 0064 40E0      		ldi r20,lo8(ep_in_pipe_buffer)
 1541 0066 A42E      		mov r10,r20
 1542 0068 40E0      		ldi r20,hi8(ep_in_pipe_buffer)
 1543 006a B42E      		mov r11,r20
 1544 006c 50E0      		ldi r21,lo8(endpoints+24)
 1545 006e 652E      		mov r6,r21
 1546 0070 50E0      		ldi r21,hi8(endpoints+24)
 1547 0072 752E      		mov r7,r21
 1548               	.LBB961:
 1549               	.LBB962:
 1550               	.LBB963:
 1551               	.LBB964:
 1552               	.LBB965:
 1553               	.LBB966:
 1554               	.LBB967:
 1555               	.LBB968:
 1556               	.LBB969:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 1557               		.loc 5 57 0
 1558 0074 66E0      		ldi r22,lo8(6)
 1559 0076 F62E      		mov r15,r22
 1560               	.LBE969:
 1561               	.LBE968:
 1562               	.LBE967:
 1563               	.LBE966:
 1564               	.LBE965:
 1565               	.LBB980:
 1566               	.LBB981:
 1567               	.LBB982:
 1568               	.LBB983:
 1569               	.LBB984:
 1570               	.LBB985:
 1571               	.LBB986:
 1572               	.LBB987:
 1573               	.LBB988:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 1574               		.loc 2 69 0
 1575 0078 71E0      		ldi r23,lo8(1)
 1576 007a C72E      		mov r12,r23
 1577 007c D12C      		mov r13,__zero_reg__
 1578               	.LBE988:
 1579               	.LBE987:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 1580               		.loc 2 88 0
 1581 007e A2E0      		ldi r26,lo8(2)
 1582 0080 EA2E      		mov r14,r26
 1583               	.LBB997:
 1584               	.LBB998:
 1585               	.LBB999:
 1586               	.LBB1000:
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1587               		.loc 4 169 0
 1588 0082 B0E4      		ldi r27,lo8(64)
 1589 0084 8B2E      		mov r8,r27
 1590 0086 912C      		mov r9,__zero_reg__
 1591               	.LVL83:
 1592               	.L122:
 1593               	.LBE1000:
 1594               	.LBE999:
 1595               	.LBE998:
 1596               	.LBE997:
 1597               	.LBE986:
 1598               	.LBE985:
 1599               	.LBE984:
 1600               	.LBE983:
 1601               	.LBE982:
 1602               	.LBE981:
 1603               	.LBE980:
 1604               	.LBE964:
 1605               	.LBE963:
 1606               	.LBE962:
 1607               	.LBB1076:
 1608               	.LBB1077:
  66:main.c        ****   token[0] = strtok(s, ","); //get pointer to first token found and store in 0
 1609               		.loc 6 66 0
 1610 0088 C755      		subi r28,lo8(-169)
 1611 008a DF4F      		sbci r29,hi8(-169)
 1612 008c E881      		ld r30,Y
 1613 008e F981      		ldd r31,Y+1
 1614 0090 C95A      		subi r28,lo8(169)
 1615 0092 D040      		sbci r29,hi8(169)
 1616 0094 8191      		ld r24,Z+
 1617 0096 9191      		ld r25,Z+
 1618 0098 C755      		subi r28,lo8(-169)
 1619 009a DF4F      		sbci r29,hi8(-169)
 1620 009c E883      		st Y,r30
 1621 009e F983      		std Y+1,r31
 1622 00a0 C95A      		subi r28,lo8(169)
 1623 00a2 D040      		sbci r29,hi8(169)
 1624 00a4 60E0      		ldi r22,lo8(.LC0)
 1625 00a6 70E0      		ldi r23,hi8(.LC0)
 1626 00a8 0E94 0000 		call strtok
 1627               	.LVL84:
  68:main.c        ****   while(token[i]!= NULL) {   //ensure a pointer was found
 1628               		.loc 6 68 0
 1629 00ac 0097      		sbiw r24,0
 1630 00ae 01F0      		breq .L60
 1631 00b0 8E01      		movw r16,r28
 1632 00b2 095F      		subi r16,lo8(-(7))
 1633 00b4 1F4F      		sbci r17,hi8(-(7))
 1634               	.LVL85:
 1635               	.L61:
  70:main.c        ****       token[i] = strtok(NULL, ","); //continue to tokenize the string
 1636               		.loc 6 70 0
 1637 00b6 80E0      		ldi r24,lo8(0)
 1638 00b8 90E0      		ldi r25,hi8(0)
 1639 00ba 60E0      		ldi r22,lo8(.LC0)
 1640 00bc 70E0      		ldi r23,hi8(.LC0)
 1641 00be 0E94 0000 		call strtok
 1642 00c2 F801      		movw r30,r16
 1643 00c4 8193      		st Z+,r24
 1644 00c6 9193      		st Z+,r25
 1645 00c8 8F01      		movw r16,r30
  68:main.c        ****   while(token[i]!= NULL) {   //ensure a pointer was found
 1646               		.loc 6 68 0
 1647 00ca 0097      		sbiw r24,0
 1648 00cc 01F4      		brne .L61
 1649               	.L60:
  73:main.c        ****   gps->lat = token[3];
 1650               		.loc 6 73 0
 1651 00ce 8B85      		ldd r24,Y+11
 1652 00d0 9C85      		ldd r25,Y+12
 1653               	.LVL86:
  74:main.c        ****   gps->lng = token[5];
 1654               		.loc 6 74 0
 1655 00d2 2F85      		ldd r18,Y+15
 1656 00d4 C555      		subi r28,lo8(-171)
 1657 00d6 DF4F      		sbci r29,hi8(-171)
 1658 00d8 2883      		st Y,r18
 1659 00da CB5A      		subi r28,lo8(171)
 1660 00dc D040      		sbci r29,hi8(171)
 1661 00de 3889      		ldd r19,Y+16
 1662 00e0 C455      		subi r28,lo8(-172)
 1663 00e2 DF4F      		sbci r29,hi8(-172)
 1664 00e4 3883      		st Y,r19
 1665 00e6 CC5A      		subi r28,lo8(172)
 1666 00e8 D040      		sbci r29,hi8(172)
 1667               	.LVL87:
 1668               	.LBE1077:
 1669               	.LBE1076:
 117:main.c        ****       int len_lat = strlen(gps.lat);
 1670               		.loc 6 117 0
 1671 00ea FC01      		movw r30,r24
 1672 00ec DF01      		movw r26,r30
 1673 00ee 0D90      		ld __tmp_reg__,X+
 1674 00f0 0020      		tst __tmp_reg__
 1675 00f2 01F4      		brne .-6
 1676 00f4 1197      		sbiw r26,1
 1677 00f6 AE1B      		sub r26,r30
 1678 00f8 BF0B      		sbc r27,r31
 1679               	.LVL88:
 118:main.c        ****       int len_lng = strlen(gps.lng);
 1680               		.loc 6 118 0
 1681 00fa F901      		movw r30,r18
 1682 00fc 0190      		ld __tmp_reg__,Z+
 1683 00fe 0020      		tst __tmp_reg__
 1684 0100 01F4      		brne .-6
 1685 0102 2F01      		movw r4,r30
 1686 0104 0894      		sec
 1687 0106 4108      		sbc r4,__zero_reg__
 1688 0108 5108      		sbc r5,__zero_reg__
 1689 010a 421A      		sub r4,r18
 1690 010c 530A      		sbc r5,r19
 1691               	.LVL89:
 1692               	.LBB1078:
 120:main.c        ****       for (int i=0; i<len_lat; i++) {
 1693               		.loc 6 120 0
 1694 010e 1A16      		cp __zero_reg__,r26
 1695 0110 1B06      		cpc __zero_reg__,r27
 1696 0112 04F0      		brlt .+2
 1697 0114 00C0      		rjmp .L129
 1698 0116 C955      		subi r28,lo8(-167)
 1699 0118 DF4F      		sbci r29,hi8(-167)
 1700 011a 8883      		st Y,r24
 1701 011c C75A      		subi r28,lo8(167)
 1702 011e D040      		sbci r29,hi8(167)
 1703 0120 C855      		subi r28,lo8(-168)
 1704 0122 DF4F      		sbci r29,hi8(-168)
 1705 0124 9883      		st Y,r25
 1706 0126 C85A      		subi r28,lo8(168)
 1707 0128 D040      		sbci r29,hi8(168)
 1708 012a 2224      		clr r2
 1709 012c 3324      		clr r3
 1710               	.LVL90:
 1711               	.L77:
 121:main.c        ****         send_byte(gps.lat[i]);  
 1712               		.loc 6 121 0
 1713 012e C955      		subi r28,lo8(-167)
 1714 0130 DF4F      		sbci r29,hi8(-167)
 1715 0132 E881      		ld r30,Y
 1716 0134 F981      		ldd r31,Y+1
 1717 0136 C75A      		subi r28,lo8(167)
 1718 0138 D040      		sbci r29,hi8(167)
 1719 013a 3191      		ld r19,Z+
 1720 013c C955      		subi r28,lo8(-167)
 1721 013e DF4F      		sbci r29,hi8(-167)
 1722 0140 E883      		st Y,r30
 1723 0142 F983      		std Y+1,r31
 1724 0144 C75A      		subi r28,lo8(167)
 1725 0146 D040      		sbci r29,hi8(167)
 1726               	.LVL91:
 1727               	.L65:
 1728               	.LBB1071:
 1729               	.LBB1066:
 1730               	.LBB1059:
 1731               	.LBB978:
 1732               	.LBB976:
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1733               		.loc 2 123 0
 1734 0148 9FB7      		in r25,__SREG__
 1735               	.LVL92:
 1736               	.LBB971:
 1737               	.LBB972:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 1738               		.loc 3 50 0
 1739               	/* #APP */
 1740               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 1741 014a F894      		cli
 1742               	 ;  0 "" 2
 1743               	.LVL93:
 1744               	/* #NOAPP */
 1745               	.LBE972:
 1746               	.LBE971:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 1747               		.loc 2 124 0
 1748 014c 8091 0000 		lds r24,ep_in_data+1
 1749 0150 8823      		tst r24
 1750 0152 01F4      		brne .+2
 1751 0154 00C0      		rjmp .L143
 1752               	.L124:
 125:usb/usb_pipe.h **** 			r = false;
 1753               		.loc 2 125 0
 1754 0156 80E0      		ldi r24,lo8(0)
 1755               	.L63:
 1756               	.LBB973:
 1757               	.LBB974:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 1758               		.loc 3 70 0
 1759 0158 9FBF      		out __SREG__,r25
 1760               		.loc 3 71 0
 1761               	.LBE974:
 1762               	.LBE973:
 1763               	.LBE976:
 1764               	.LBE978:
 1765               	.LBE1059:
  20:Framework.h   ****     while (!usb_pipe_can_write(&ep_in));
 1766               		.loc 1 20 0
 1767 015a 8823      		tst r24
 1768 015c 01F0      		breq .L65
 1769               	.LVL94:
 1770               	.LBB1060:
 1771               	.LBB1061:
 128:usb/usb_pipe.h **** 		}
 129:usb/usb_pipe.h **** 	}
 130:usb/usb_pipe.h **** 	return r;
 131:usb/usb_pipe.h **** }
 132:usb/usb_pipe.h **** 
 133:usb/usb_pipe.h **** static inline uint8_t* usb_pipe_write_ptr(const USB_Pipe* p){
 134:usb/usb_pipe.h **** 	return pipe_write_ptr(p->pipe);
 135:usb/usb_pipe.h **** }
 136:usb/usb_pipe.h **** 
 137:usb/usb_pipe.h **** static inline void usb_pipe_done_write(const USB_Pipe* p){
 138:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 139:usb/usb_pipe.h **** 		pipe_done_write(p->pipe);
 140:usb/usb_pipe.h **** 	}
 141:usb/usb_pipe.h **** }
 142:usb/usb_pipe.h **** 
 143:usb/usb_pipe.h **** static inline bool usb_pipe_can_read(const USB_Pipe* p) ATTR_ALWAYS_INLINE;
 144:usb/usb_pipe.h **** static inline bool usb_pipe_can_read(const USB_Pipe* p){
 145:usb/usb_pipe.h **** 	bool r;
 146:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 147:usb/usb_pipe.h **** 		r = pipe_can_read(p->pipe) > 0;
 148:usb/usb_pipe.h **** 	}
 149:usb/usb_pipe.h **** 	return r;
 150:usb/usb_pipe.h **** }
 151:usb/usb_pipe.h **** 
 152:usb/usb_pipe.h **** static inline uint8_t* usb_pipe_read_ptr(const USB_Pipe* p){
 153:usb/usb_pipe.h **** 	return pipe_read_ptr(p->pipe);
 154:usb/usb_pipe.h **** }
 155:usb/usb_pipe.h **** 
 156:usb/usb_pipe.h **** static inline void usb_pipe_done_read(const USB_Pipe* p){
 157:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 158:usb/usb_pipe.h **** 		pipe_done_read(p->pipe);
 159:usb/usb_pipe.h **** 	}
 160:usb/usb_pipe.h **** }
 161:usb/usb_pipe.h **** 
 162:usb/usb_pipe.h **** static inline uint8_t usb_pipe_read_byte(const USB_Pipe* p){
 163:usb/usb_pipe.h **** 	uint8_t r = p->pipe->data->read_ptr[p->data->packet_offset++];
 164:usb/usb_pipe.h **** 	if (p->data->packet_offset == p->pipe->size){
 165:usb/usb_pipe.h **** 		ATOMIC_BLOCK(PIPE_ATOMIC){
 166:usb/usb_pipe.h **** 			p->data->packet_offset = 0;
 167:usb/usb_pipe.h **** 			pipe_done_read(p->pipe);
 168:usb/usb_pipe.h **** 			usb_pipe_handle(p);
 169:usb/usb_pipe.h **** 		}
 170:usb/usb_pipe.h **** 	}
 171:usb/usb_pipe.h **** 	return r;
 172:usb/usb_pipe.h **** }
 173:usb/usb_pipe.h **** 
 174:usb/usb_pipe.h **** static inline void usb_pipe_write_byte(const USB_Pipe* p, uint8_t v){
 175:usb/usb_pipe.h **** 	p->pipe->data->write_ptr[p->data->packet_offset++] = v;
 1772               		.loc 2 175 0
 1773 015e 8091 0000 		lds r24,ep_in_data+2
 1774 0162 9091 0000 		lds r25,ep_in_data+2+1
 1775 0166 E091 0000 		lds r30,ep_in_pipe_data+2
 1776 016a F091 0000 		lds r31,ep_in_pipe_data+2+1
 1777 016e E80F      		add r30,r24
 1778 0170 F91F      		adc r31,r25
 1779 0172 3083      		st Z,r19
 1780 0174 0196      		adiw r24,1
 1781 0176 8093 0000 		sts ep_in_data+2,r24
 1782 017a 9093 0000 		sts ep_in_data+2+1,r25
 176:usb/usb_pipe.h **** 	if (p->data->packet_offset == p->pipe->size){
 1783               		.loc 2 176 0
 1784 017e 8034      		cpi r24,64
 1785 0180 9105      		cpc r25,__zero_reg__
 1786 0182 01F4      		brne .+2
 1787 0184 00C0      		rjmp .L144
 1788               	.LVL95:
 1789               	.L66:
 1790               	.LBE1061:
 1791               	.LBE1060:
 1792               	.LBE1066:
 1793               	.LBE1071:
 120:main.c        ****       for (int i=0; i<len_lat; i++) {
 1794               		.loc 6 120 0
 1795 0186 0894      		sec
 1796 0188 211C      		adc r2,__zero_reg__
 1797 018a 311C      		adc r3,__zero_reg__
 1798               	.LVL96:
 1799 018c A215      		cp r26,r2
 1800 018e B305      		cpc r27,r3
 1801 0190 01F4      		brne .L77
 1802               	.LVL97:
 1803               	.L129:
 1804               	.LBE1078:
 1805               	.LBB1079:
 1806               	.LBB1080:
 1807               	.LBB1081:
 1808               	.LBB1082:
 1809               	.LBB1083:
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1810               		.loc 2 123 0
 1811 0192 9FB7      		in r25,__SREG__
 1812               	.LVL98:
 1813               	.LBB1084:
 1814               	.LBB1085:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 1815               		.loc 3 50 0
 1816               	/* #APP */
 1817               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 1818 0194 F894      		cli
 1819               	 ;  0 "" 2
 1820               	.LVL99:
 1821               	/* #NOAPP */
 1822               	.LBE1085:
 1823               	.LBE1084:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 1824               		.loc 2 124 0
 1825 0196 8091 0000 		lds r24,ep_in_data+1
 1826 019a 8823      		tst r24
 1827 019c 01F4      		brne .+2
 1828 019e 00C0      		rjmp .L145
 1829               	.L125:
 125:usb/usb_pipe.h **** 			r = false;
 1830               		.loc 2 125 0
 1831 01a0 80E0      		ldi r24,lo8(0)
 1832               	.L78:
 1833               	.LBB1086:
 1834               	.LBB1087:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 1835               		.loc 3 70 0
 1836 01a2 9FBF      		out __SREG__,r25
 1837               		.loc 3 71 0
 1838               	.LBE1087:
 1839               	.LBE1086:
 1840               	.LBE1083:
 1841               	.LBE1082:
 1842               	.LBE1081:
  20:Framework.h   ****     while (!usb_pipe_can_write(&ep_in));
 1843               		.loc 1 20 0
 1844 01a4 8823      		tst r24
 1845 01a6 01F0      		breq .L129
 1846               	.LVL100:
 1847               	.LBB1092:
 1848               	.LBB1093:
 175:usb/usb_pipe.h **** 	p->pipe->data->write_ptr[p->data->packet_offset++] = v;
 1849               		.loc 2 175 0
 1850 01a8 8091 0000 		lds r24,ep_in_data+2
 1851 01ac 9091 0000 		lds r25,ep_in_data+2+1
 1852 01b0 E091 0000 		lds r30,ep_in_pipe_data+2
 1853 01b4 F091 0000 		lds r31,ep_in_pipe_data+2+1
 1854 01b8 E80F      		add r30,r24
 1855 01ba F91F      		adc r31,r25
 1856 01bc 20E2      		ldi r18,lo8(32)
 1857 01be 2083      		st Z,r18
 1858 01c0 0196      		adiw r24,1
 1859 01c2 8093 0000 		sts ep_in_data+2,r24
 1860 01c6 9093 0000 		sts ep_in_data+2+1,r25
 1861               		.loc 2 176 0
 1862 01ca 8034      		cpi r24,64
 1863 01cc 9105      		cpc r25,__zero_reg__
 1864 01ce 01F4      		brne .+2
 1865 01d0 00C0      		rjmp .L146
 1866               	.LVL101:
 1867               	.L81:
 1868               	.LBE1093:
 1869               	.LBE1092:
 1870               	.LBE1080:
 1871               	.LBE1079:
 1872               	.LBB1166:
 124:main.c        ****       for (int j=0; j<len_lng; j++) {
 1873               		.loc 6 124 0
 1874 01d2 1414      		cp __zero_reg__,r4
 1875 01d4 1504      		cpc __zero_reg__,r5
 1876 01d6 04F4      		brge .L128
 1877 01d8 C555      		subi r28,lo8(-171)
 1878 01da DF4F      		sbci r29,hi8(-171)
 1879 01dc 2880      		ld r2,Y
 1880 01de CB5A      		subi r28,lo8(171)
 1881 01e0 D040      		sbci r29,hi8(171)
 1882 01e2 C455      		subi r28,lo8(-172)
 1883 01e4 DF4F      		sbci r29,hi8(-172)
 1884 01e6 3880      		ld r3,Y
 1885 01e8 CC5A      		subi r28,lo8(172)
 1886 01ea D040      		sbci r29,hi8(172)
 1887 01ec A0E0      		ldi r26,lo8(0)
 1888 01ee B0E0      		ldi r27,hi8(0)
 1889               	.LVL102:
 1890               	.L107:
 125:main.c        ****         send_byte(gps.lng[j]);  
 1891               		.loc 6 125 0
 1892 01f0 F101      		movw r30,r2
 1893 01f2 2191      		ld r18,Z+
 1894 01f4 1F01      		movw r2,r30
 1895               	.LVL103:
 1896               	.L95:
 1897               	.LBB1167:
 1898               	.LBB1168:
 1899               	.LBB1169:
 1900               	.LBB1170:
 1901               	.LBB1171:
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1902               		.loc 2 123 0
 1903 01f6 9FB7      		in r25,__SREG__
 1904               	.LVL104:
 1905               	.LBB1172:
 1906               	.LBB1173:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 1907               		.loc 3 50 0
 1908               	/* #APP */
 1909               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 1910 01f8 F894      		cli
 1911               	 ;  0 "" 2
 1912               	.LVL105:
 1913               	/* #NOAPP */
 1914               	.LBE1173:
 1915               	.LBE1172:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 1916               		.loc 2 124 0
 1917 01fa 8091 0000 		lds r24,ep_in_data+1
 1918 01fe 8823      		tst r24
 1919 0200 01F4      		brne .+2
 1920 0202 00C0      		rjmp .L147
 1921               	.L126:
 125:usb/usb_pipe.h **** 			r = false;
 1922               		.loc 2 125 0
 1923 0204 80E0      		ldi r24,lo8(0)
 1924               	.L93:
 1925               	.LBB1174:
 1926               	.LBB1175:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 1927               		.loc 3 70 0
 1928 0206 9FBF      		out __SREG__,r25
 1929               		.loc 3 71 0
 1930               	.LBE1175:
 1931               	.LBE1174:
 1932               	.LBE1171:
 1933               	.LBE1170:
 1934               	.LBE1169:
  20:Framework.h   ****     while (!usb_pipe_can_write(&ep_in));
 1935               		.loc 1 20 0
 1936 0208 8823      		tst r24
 1937 020a 01F0      		breq .L95
 1938               	.LVL106:
 1939               	.LBB1180:
 1940               	.LBB1181:
 175:usb/usb_pipe.h **** 	p->pipe->data->write_ptr[p->data->packet_offset++] = v;
 1941               		.loc 2 175 0
 1942 020c 8091 0000 		lds r24,ep_in_data+2
 1943 0210 9091 0000 		lds r25,ep_in_data+2+1
 1944 0214 E091 0000 		lds r30,ep_in_pipe_data+2
 1945 0218 F091 0000 		lds r31,ep_in_pipe_data+2+1
 1946               	.LVL107:
 1947 021c E80F      		add r30,r24
 1948 021e F91F      		adc r31,r25
 1949 0220 2083      		st Z,r18
 1950 0222 0196      		adiw r24,1
 1951 0224 8093 0000 		sts ep_in_data+2,r24
 1952 0228 9093 0000 		sts ep_in_data+2+1,r25
 1953               		.loc 2 176 0
 1954 022c 8034      		cpi r24,64
 1955 022e 9105      		cpc r25,__zero_reg__
 1956 0230 01F4      		brne .+2
 1957 0232 00C0      		rjmp .L148
 1958               	.LVL108:
 1959               	.L96:
 1960               	.LBE1181:
 1961               	.LBE1180:
 1962               	.LBE1168:
 1963               	.LBE1167:
 124:main.c        ****       for (int j=0; j<len_lng; j++) {
 1964               		.loc 6 124 0
 1965 0234 1196      		adiw r26,1
 1966               	.LVL109:
 1967 0236 4A16      		cp r4,r26
 1968 0238 5B06      		cpc r5,r27
 1969 023a 01F4      		brne .L107
 1970               	.LVL110:
 1971               	.L128:
 1972               	.LBE1166:
 1973               	.LBB1251:
 1974               	.LBB1252:
 1975               	.LBB1253:
 1976               	.LBB1254:
 1977               	.LBB1255:
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1978               		.loc 2 123 0
 1979 023c 9FB7      		in r25,__SREG__
 1980               	.LVL111:
 1981               	.LBB1256:
 1982               	.LBB1257:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 1983               		.loc 3 50 0
 1984               	/* #APP */
 1985               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 1986 023e F894      		cli
 1987               	 ;  0 "" 2
 1988               	.LVL112:
 1989               	/* #NOAPP */
 1990               	.LBE1257:
 1991               	.LBE1256:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 1992               		.loc 2 124 0
 1993 0240 8091 0000 		lds r24,ep_in_data+1
 1994 0244 8823      		tst r24
 1995 0246 01F4      		brne .+2
 1996 0248 00C0      		rjmp .L149
 1997               	.L127:
 125:usb/usb_pipe.h **** 			r = false;
 1998               		.loc 2 125 0
 1999 024a 80E0      		ldi r24,lo8(0)
 2000               	.L108:
 2001               	.LBB1258:
 2002               	.LBB1259:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 2003               		.loc 3 70 0
 2004 024c 9FBF      		out __SREG__,r25
 2005               		.loc 3 71 0
 2006               	.LBE1259:
 2007               	.LBE1258:
 2008               	.LBE1255:
 2009               	.LBE1254:
 2010               	.LBE1253:
  20:Framework.h   ****     while (!usb_pipe_can_write(&ep_in));
 2011               		.loc 1 20 0
 2012 024e 8823      		tst r24
 2013 0250 01F0      		breq .L128
 2014               	.LVL113:
 2015               	.LBB1264:
 2016               	.LBB1265:
 175:usb/usb_pipe.h **** 	p->pipe->data->write_ptr[p->data->packet_offset++] = v;
 2017               		.loc 2 175 0
 2018 0252 8091 0000 		lds r24,ep_in_data+2
 2019 0256 9091 0000 		lds r25,ep_in_data+2+1
 2020 025a E091 0000 		lds r30,ep_in_pipe_data+2
 2021 025e F091 0000 		lds r31,ep_in_pipe_data+2+1
 2022 0262 E80F      		add r30,r24
 2023 0264 F91F      		adc r31,r25
 2024 0266 2AE0      		ldi r18,lo8(10)
 2025 0268 2083      		st Z,r18
 2026 026a 0196      		adiw r24,1
 2027 026c 8093 0000 		sts ep_in_data+2,r24
 2028 0270 9093 0000 		sts ep_in_data+2+1,r25
 2029               		.loc 2 176 0
 2030 0274 8034      		cpi r24,64
 2031 0276 9105      		cpc r25,__zero_reg__
 2032 0278 01F4      		brne .+2
 2033 027a 00C0      		rjmp .L150
 2034               	.LVL114:
 2035               	.L111:
 2036               	.LBE1265:
 2037               	.LBE1264:
 2038               	.LBE1252:
 2039               	.LBE1251:
 2040               	.LBE961:
 106:main.c        ****     for(it = 0; it < 2; ++it){
 2041               		.loc 6 106 0
 2042 027c C755      		subi r28,lo8(-169)
 2043 027e DF4F      		sbci r29,hi8(-169)
 2044 0280 2881      		ld r18,Y
 2045 0282 3981      		ldd r19,Y+1
 2046 0284 C95A      		subi r28,lo8(169)
 2047 0286 D040      		sbci r29,hi8(169)
 2048 0288 CB55      		subi r28,lo8(-165)
 2049 028a DF4F      		sbci r29,hi8(-165)
 2050 028c 8881      		ld r24,Y
 2051 028e 9981      		ldd r25,Y+1
 2052 0290 C55A      		subi r28,lo8(165)
 2053 0292 D040      		sbci r29,hi8(165)
 2054 0294 2817      		cp r18,r24
 2055 0296 3907      		cpc r19,r25
 2056 0298 01F0      		breq .+2
 2057 029a 00C0      		rjmp .L122
 129:main.c        ****     break_and_flush();
 2058               		.loc 6 129 0
 2059 029c 0E94 0000 		call break_and_flush
 2060               	.LVL115:
 2061               	.L123:
 2062 02a0 00C0      		rjmp .L123
 2063               	.LVL116:
 2064               	.L143:
 2065               	.LBB1353:
 2066               	.LBB1338:
 2067               	.LBB1072:
 2068               	.LBB1067:
 2069               	.LBB1062:
 2070               	.LBB979:
 2071               	.LBB977:
 2072               	.LBB975:
 2073               	.LBB970:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 2074               		.loc 5 57 0
 2075 02a2 8091 0000 		lds r24,ep_in_pipe_data+4
 2076 02a6 2F2D      		mov r18,r15
 2077 02a8 281B      		sub r18,r24
 2078               	.LBE970:
 2079               	.LBE975:
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 2080               		.loc 2 127 0
 2081 02aa 81E0      		ldi r24,lo8(1)
 2082 02ac 1216      		cp __zero_reg__,r18
 2083 02ae 04F4      		brge .+2
 2084 02b0 00C0      		rjmp .L63
 2085 02b2 00C0      		rjmp .L124
 2086               	.LVL117:
 2087               	.L147:
 2088               	.LBE977:
 2089               	.LBE979:
 2090               	.LBE1062:
 2091               	.LBE1067:
 2092               	.LBE1072:
 2093               	.LBE1338:
 2094               	.LBB1339:
 2095               	.LBB1248:
 2096               	.LBB1245:
 2097               	.LBB1182:
 2098               	.LBB1179:
 2099               	.LBB1178:
 2100               	.LBB1176:
 2101               	.LBB1177:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 2102               		.loc 5 57 0
 2103 02b4 8091 0000 		lds r24,ep_in_pipe_data+4
 2104 02b8 3F2D      		mov r19,r15
 2105 02ba 381B      		sub r19,r24
 2106               	.LBE1177:
 2107               	.LBE1176:
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 2108               		.loc 2 127 0
 2109 02bc 81E0      		ldi r24,lo8(1)
 2110 02be 1316      		cp __zero_reg__,r19
 2111 02c0 04F4      		brge .+2
 2112 02c2 00C0      		rjmp .L93
 2113 02c4 00C0      		rjmp .L126
 2114               	.LVL118:
 2115               	.L149:
 2116               	.LBE1178:
 2117               	.LBE1179:
 2118               	.LBE1182:
 2119               	.LBE1245:
 2120               	.LBE1248:
 2121               	.LBE1339:
 2122               	.LBB1340:
 2123               	.LBB1334:
 2124               	.LBB1266:
 2125               	.LBB1263:
 2126               	.LBB1262:
 2127               	.LBB1260:
 2128               	.LBB1261:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 2129               		.loc 5 57 0
 2130 02c6 8091 0000 		lds r24,ep_in_pipe_data+4
 2131 02ca 2F2D      		mov r18,r15
 2132 02cc 281B      		sub r18,r24
 2133               	.LBE1261:
 2134               	.LBE1260:
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 2135               		.loc 2 127 0
 2136 02ce 81E0      		ldi r24,lo8(1)
 2137 02d0 1216      		cp __zero_reg__,r18
 2138 02d2 04F4      		brge .+2
 2139 02d4 00C0      		rjmp .L108
 2140 02d6 00C0      		rjmp .L127
 2141               	.LVL119:
 2142               	.L145:
 2143               	.LBE1262:
 2144               	.LBE1263:
 2145               	.LBE1266:
 2146               	.LBE1334:
 2147               	.LBE1340:
 2148               	.LBB1341:
 2149               	.LBB1162:
 2150               	.LBB1094:
 2151               	.LBB1091:
 2152               	.LBB1090:
 2153               	.LBB1088:
 2154               	.LBB1089:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 2155               		.loc 5 57 0
 2156 02d8 8091 0000 		lds r24,ep_in_pipe_data+4
 2157 02dc 2F2D      		mov r18,r15
 2158 02de 281B      		sub r18,r24
 2159               	.LBE1089:
 2160               	.LBE1088:
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 2161               		.loc 2 127 0
 2162 02e0 81E0      		ldi r24,lo8(1)
 2163 02e2 1216      		cp __zero_reg__,r18
 2164 02e4 04F4      		brge .+2
 2165 02e6 00C0      		rjmp .L78
 2166 02e8 00C0      		rjmp .L125
 2167               	.LVL120:
 2168               	.L144:
 2169               	.LBE1090:
 2170               	.LBE1091:
 2171               	.LBE1094:
 2172               	.LBE1162:
 2173               	.LBE1341:
 2174               	.LBB1342:
 2175               	.LBB1073:
 2176               	.LBB1068:
 2177               	.LBB1063:
 2178               	.LBB1056:
 2179               	.LBB1053:
 2180               	.LBB1050:
 177:usb/usb_pipe.h **** 		ATOMIC_BLOCK(PIPE_ATOMIC){
 2181               		.loc 2 177 0
 2182 02ea 1FB7      		in r17,__SREG__
 2183               	.LVL121:
 2184               	.LBB1040:
 2185               	.LBB1041:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 2186               		.loc 3 50 0
 2187               	/* #APP */
 2188               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 2189 02ec F894      		cli
 2190               	 ;  0 "" 2
 2191               	.LVL122:
 2192               	/* #NOAPP */
 2193               	.LBE1041:
 2194               	.LBE1040:
 178:usb/usb_pipe.h **** 			p->data->packet_offset = 0;
 2195               		.loc 2 178 0
 2196 02ee 1092 0000 		sts ep_in_data+2,__zero_reg__
 2197 02f2 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 2198               	.LVL123:
 2199               	.LBB1042:
 2200               	.LBB1043:
  81:usb/pipe.h    **** 	pipe->data->count += 1;
 2201               		.loc 5 81 0
 2202 02f6 8091 0000 		lds r24,ep_in_pipe_data+4
 2203 02fa 8F5F      		subi r24,lo8(-(1))
 2204 02fc 8093 0000 		sts ep_in_pipe_data+4,r24
  82:usb/pipe.h    **** 	pipe->data->write_ptr += pipe->size;
 2205               		.loc 5 82 0
 2206 0300 8091 0000 		lds r24,ep_in_pipe_data+2
 2207 0304 9091 0000 		lds r25,ep_in_pipe_data+2+1
 2208 0308 805C      		subi r24,lo8(-(64))
 2209 030a 9F4F      		sbci r25,hi8(-(64))
 2210 030c 8093 0000 		sts ep_in_pipe_data+2,r24
 2211 0310 9093 0000 		sts ep_in_pipe_data+2+1,r25
  84:usb/pipe.h    **** 	if (pipe->data->write_ptr == &pipe->buffer[pipe->slots*pipe->size])
 2212               		.loc 5 84 0
 2213 0314 F0E0      		ldi r31,hi8(ep_in_pipe_buffer+512)
 2214 0316 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 2215 0318 9F07      		cpc r25,r31
 2216 031a 01F4      		brne .L67
  85:usb/pipe.h    **** 		pipe->data->write_ptr = &pipe->buffer[0];
 2217               		.loc 5 85 0
 2218 031c A092 0000 		sts ep_in_pipe_data+2,r10
 2219 0320 B092 0000 		sts ep_in_pipe_data+2+1,r11
 2220               	.L67:
 2221               	.LVL124:
 2222               	.LBE1043:
 2223               	.LBE1042:
 2224               	.LBB1044:
 2225               	.LBB1036:
 2226               	.LBB1032:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 2227               		.loc 2 80 0
 2228 0324 5FB7      		in r21,__SREG__
 2229               	.LVL125:
 2230               	.LBB1007:
 2231               	.LBB1008:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 2232               		.loc 3 50 0
 2233               	/* #APP */
 2234               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 2235 0326 F894      		cli
 2236               	 ;  0 "" 2
 2237               	.LVL126:
 2238               	/* #NOAPP */
 2239               	.LBE1008:
 2240               	.LBE1007:
 2241               	.LBB1009:
 2242               	.LBB1010:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 2243               		.loc 4 220 0
 2244 0328 8091 0000 		lds r24,endpoints+24
 2245 032c 8670      		andi r24,lo8(6)
 2246               	.LBE1010:
 2247               	.LBE1009:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 2248               		.loc 2 82 0
 2249 032e 01F4      		brne .L151
 2250               	.LVL127:
 2251               	.L68:
 2252               	.LBB1011:
 2253               	.LBB1012:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 2254               		.loc 3 70 0
 2255 0330 5FBF      		out __SREG__,r21
 2256               		.loc 3 71 0
 2257               	.LVL128:
 2258               	.LBE1012:
 2259               	.LBE1011:
 2260               	.LBE1032:
 2261               	.LBE1036:
 2262               	.LBE1044:
 2263               	.LBB1045:
 2264               	.LBB1046:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 2265               		.loc 3 70 0
 2266 0332 1FBF      		out __SREG__,r17
 2267               		.loc 3 71 0
 2268 0334 00C0      		rjmp .L66
 2269               	.LVL129:
 2270               	.L151:
 2271               	.LBE1046:
 2272               	.LBE1045:
 2273               	.LBB1047:
 2274               	.LBB1037:
 2275               	.LBB1033:
 2276               	.LBB1013:
 2277               	.LBB1014:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 2278               		.loc 5 51 0
 2279 0336 2091 0000 		lds r18,ep_in_pipe_data+4
 2280               	.LBE1014:
 2281               	.LBE1013:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 2282               		.loc 2 83 0
 2283 033a 1216      		cp __zero_reg__,r18
 2284 033c 04F0      		brlt .+2
 2285 033e 00C0      		rjmp .L69
 2286               	.LBB1015:
 2287               	.LBB1016:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 2288               		.loc 5 62 0
 2289 0340 6091 0000 		lds r22,ep_in_pipe_data
 2290 0344 7091 0000 		lds r23,ep_in_pipe_data+1
 2291               	.LVL130:
 2292               	.LBE1016:
 2293               	.LBE1015:
 2294               	.LBB1017:
 2295               	.LBB1005:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 2296               		.loc 2 68 0
 2297 0348 3091 0000 		lds r19,ep_in_data
 2298               	.LVL131:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 2299               		.loc 2 69 0
 2300 034c 832F      		mov r24,r19
 2301 034e 90E0      		ldi r25,lo8(0)
 2302 0350 41E0      		ldi r20,lo8(1)
 2303 0352 8C15      		cp r24,r12
 2304 0354 9D05      		cpc r25,r13
 2305 0356 01F4      		brne .L70
 2306 0358 40E0      		ldi r20,lo8(0)
 2307               	.L70:
 2308 035a 4093 0000 		sts ep_in_data,r20
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 2309               		.loc 2 72 0
 2310 035e 3323      		tst r19
 2311 0360 01F4      		brne .L71
 2312               	.LVL132:
 2313               	.LBB1002:
 2314               	.LBB1003:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2315               		.loc 4 168 0
 2316 0362 6093 0000 		sts endpoints+28,r22
 2317 0366 7093 0000 		sts endpoints+28+1,r23
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2318               		.loc 4 169 0
 2319 036a 8092 0000 		sts endpoints+26,r8
 2320 036e 9092 0000 		sts endpoints+26+1,r9
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 2321               		.loc 4 174 0
 2322 0372 F301      		movw r30,r6
 2323               	/* #APP */
 2324               	 ;  174 "usb/usb.h" 1
 2325 0374 02E2      		ldi r16, 34
 2326 0376 0693      		.dc.w 0x9306
 2327               		
 2328               	 ;  0 "" 2
 2329               	.LVL133:
 2330               	/* #NOAPP */
 2331               	.L72:
 2332               	.LBE1003:
 2333               	.LBE1002:
 2334               	.LBE1005:
 2335               	.LBE1017:
 2336               	.LBB1018:
 2337               	.LBB1019:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 2338               		.loc 5 72 0
 2339 0378 2150      		subi r18,lo8(-(-1))
 2340 037a 2093 0000 		sts ep_in_pipe_data+4,r18
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 2341               		.loc 5 73 0
 2342 037e CB01      		movw r24,r22
 2343 0380 805C      		subi r24,lo8(-(64))
 2344 0382 9F4F      		sbci r25,hi8(-(64))
 2345 0384 8093 0000 		sts ep_in_pipe_data,r24
 2346 0388 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 2347               		.loc 5 75 0
 2348 038c F0E0      		ldi r31,hi8(ep_in_pipe_buffer+512)
 2349 038e 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 2350 0390 9F07      		cpc r25,r31
 2351 0392 01F4      		brne .L68
 2352               	.LBE1019:
 2353               	.LBE1018:
 2354               	.LBB1020:
 2355               	.LBB1021:
 2356               		.loc 5 91 0
 2357 0394 A092 0000 		sts ep_in_pipe_data,r10
 2358 0398 B092 0000 		sts ep_in_pipe_data+1,r11
 2359               	.LVL134:
 2360 039c 00C0      		rjmp .L68
 2361               	.LVL135:
 2362               	.L71:
 2363               	.LBE1021:
 2364               	.LBE1020:
 2365               	.LBB1023:
 2366               	.LBB1006:
 2367               	.LBB1004:
 2368               	.LBB1001:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2369               		.loc 4 168 0
 2370 039e 6093 0000 		sts endpoints+20,r22
 2371 03a2 7093 0000 		sts endpoints+20+1,r23
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2372               		.loc 4 169 0
 2373 03a6 8092 0000 		sts endpoints+18,r8
 2374 03aa 9092 0000 		sts endpoints+18+1,r9
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 2375               		.loc 4 176 0
 2376 03ae F301      		movw r30,r6
 2377               	/* #APP */
 2378               	 ;  176 "usb/usb.h" 1
 2379 03b0 04E1      		ldi r16, 20
 2380 03b2 0693      		.dc.w 0x9306
 2381               		
 2382               	 ;  0 "" 2
 2383               	/* #NOAPP */
 2384 03b4 00C0      		rjmp .L72
 2385               	.LVL136:
 2386               	.L69:
 2387               	.LBE1001:
 2388               	.LBE1004:
 2389               	.LBE1006:
 2390               	.LBE1023:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 2391               		.loc 2 87 0
 2392 03b6 8091 0000 		lds r24,ep_in_data+1
 2393 03ba 8130      		cpi r24,lo8(1)
 2394 03bc 01F4      		brne .+2
 2395 03be 00C0      		rjmp .L152
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 2396               		.loc 2 91 0
 2397 03c0 8230      		cpi r24,lo8(2)
 2398 03c2 01F0      		breq .+2
 2399 03c4 00C0      		rjmp .L68
 2400               	.LVL137:
 2401               	.LBB1024:
 2402               	.LBB1025:
 2403               	.LBB1026:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 2404               		.loc 4 228 0
 2405 03c6 8091 0000 		lds r24,endpoints+24
 2406 03ca 8670      		andi r24,lo8(6)
 2407               	.LBE1026:
 2408               	.LBE1025:
 2409               	.LBE1024:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 2410               		.loc 2 91 0
 2411 03cc 8630      		cpi r24,lo8(6)
 2412 03ce 01F0      		breq .+2
 2413 03d0 00C0      		rjmp .L68
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 2414               		.loc 2 92 0
 2415 03d2 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 2416               		.loc 2 93 0
 2417 03d6 1092 0000 		sts ep_in_data+2,__zero_reg__
 2418 03da 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 2419               	.LBB1027:
 2420               	.LBB1022:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 2421               		.loc 5 90 0
 2422 03de 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 2423               		.loc 5 91 0
 2424 03e2 A092 0000 		sts ep_in_pipe_data+2,r10
 2425 03e6 B092 0000 		sts ep_in_pipe_data+2+1,r11
 2426 03ea A092 0000 		sts ep_in_pipe_data,r10
 2427 03ee B092 0000 		sts ep_in_pipe_data+1,r11
 2428               	.LVL138:
 2429 03f2 00C0      		rjmp .L68
 2430               	.LVL139:
 2431               	.L148:
 2432               	.LBE1022:
 2433               	.LBE1027:
 2434               	.LBE1033:
 2435               	.LBE1037:
 2436               	.LBE1047:
 2437               	.LBE1050:
 2438               	.LBE1053:
 2439               	.LBE1056:
 2440               	.LBE1063:
 2441               	.LBE1068:
 2442               	.LBE1073:
 2443               	.LBE1342:
 2444               	.LBB1343:
 2445               	.LBB1249:
 2446               	.LBB1246:
 2447               	.LBB1183:
 2448               	.LBB1184:
 2449               	.LBB1185:
 2450               	.LBB1186:
 177:usb/usb_pipe.h **** 		ATOMIC_BLOCK(PIPE_ATOMIC){
 2451               		.loc 2 177 0
 2452 03f4 1FB7      		in r17,__SREG__
 2453               	.LVL140:
 2454               	.LBB1187:
 2455               	.LBB1188:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 2456               		.loc 3 50 0
 2457               	/* #APP */
 2458               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 2459 03f6 F894      		cli
 2460               	 ;  0 "" 2
 2461               	.LVL141:
 2462               	/* #NOAPP */
 2463               	.LBE1188:
 2464               	.LBE1187:
 2465               		.loc 2 178 0
 2466 03f8 1092 0000 		sts ep_in_data+2,__zero_reg__
 2467 03fc 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 2468               	.LVL142:
 2469               	.LBB1189:
 2470               	.LBB1190:
  81:usb/pipe.h    **** 	pipe->data->count += 1;
 2471               		.loc 5 81 0
 2472 0400 8091 0000 		lds r24,ep_in_pipe_data+4
 2473 0404 8F5F      		subi r24,lo8(-(1))
 2474 0406 8093 0000 		sts ep_in_pipe_data+4,r24
  82:usb/pipe.h    **** 	pipe->data->write_ptr += pipe->size;
 2475               		.loc 5 82 0
 2476 040a 8091 0000 		lds r24,ep_in_pipe_data+2
 2477 040e 9091 0000 		lds r25,ep_in_pipe_data+2+1
 2478 0412 805C      		subi r24,lo8(-(64))
 2479 0414 9F4F      		sbci r25,hi8(-(64))
 2480 0416 8093 0000 		sts ep_in_pipe_data+2,r24
 2481 041a 9093 0000 		sts ep_in_pipe_data+2+1,r25
  84:usb/pipe.h    **** 	if (pipe->data->write_ptr == &pipe->buffer[pipe->slots*pipe->size])
 2482               		.loc 5 84 0
 2483 041e F0E0      		ldi r31,hi8(ep_in_pipe_buffer+512)
 2484 0420 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 2485 0422 9F07      		cpc r25,r31
 2486 0424 01F4      		brne .L97
  85:usb/pipe.h    **** 		pipe->data->write_ptr = &pipe->buffer[0];
 2487               		.loc 5 85 0
 2488 0426 A092 0000 		sts ep_in_pipe_data+2,r10
 2489 042a B092 0000 		sts ep_in_pipe_data+2+1,r11
 2490               	.L97:
 2491               	.LVL143:
 2492               	.LBE1190:
 2493               	.LBE1189:
 2494               	.LBB1191:
 2495               	.LBB1192:
 2496               	.LBB1193:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 2497               		.loc 2 80 0
 2498 042e 7FB7      		in r23,__SREG__
 2499               	.LVL144:
 2500               	.LBB1194:
 2501               	.LBB1195:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 2502               		.loc 3 50 0
 2503               	/* #APP */
 2504               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 2505 0430 F894      		cli
 2506               	 ;  0 "" 2
 2507               	.LVL145:
 2508               	/* #NOAPP */
 2509               	.LBE1195:
 2510               	.LBE1194:
 2511               	.LBB1196:
 2512               	.LBB1197:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 2513               		.loc 4 220 0
 2514 0432 8091 0000 		lds r24,endpoints+24
 2515 0436 8670      		andi r24,lo8(6)
 2516               	.LBE1197:
 2517               	.LBE1196:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 2518               		.loc 2 82 0
 2519 0438 01F4      		brne .L153
 2520               	.LVL146:
 2521               	.L98:
 2522               	.LBB1198:
 2523               	.LBB1199:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 2524               		.loc 3 70 0
 2525 043a 7FBF      		out __SREG__,r23
 2526               		.loc 3 71 0
 2527               	.LVL147:
 2528               	.LBE1199:
 2529               	.LBE1198:
 2530               	.LBE1193:
 2531               	.LBE1192:
 2532               	.LBE1191:
 2533               	.LBB1237:
 2534               	.LBB1238:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 2535               		.loc 3 70 0
 2536 043c 1FBF      		out __SREG__,r17
 2537               		.loc 3 71 0
 2538 043e 00C0      		rjmp .L96
 2539               	.LVL148:
 2540               	.L153:
 2541               	.LBE1238:
 2542               	.LBE1237:
 2543               	.LBB1239:
 2544               	.LBB1235:
 2545               	.LBB1233:
 2546               	.LBB1200:
 2547               	.LBB1201:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 2548               		.loc 5 51 0
 2549 0440 4091 0000 		lds r20,ep_in_pipe_data+4
 2550               	.LBE1201:
 2551               	.LBE1200:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 2552               		.loc 2 83 0
 2553 0444 1416      		cp __zero_reg__,r20
 2554 0446 04F0      		brlt .+2
 2555 0448 00C0      		rjmp .L99
 2556               	.LBB1202:
 2557               	.LBB1203:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 2558               		.loc 5 62 0
 2559 044a 2091 0000 		lds r18,ep_in_pipe_data
 2560 044e 3091 0000 		lds r19,ep_in_pipe_data+1
 2561               	.LVL149:
 2562               	.LBE1203:
 2563               	.LBE1202:
 2564               	.LBB1204:
 2565               	.LBB1205:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 2566               		.loc 2 68 0
 2567 0452 5091 0000 		lds r21,ep_in_data
 2568               	.LVL150:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 2569               		.loc 2 69 0
 2570 0456 852F      		mov r24,r21
 2571 0458 90E0      		ldi r25,lo8(0)
 2572 045a 61E0      		ldi r22,lo8(1)
 2573 045c 8C15      		cp r24,r12
 2574 045e 9D05      		cpc r25,r13
 2575 0460 01F4      		brne .L100
 2576 0462 60E0      		ldi r22,lo8(0)
 2577               	.L100:
 2578 0464 6093 0000 		sts ep_in_data,r22
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 2579               		.loc 2 72 0
 2580 0468 5523      		tst r21
 2581 046a 01F4      		brne .L101
 2582               	.LVL151:
 2583               	.LBB1206:
 2584               	.LBB1207:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2585               		.loc 4 168 0
 2586 046c 2093 0000 		sts endpoints+28,r18
 2587 0470 3093 0000 		sts endpoints+28+1,r19
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2588               		.loc 4 169 0
 2589 0474 8092 0000 		sts endpoints+26,r8
 2590 0478 9092 0000 		sts endpoints+26+1,r9
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 2591               		.loc 4 174 0
 2592 047c F301      		movw r30,r6
 2593               	/* #APP */
 2594               	 ;  174 "usb/usb.h" 1
 2595 047e 02E2      		ldi r16, 34
 2596 0480 0693      		.dc.w 0x9306
 2597               		
 2598               	 ;  0 "" 2
 2599               	.LVL152:
 2600               	/* #NOAPP */
 2601               	.L102:
 2602               	.LBE1207:
 2603               	.LBE1206:
 2604               	.LBE1205:
 2605               	.LBE1204:
 2606               	.LBB1211:
 2607               	.LBB1212:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 2608               		.loc 5 72 0
 2609 0482 4150      		subi r20,lo8(-(-1))
 2610 0484 4093 0000 		sts ep_in_pipe_data+4,r20
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 2611               		.loc 5 73 0
 2612 0488 C901      		movw r24,r18
 2613 048a 805C      		subi r24,lo8(-(64))
 2614 048c 9F4F      		sbci r25,hi8(-(64))
 2615 048e 8093 0000 		sts ep_in_pipe_data,r24
 2616 0492 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 2617               		.loc 5 75 0
 2618 0496 F0E0      		ldi r31,hi8(ep_in_pipe_buffer+512)
 2619 0498 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 2620 049a 9F07      		cpc r25,r31
 2621 049c 01F4      		brne .L98
 2622               	.LBE1212:
 2623               	.LBE1211:
 2624               	.LBB1213:
 2625               	.LBB1214:
 2626               		.loc 5 91 0
 2627 049e A092 0000 		sts ep_in_pipe_data,r10
 2628 04a2 B092 0000 		sts ep_in_pipe_data+1,r11
 2629               	.LVL153:
 2630 04a6 00C0      		rjmp .L98
 2631               	.LVL154:
 2632               	.L101:
 2633               	.LBE1214:
 2634               	.LBE1213:
 2635               	.LBB1216:
 2636               	.LBB1210:
 2637               	.LBB1208:
 2638               	.LBB1209:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2639               		.loc 4 168 0
 2640 04a8 2093 0000 		sts endpoints+20,r18
 2641 04ac 3093 0000 		sts endpoints+20+1,r19
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2642               		.loc 4 169 0
 2643 04b0 8092 0000 		sts endpoints+18,r8
 2644 04b4 9092 0000 		sts endpoints+18+1,r9
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 2645               		.loc 4 176 0
 2646 04b8 F301      		movw r30,r6
 2647               	/* #APP */
 2648               	 ;  176 "usb/usb.h" 1
 2649 04ba 04E1      		ldi r16, 20
 2650 04bc 0693      		.dc.w 0x9306
 2651               		
 2652               	 ;  0 "" 2
 2653               	/* #NOAPP */
 2654 04be 00C0      		rjmp .L102
 2655               	.LVL155:
 2656               	.L99:
 2657               	.LBE1209:
 2658               	.LBE1208:
 2659               	.LBE1210:
 2660               	.LBE1216:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 2661               		.loc 2 87 0
 2662 04c0 8091 0000 		lds r24,ep_in_data+1
 2663 04c4 8130      		cpi r24,lo8(1)
 2664 04c6 01F0      		breq .L154
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 2665               		.loc 2 91 0
 2666 04c8 8230      		cpi r24,lo8(2)
 2667 04ca 01F0      		breq .+2
 2668 04cc 00C0      		rjmp .L98
 2669               	.LVL156:
 2670               	.LBB1217:
 2671               	.LBB1218:
 2672               	.LBB1219:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 2673               		.loc 4 228 0
 2674 04ce 8091 0000 		lds r24,endpoints+24
 2675 04d2 8670      		andi r24,lo8(6)
 2676               	.LBE1219:
 2677               	.LBE1218:
 2678               	.LBE1217:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 2679               		.loc 2 91 0
 2680 04d4 8630      		cpi r24,lo8(6)
 2681 04d6 01F0      		breq .+2
 2682 04d8 00C0      		rjmp .L98
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 2683               		.loc 2 92 0
 2684 04da 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 2685               		.loc 2 93 0
 2686 04de 1092 0000 		sts ep_in_data+2,__zero_reg__
 2687 04e2 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 2688               	.LBB1220:
 2689               	.LBB1215:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 2690               		.loc 5 90 0
 2691 04e6 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 2692               		.loc 5 91 0
 2693 04ea A092 0000 		sts ep_in_pipe_data+2,r10
 2694 04ee B092 0000 		sts ep_in_pipe_data+2+1,r11
 2695 04f2 A092 0000 		sts ep_in_pipe_data,r10
 2696 04f6 B092 0000 		sts ep_in_pipe_data+1,r11
 2697               	.LVL157:
 2698 04fa 00C0      		rjmp .L98
 2699               	.LVL158:
 2700               	.L154:
 2701               	.LBE1215:
 2702               	.LBE1220:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 2703               		.loc 2 88 0
 2704 04fc E092 0000 		sts ep_in_data+1,r14
 2705               	.LBB1221:
 2706               	.LBB1222:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 2707               		.loc 5 62 0
 2708 0500 6091 0000 		lds r22,ep_in_pipe_data
 2709 0504 E091 0000 		lds r30,ep_in_pipe_data+1
 2710               	.LBE1222:
 2711               	.LBE1221:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 2712               		.loc 2 90 0
 2713 0508 2091 0000 		lds r18,ep_in_data+2
 2714 050c 3091 0000 		lds r19,ep_in_data+2+1
 2715               	.LVL159:
 2716               	.LBB1223:
 2717               	.LBB1224:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 2718               		.loc 2 68 0
 2719 0510 5091 0000 		lds r21,ep_in_data
 2720               	.LVL160:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 2721               		.loc 2 69 0
 2722 0514 852F      		mov r24,r21
 2723 0516 90E0      		ldi r25,lo8(0)
 2724 0518 41E0      		ldi r20,lo8(1)
 2725 051a 8C15      		cp r24,r12
 2726 051c 9D05      		cpc r25,r13
 2727 051e 01F4      		brne .L105
 2728 0520 40E0      		ldi r20,lo8(0)
 2729               	.L105:
 2730 0522 4093 0000 		sts ep_in_data,r20
 2731               	.LBB1225:
 2732               	.LBB1226:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2733               		.loc 4 168 0
 2734 0526 862F      		mov r24,r22
 2735 0528 9E2F      		mov r25,r30
 2736               	.LBE1226:
 2737               	.LBE1225:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 2738               		.loc 2 72 0
 2739 052a 5523      		tst r21
 2740 052c 01F4      		brne .L106
 2741               	.LVL161:
 2742               	.LBB1228:
 2743               	.LBB1227:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2744               		.loc 4 168 0
 2745 052e 8093 0000 		sts endpoints+28,r24
 2746 0532 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2747               		.loc 4 169 0
 2748 0536 2093 0000 		sts endpoints+26,r18
 2749 053a 3093 0000 		sts endpoints+26+1,r19
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 2750               		.loc 4 174 0
 2751 053e F301      		movw r30,r6
 2752               	/* #APP */
 2753               	 ;  174 "usb/usb.h" 1
 2754 0540 02E2      		ldi r16, 34
 2755 0542 0693      		.dc.w 0x9306
 2756               		
 2757               	 ;  0 "" 2
 2758               	/* #NOAPP */
 2759 0544 00C0      		rjmp .L98
 2760               	.LVL162:
 2761               	.L152:
 2762               	.LBE1227:
 2763               	.LBE1228:
 2764               	.LBE1224:
 2765               	.LBE1223:
 2766               	.LBE1233:
 2767               	.LBE1235:
 2768               	.LBE1239:
 2769               	.LBE1186:
 2770               	.LBE1185:
 2771               	.LBE1184:
 2772               	.LBE1183:
 2773               	.LBE1246:
 2774               	.LBE1249:
 2775               	.LBE1343:
 2776               	.LBB1344:
 2777               	.LBB1074:
 2778               	.LBB1069:
 2779               	.LBB1064:
 2780               	.LBB1057:
 2781               	.LBB1054:
 2782               	.LBB1051:
 2783               	.LBB1048:
 2784               	.LBB1038:
 2785               	.LBB1034:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 2786               		.loc 2 88 0
 2787 0546 E092 0000 		sts ep_in_data+1,r14
 2788               	.LBB1028:
 2789               	.LBB1029:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 2790               		.loc 5 62 0
 2791 054a 7091 0000 		lds r23,ep_in_pipe_data
 2792 054e E091 0000 		lds r30,ep_in_pipe_data+1
 2793               	.LBE1029:
 2794               	.LBE1028:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 2795               		.loc 2 90 0
 2796 0552 2091 0000 		lds r18,ep_in_data+2
 2797 0556 3091 0000 		lds r19,ep_in_data+2+1
 2798               	.LVL163:
 2799               	.LBB1030:
 2800               	.LBB995:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 2801               		.loc 2 68 0
 2802 055a 6091 0000 		lds r22,ep_in_data
 2803               	.LVL164:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 2804               		.loc 2 69 0
 2805 055e 862F      		mov r24,r22
 2806 0560 90E0      		ldi r25,lo8(0)
 2807               	.LVL165:
 2808 0562 41E0      		ldi r20,lo8(1)
 2809 0564 8C15      		cp r24,r12
 2810 0566 9D05      		cpc r25,r13
 2811 0568 01F4      		brne .L75
 2812 056a 40E0      		ldi r20,lo8(0)
 2813               	.L75:
 2814 056c 4093 0000 		sts ep_in_data,r20
 2815               	.LBB989:
 2816               	.LBB990:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2817               		.loc 4 168 0
 2818 0570 872F      		mov r24,r23
 2819 0572 9E2F      		mov r25,r30
 2820               	.LBE990:
 2821               	.LBE989:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 2822               		.loc 2 72 0
 2823 0574 6623      		tst r22
 2824 0576 01F4      		brne .L76
 2825               	.LVL166:
 2826               	.LBB992:
 2827               	.LBB991:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2828               		.loc 4 168 0
 2829 0578 8093 0000 		sts endpoints+28,r24
 2830 057c 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2831               		.loc 4 169 0
 2832 0580 2093 0000 		sts endpoints+26,r18
 2833 0584 3093 0000 		sts endpoints+26+1,r19
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 2834               		.loc 4 174 0
 2835 0588 F301      		movw r30,r6
 2836               	/* #APP */
 2837               	 ;  174 "usb/usb.h" 1
 2838 058a 02E2      		ldi r16, 34
 2839 058c 0693      		.dc.w 0x9306
 2840               		
 2841               	 ;  0 "" 2
 2842               	/* #NOAPP */
 2843 058e 00C0      		rjmp .L68
 2844               	.LVL167:
 2845               	.L106:
 2846               	.LBE991:
 2847               	.LBE992:
 2848               	.LBE995:
 2849               	.LBE1030:
 2850               	.LBE1034:
 2851               	.LBE1038:
 2852               	.LBE1048:
 2853               	.LBE1051:
 2854               	.LBE1054:
 2855               	.LBE1057:
 2856               	.LBE1064:
 2857               	.LBE1069:
 2858               	.LBE1074:
 2859               	.LBE1344:
 2860               	.LBB1345:
 2861               	.LBB1250:
 2862               	.LBB1247:
 2863               	.LBB1244:
 2864               	.LBB1243:
 2865               	.LBB1242:
 2866               	.LBB1241:
 2867               	.LBB1240:
 2868               	.LBB1236:
 2869               	.LBB1234:
 2870               	.LBB1232:
 2871               	.LBB1231:
 2872               	.LBB1229:
 2873               	.LBB1230:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2874               		.loc 4 168 0
 2875 0590 8093 0000 		sts endpoints+20,r24
 2876 0594 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2877               		.loc 4 169 0
 2878 0598 2093 0000 		sts endpoints+18,r18
 2879 059c 3093 0000 		sts endpoints+18+1,r19
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 2880               		.loc 4 176 0
 2881 05a0 F301      		movw r30,r6
 2882               	/* #APP */
 2883               	 ;  176 "usb/usb.h" 1
 2884 05a2 04E1      		ldi r16, 20
 2885 05a4 0693      		.dc.w 0x9306
 2886               		
 2887               	 ;  0 "" 2
 2888               	/* #NOAPP */
 2889 05a6 00C0      		rjmp .L98
 2890               	.LVL168:
 2891               	.L76:
 2892               	.LBE1230:
 2893               	.LBE1229:
 2894               	.LBE1231:
 2895               	.LBE1232:
 2896               	.LBE1234:
 2897               	.LBE1236:
 2898               	.LBE1240:
 2899               	.LBE1241:
 2900               	.LBE1242:
 2901               	.LBE1243:
 2902               	.LBE1244:
 2903               	.LBE1247:
 2904               	.LBE1250:
 2905               	.LBE1345:
 2906               	.LBB1346:
 2907               	.LBB1075:
 2908               	.LBB1070:
 2909               	.LBB1065:
 2910               	.LBB1058:
 2911               	.LBB1055:
 2912               	.LBB1052:
 2913               	.LBB1049:
 2914               	.LBB1039:
 2915               	.LBB1035:
 2916               	.LBB1031:
 2917               	.LBB996:
 2918               	.LBB993:
 2919               	.LBB994:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 2920               		.loc 4 168 0
 2921 05a8 8093 0000 		sts endpoints+20,r24
 2922 05ac 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 2923               		.loc 4 169 0
 2924 05b0 2093 0000 		sts endpoints+18,r18
 2925 05b4 3093 0000 		sts endpoints+18+1,r19
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 2926               		.loc 4 176 0
 2927 05b8 F301      		movw r30,r6
 2928               	/* #APP */
 2929               	 ;  176 "usb/usb.h" 1
 2930 05ba 04E1      		ldi r16, 20
 2931 05bc 0693      		.dc.w 0x9306
 2932               		
 2933               	 ;  0 "" 2
 2934               	/* #NOAPP */
 2935 05be 00C0      		rjmp .L68
 2936               	.LVL169:
 2937               	.L146:
 2938               	.LBE994:
 2939               	.LBE993:
 2940               	.LBE996:
 2941               	.LBE1031:
 2942               	.LBE1035:
 2943               	.LBE1039:
 2944               	.LBE1049:
 2945               	.LBE1052:
 2946               	.LBE1055:
 2947               	.LBE1058:
 2948               	.LBE1065:
 2949               	.LBE1070:
 2950               	.LBE1075:
 2951               	.LBE1346:
 2952               	.LBB1347:
 2953               	.LBB1163:
 2954               	.LBB1095:
 2955               	.LBB1096:
 2956               	.LBB1097:
 2957               	.LBB1098:
 177:usb/usb_pipe.h **** 		ATOMIC_BLOCK(PIPE_ATOMIC){
 2958               		.loc 2 177 0
 2959 05c0 BFB7      		in r27,__SREG__
 2960               	.LVL170:
 2961               	.LBB1099:
 2962               	.LBB1100:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 2963               		.loc 3 50 0
 2964               	/* #APP */
 2965               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 2966 05c2 F894      		cli
 2967               	 ;  0 "" 2
 2968               	.LVL171:
 2969               	/* #NOAPP */
 2970               	.LBE1100:
 2971               	.LBE1099:
 2972               		.loc 2 178 0
 2973 05c4 1092 0000 		sts ep_in_data+2,__zero_reg__
 2974 05c8 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 2975               	.LVL172:
 2976               	.LBB1101:
 2977               	.LBB1102:
  81:usb/pipe.h    **** 	pipe->data->count += 1;
 2978               		.loc 5 81 0
 2979 05cc 8091 0000 		lds r24,ep_in_pipe_data+4
 2980 05d0 8F5F      		subi r24,lo8(-(1))
 2981 05d2 8093 0000 		sts ep_in_pipe_data+4,r24
  82:usb/pipe.h    **** 	pipe->data->write_ptr += pipe->size;
 2982               		.loc 5 82 0
 2983 05d6 8091 0000 		lds r24,ep_in_pipe_data+2
 2984 05da 9091 0000 		lds r25,ep_in_pipe_data+2+1
 2985 05de 805C      		subi r24,lo8(-(64))
 2986 05e0 9F4F      		sbci r25,hi8(-(64))
 2987 05e2 8093 0000 		sts ep_in_pipe_data+2,r24
 2988 05e6 9093 0000 		sts ep_in_pipe_data+2+1,r25
  84:usb/pipe.h    **** 	if (pipe->data->write_ptr == &pipe->buffer[pipe->slots*pipe->size])
 2989               		.loc 5 84 0
 2990 05ea 30E0      		ldi r19,hi8(ep_in_pipe_buffer+512)
 2991 05ec 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 2992 05ee 9307      		cpc r25,r19
 2993 05f0 01F4      		brne .L82
  85:usb/pipe.h    **** 		pipe->data->write_ptr = &pipe->buffer[0];
 2994               		.loc 5 85 0
 2995 05f2 A092 0000 		sts ep_in_pipe_data+2,r10
 2996 05f6 B092 0000 		sts ep_in_pipe_data+2+1,r11
 2997               	.L82:
 2998               	.LVL173:
 2999               	.LBE1102:
 3000               	.LBE1101:
 3001               	.LBB1103:
 3002               	.LBB1104:
 3003               	.LBB1105:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 3004               		.loc 2 80 0
 3005 05fa AFB7      		in r26,__SREG__
 3006               	.LVL174:
 3007               	.LBB1106:
 3008               	.LBB1107:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 3009               		.loc 3 50 0
 3010               	/* #APP */
 3011               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 3012 05fc F894      		cli
 3013               	 ;  0 "" 2
 3014               	.LVL175:
 3015               	/* #NOAPP */
 3016               	.LBE1107:
 3017               	.LBE1106:
 3018               	.LBB1108:
 3019               	.LBB1109:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 3020               		.loc 4 220 0
 3021 05fe 8091 0000 		lds r24,endpoints+24
 3022 0602 8670      		andi r24,lo8(6)
 3023               	.LBE1109:
 3024               	.LBE1108:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 3025               		.loc 2 82 0
 3026 0604 01F4      		brne .L155
 3027               	.LVL176:
 3028               	.L83:
 3029               	.LBB1110:
 3030               	.LBB1111:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 3031               		.loc 3 70 0
 3032 0606 AFBF      		out __SREG__,r26
 3033               		.loc 3 71 0
 3034               	.LVL177:
 3035               	.LBE1111:
 3036               	.LBE1110:
 3037               	.LBE1105:
 3038               	.LBE1104:
 3039               	.LBE1103:
 3040               	.LBB1149:
 3041               	.LBB1150:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 3042               		.loc 3 70 0
 3043 0608 BFBF      		out __SREG__,r27
 3044               		.loc 3 71 0
 3045 060a 00C0      		rjmp .L81
 3046               	.LVL178:
 3047               	.L155:
 3048               	.LBE1150:
 3049               	.LBE1149:
 3050               	.LBB1151:
 3051               	.LBB1146:
 3052               	.LBB1143:
 3053               	.LBB1112:
 3054               	.LBB1113:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 3055               		.loc 5 51 0
 3056 060c 4091 0000 		lds r20,ep_in_pipe_data+4
 3057               	.LBE1113:
 3058               	.LBE1112:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 3059               		.loc 2 83 0
 3060 0610 1416      		cp __zero_reg__,r20
 3061 0612 04F0      		brlt .+2
 3062 0614 00C0      		rjmp .L84
 3063               	.LBB1114:
 3064               	.LBB1115:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 3065               		.loc 5 62 0
 3066 0616 2091 0000 		lds r18,ep_in_pipe_data
 3067 061a 3091 0000 		lds r19,ep_in_pipe_data+1
 3068               	.LVL179:
 3069               	.LBE1115:
 3070               	.LBE1114:
 3071               	.LBB1116:
 3072               	.LBB1117:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 3073               		.loc 2 68 0
 3074 061e 5091 0000 		lds r21,ep_in_data
 3075               	.LVL180:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 3076               		.loc 2 69 0
 3077 0622 852F      		mov r24,r21
 3078 0624 90E0      		ldi r25,lo8(0)
 3079 0626 61E0      		ldi r22,lo8(1)
 3080 0628 8C15      		cp r24,r12
 3081 062a 9D05      		cpc r25,r13
 3082 062c 01F4      		brne .L85
 3083 062e 60E0      		ldi r22,lo8(0)
 3084               	.L85:
 3085 0630 6093 0000 		sts ep_in_data,r22
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 3086               		.loc 2 72 0
 3087 0634 5523      		tst r21
 3088 0636 01F4      		brne .L86
 3089               	.LVL181:
 3090               	.LBB1118:
 3091               	.LBB1119:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3092               		.loc 4 168 0
 3093 0638 2093 0000 		sts endpoints+28,r18
 3094 063c 3093 0000 		sts endpoints+28+1,r19
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3095               		.loc 4 169 0
 3096 0640 8092 0000 		sts endpoints+26,r8
 3097 0644 9092 0000 		sts endpoints+26+1,r9
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 3098               		.loc 4 174 0
 3099 0648 F301      		movw r30,r6
 3100               	/* #APP */
 3101               	 ;  174 "usb/usb.h" 1
 3102 064a 02E2      		ldi r16, 34
 3103 064c 0693      		.dc.w 0x9306
 3104               		
 3105               	 ;  0 "" 2
 3106               	.LVL182:
 3107               	/* #NOAPP */
 3108               	.L87:
 3109               	.LBE1119:
 3110               	.LBE1118:
 3111               	.LBE1117:
 3112               	.LBE1116:
 3113               	.LBB1123:
 3114               	.LBB1124:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 3115               		.loc 5 72 0
 3116 064e 4150      		subi r20,lo8(-(-1))
 3117 0650 4093 0000 		sts ep_in_pipe_data+4,r20
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 3118               		.loc 5 73 0
 3119 0654 C901      		movw r24,r18
 3120 0656 805C      		subi r24,lo8(-(64))
 3121 0658 9F4F      		sbci r25,hi8(-(64))
 3122 065a 8093 0000 		sts ep_in_pipe_data,r24
 3123 065e 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 3124               		.loc 5 75 0
 3125 0662 F0E0      		ldi r31,hi8(ep_in_pipe_buffer+512)
 3126 0664 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 3127 0666 9F07      		cpc r25,r31
 3128 0668 01F4      		brne .L83
 3129               	.LVL183:
 3130               	.L140:
 3131               	.LBE1124:
 3132               	.LBE1123:
 3133               	.LBB1125:
 3134               	.LBB1126:
 3135               		.loc 5 91 0
 3136 066a A092 0000 		sts ep_in_pipe_data,r10
 3137 066e B092 0000 		sts ep_in_pipe_data+1,r11
 3138               	.LVL184:
 3139 0672 00C0      		rjmp .L83
 3140               	.LVL185:
 3141               	.L86:
 3142               	.LBE1126:
 3143               	.LBE1125:
 3144               	.LBB1128:
 3145               	.LBB1122:
 3146               	.LBB1120:
 3147               	.LBB1121:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3148               		.loc 4 168 0
 3149 0674 2093 0000 		sts endpoints+20,r18
 3150 0678 3093 0000 		sts endpoints+20+1,r19
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3151               		.loc 4 169 0
 3152 067c 8092 0000 		sts endpoints+18,r8
 3153 0680 9092 0000 		sts endpoints+18+1,r9
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 3154               		.loc 4 176 0
 3155 0684 F301      		movw r30,r6
 3156               	/* #APP */
 3157               	 ;  176 "usb/usb.h" 1
 3158 0686 04E1      		ldi r16, 20
 3159 0688 0693      		.dc.w 0x9306
 3160               		
 3161               	 ;  0 "" 2
 3162               	/* #NOAPP */
 3163 068a 00C0      		rjmp .L87
 3164               	.LVL186:
 3165               	.L84:
 3166               	.LBE1121:
 3167               	.LBE1120:
 3168               	.LBE1122:
 3169               	.LBE1128:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 3170               		.loc 2 87 0
 3171 068c 8091 0000 		lds r24,ep_in_data+1
 3172 0690 8130      		cpi r24,lo8(1)
 3173 0692 01F4      		brne .+2
 3174 0694 00C0      		rjmp .L156
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 3175               		.loc 2 91 0
 3176 0696 8230      		cpi r24,lo8(2)
 3177 0698 01F0      		breq .+2
 3178 069a 00C0      		rjmp .L83
 3179               	.LVL187:
 3180               	.LBB1129:
 3181               	.LBB1130:
 3182               	.LBB1131:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 3183               		.loc 4 228 0
 3184 069c 8091 0000 		lds r24,endpoints+24
 3185 06a0 8670      		andi r24,lo8(6)
 3186               	.LBE1131:
 3187               	.LBE1130:
 3188               	.LBE1129:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 3189               		.loc 2 91 0
 3190 06a2 8630      		cpi r24,lo8(6)
 3191 06a4 01F0      		breq .+2
 3192 06a6 00C0      		rjmp .L83
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 3193               		.loc 2 92 0
 3194 06a8 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 3195               		.loc 2 93 0
 3196 06ac 1092 0000 		sts ep_in_data+2,__zero_reg__
 3197 06b0 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 3198               	.LBB1132:
 3199               	.LBB1127:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 3200               		.loc 5 90 0
 3201 06b4 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 3202               		.loc 5 91 0
 3203 06b8 A092 0000 		sts ep_in_pipe_data+2,r10
 3204 06bc B092 0000 		sts ep_in_pipe_data+2+1,r11
 3205 06c0 00C0      		rjmp .L140
 3206               	.LVL188:
 3207               	.L150:
 3208               	.LBE1127:
 3209               	.LBE1132:
 3210               	.LBE1143:
 3211               	.LBE1146:
 3212               	.LBE1151:
 3213               	.LBE1098:
 3214               	.LBE1097:
 3215               	.LBE1096:
 3216               	.LBE1095:
 3217               	.LBE1163:
 3218               	.LBE1347:
 3219               	.LBB1348:
 3220               	.LBB1335:
 3221               	.LBB1267:
 3222               	.LBB1268:
 3223               	.LBB1269:
 3224               	.LBB1270:
 177:usb/usb_pipe.h **** 		ATOMIC_BLOCK(PIPE_ATOMIC){
 3225               		.loc 2 177 0
 3226 06c2 7FB7      		in r23,__SREG__
 3227               	.LVL189:
 3228               	.LBB1271:
 3229               	.LBB1272:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 3230               		.loc 3 50 0
 3231               	/* #APP */
 3232               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 3233 06c4 F894      		cli
 3234               	 ;  0 "" 2
 3235               	.LVL190:
 3236               	/* #NOAPP */
 3237               	.LBE1272:
 3238               	.LBE1271:
 3239               		.loc 2 178 0
 3240 06c6 1092 0000 		sts ep_in_data+2,__zero_reg__
 3241 06ca 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 3242               	.LVL191:
 3243               	.LBB1273:
 3244               	.LBB1274:
  81:usb/pipe.h    **** 	pipe->data->count += 1;
 3245               		.loc 5 81 0
 3246 06ce 8091 0000 		lds r24,ep_in_pipe_data+4
 3247 06d2 8F5F      		subi r24,lo8(-(1))
 3248 06d4 8093 0000 		sts ep_in_pipe_data+4,r24
  82:usb/pipe.h    **** 	pipe->data->write_ptr += pipe->size;
 3249               		.loc 5 82 0
 3250 06d8 8091 0000 		lds r24,ep_in_pipe_data+2
 3251 06dc 9091 0000 		lds r25,ep_in_pipe_data+2+1
 3252 06e0 805C      		subi r24,lo8(-(64))
 3253 06e2 9F4F      		sbci r25,hi8(-(64))
 3254 06e4 8093 0000 		sts ep_in_pipe_data+2,r24
 3255 06e8 9093 0000 		sts ep_in_pipe_data+2+1,r25
  84:usb/pipe.h    **** 	if (pipe->data->write_ptr == &pipe->buffer[pipe->slots*pipe->size])
 3256               		.loc 5 84 0
 3257 06ec 30E0      		ldi r19,hi8(ep_in_pipe_buffer+512)
 3258 06ee 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 3259 06f0 9307      		cpc r25,r19
 3260 06f2 01F4      		brne .L112
  85:usb/pipe.h    **** 		pipe->data->write_ptr = &pipe->buffer[0];
 3261               		.loc 5 85 0
 3262 06f4 A092 0000 		sts ep_in_pipe_data+2,r10
 3263 06f8 B092 0000 		sts ep_in_pipe_data+2+1,r11
 3264               	.L112:
 3265               	.LVL192:
 3266               	.LBE1274:
 3267               	.LBE1273:
 3268               	.LBB1275:
 3269               	.LBB1276:
 3270               	.LBB1277:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 3271               		.loc 2 80 0
 3272 06fc 6FB7      		in r22,__SREG__
 3273               	.LVL193:
 3274               	.LBB1278:
 3275               	.LBB1279:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 3276               		.loc 3 50 0
 3277               	/* #APP */
 3278               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 3279 06fe F894      		cli
 3280               	 ;  0 "" 2
 3281               	.LVL194:
 3282               	/* #NOAPP */
 3283               	.LBE1279:
 3284               	.LBE1278:
 3285               	.LBB1280:
 3286               	.LBB1281:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 3287               		.loc 4 220 0
 3288 0700 8091 0000 		lds r24,endpoints+24
 3289 0704 8670      		andi r24,lo8(6)
 3290               	.LBE1281:
 3291               	.LBE1280:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 3292               		.loc 2 82 0
 3293 0706 01F4      		brne .L157
 3294               	.LVL195:
 3295               	.L113:
 3296               	.LBB1282:
 3297               	.LBB1283:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 3298               		.loc 3 70 0
 3299 0708 6FBF      		out __SREG__,r22
 3300               		.loc 3 71 0
 3301               	.LVL196:
 3302               	.LBE1283:
 3303               	.LBE1282:
 3304               	.LBE1277:
 3305               	.LBE1276:
 3306               	.LBE1275:
 3307               	.LBB1321:
 3308               	.LBB1322:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 3309               		.loc 3 70 0
 3310 070a 7FBF      		out __SREG__,r23
 3311               		.loc 3 71 0
 3312 070c 00C0      		rjmp .L111
 3313               	.LVL197:
 3314               	.L157:
 3315               	.LBE1322:
 3316               	.LBE1321:
 3317               	.LBB1323:
 3318               	.LBB1318:
 3319               	.LBB1315:
 3320               	.LBB1284:
 3321               	.LBB1285:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 3322               		.loc 5 51 0
 3323 070e 4091 0000 		lds r20,ep_in_pipe_data+4
 3324               	.LBE1285:
 3325               	.LBE1284:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 3326               		.loc 2 83 0
 3327 0712 1416      		cp __zero_reg__,r20
 3328 0714 04F0      		brlt .+2
 3329 0716 00C0      		rjmp .L114
 3330               	.LBB1286:
 3331               	.LBB1287:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 3332               		.loc 5 62 0
 3333 0718 2091 0000 		lds r18,ep_in_pipe_data
 3334 071c 3091 0000 		lds r19,ep_in_pipe_data+1
 3335               	.LVL198:
 3336               	.LBE1287:
 3337               	.LBE1286:
 3338               	.LBB1288:
 3339               	.LBB1289:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 3340               		.loc 2 68 0
 3341 0720 5091 0000 		lds r21,ep_in_data
 3342               	.LVL199:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 3343               		.loc 2 69 0
 3344 0724 852F      		mov r24,r21
 3345 0726 90E0      		ldi r25,lo8(0)
 3346 0728 E1E0      		ldi r30,lo8(1)
 3347 072a 8C15      		cp r24,r12
 3348 072c 9D05      		cpc r25,r13
 3349 072e 01F4      		brne .L115
 3350 0730 E0E0      		ldi r30,lo8(0)
 3351               	.L115:
 3352 0732 E093 0000 		sts ep_in_data,r30
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 3353               		.loc 2 72 0
 3354 0736 5523      		tst r21
 3355 0738 01F4      		brne .L116
 3356               	.LVL200:
 3357               	.LBB1290:
 3358               	.LBB1291:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3359               		.loc 4 168 0
 3360 073a 2093 0000 		sts endpoints+28,r18
 3361 073e 3093 0000 		sts endpoints+28+1,r19
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3362               		.loc 4 169 0
 3363 0742 8092 0000 		sts endpoints+26,r8
 3364 0746 9092 0000 		sts endpoints+26+1,r9
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 3365               		.loc 4 174 0
 3366 074a F301      		movw r30,r6
 3367               	/* #APP */
 3368               	 ;  174 "usb/usb.h" 1
 3369 074c 02E2      		ldi r16, 34
 3370 074e 0693      		.dc.w 0x9306
 3371               		
 3372               	 ;  0 "" 2
 3373               	.LVL201:
 3374               	/* #NOAPP */
 3375               	.L117:
 3376               	.LBE1291:
 3377               	.LBE1290:
 3378               	.LBE1289:
 3379               	.LBE1288:
 3380               	.LBB1295:
 3381               	.LBB1296:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 3382               		.loc 5 72 0
 3383 0750 4150      		subi r20,lo8(-(-1))
 3384 0752 4093 0000 		sts ep_in_pipe_data+4,r20
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 3385               		.loc 5 73 0
 3386 0756 C901      		movw r24,r18
 3387 0758 805C      		subi r24,lo8(-(64))
 3388 075a 9F4F      		sbci r25,hi8(-(64))
 3389 075c 8093 0000 		sts ep_in_pipe_data,r24
 3390 0760 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 3391               		.loc 5 75 0
 3392 0764 F0E0      		ldi r31,hi8(ep_in_pipe_buffer+512)
 3393 0766 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 3394 0768 9F07      		cpc r25,r31
 3395 076a 01F4      		brne .L113
 3396               	.LVL202:
 3397               	.L142:
 3398               	.LBE1296:
 3399               	.LBE1295:
 3400               	.LBB1297:
 3401               	.LBB1298:
 3402               		.loc 5 91 0
 3403 076c A092 0000 		sts ep_in_pipe_data,r10
 3404 0770 B092 0000 		sts ep_in_pipe_data+1,r11
 3405               	.LVL203:
 3406 0774 00C0      		rjmp .L113
 3407               	.LVL204:
 3408               	.L116:
 3409               	.LBE1298:
 3410               	.LBE1297:
 3411               	.LBB1300:
 3412               	.LBB1294:
 3413               	.LBB1292:
 3414               	.LBB1293:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3415               		.loc 4 168 0
 3416 0776 2093 0000 		sts endpoints+20,r18
 3417 077a 3093 0000 		sts endpoints+20+1,r19
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3418               		.loc 4 169 0
 3419 077e 8092 0000 		sts endpoints+18,r8
 3420 0782 9092 0000 		sts endpoints+18+1,r9
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 3421               		.loc 4 176 0
 3422 0786 F301      		movw r30,r6
 3423               	/* #APP */
 3424               	 ;  176 "usb/usb.h" 1
 3425 0788 04E1      		ldi r16, 20
 3426 078a 0693      		.dc.w 0x9306
 3427               		
 3428               	 ;  0 "" 2
 3429               	/* #NOAPP */
 3430 078c 00C0      		rjmp .L117
 3431               	.LVL205:
 3432               	.L114:
 3433               	.LBE1293:
 3434               	.LBE1292:
 3435               	.LBE1294:
 3436               	.LBE1300:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 3437               		.loc 2 87 0
 3438 078e 8091 0000 		lds r24,ep_in_data+1
 3439 0792 8130      		cpi r24,lo8(1)
 3440 0794 01F0      		breq .L158
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 3441               		.loc 2 91 0
 3442 0796 8230      		cpi r24,lo8(2)
 3443 0798 01F0      		breq .+2
 3444 079a 00C0      		rjmp .L113
 3445               	.LVL206:
 3446               	.LBB1301:
 3447               	.LBB1302:
 3448               	.LBB1303:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 3449               		.loc 4 228 0
 3450 079c 8091 0000 		lds r24,endpoints+24
 3451 07a0 8670      		andi r24,lo8(6)
 3452               	.LBE1303:
 3453               	.LBE1302:
 3454               	.LBE1301:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 3455               		.loc 2 91 0
 3456 07a2 8630      		cpi r24,lo8(6)
 3457 07a4 01F0      		breq .+2
 3458 07a6 00C0      		rjmp .L113
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 3459               		.loc 2 92 0
 3460 07a8 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 3461               		.loc 2 93 0
 3462 07ac 1092 0000 		sts ep_in_data+2,__zero_reg__
 3463 07b0 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 3464               	.LBB1304:
 3465               	.LBB1299:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 3466               		.loc 5 90 0
 3467 07b4 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 3468               		.loc 5 91 0
 3469 07b8 A092 0000 		sts ep_in_pipe_data+2,r10
 3470 07bc B092 0000 		sts ep_in_pipe_data+2+1,r11
 3471 07c0 00C0      		rjmp .L142
 3472               	.LVL207:
 3473               	.L156:
 3474               	.LBE1299:
 3475               	.LBE1304:
 3476               	.LBE1315:
 3477               	.LBE1318:
 3478               	.LBE1323:
 3479               	.LBE1270:
 3480               	.LBE1269:
 3481               	.LBE1268:
 3482               	.LBE1267:
 3483               	.LBE1335:
 3484               	.LBE1348:
 3485               	.LBB1349:
 3486               	.LBB1164:
 3487               	.LBB1160:
 3488               	.LBB1158:
 3489               	.LBB1156:
 3490               	.LBB1154:
 3491               	.LBB1152:
 3492               	.LBB1147:
 3493               	.LBB1144:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 3494               		.loc 2 88 0
 3495 07c2 E092 0000 		sts ep_in_data+1,r14
 3496               	.LBB1133:
 3497               	.LBB1134:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 3498               		.loc 5 62 0
 3499 07c6 4091 0000 		lds r20,ep_in_pipe_data
 3500 07ca 5091 0000 		lds r21,ep_in_pipe_data+1
 3501               	.LBE1134:
 3502               	.LBE1133:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 3503               		.loc 2 90 0
 3504 07ce 2091 0000 		lds r18,ep_in_data+2
 3505 07d2 3091 0000 		lds r19,ep_in_data+2+1
 3506               	.LVL208:
 3507               	.LBB1135:
 3508               	.LBB1136:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 3509               		.loc 2 68 0
 3510 07d6 6091 0000 		lds r22,ep_in_data
 3511               	.LVL209:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 3512               		.loc 2 69 0
 3513 07da 862F      		mov r24,r22
 3514 07dc 90E0      		ldi r25,lo8(0)
 3515 07de 71E0      		ldi r23,lo8(1)
 3516 07e0 8C15      		cp r24,r12
 3517 07e2 9D05      		cpc r25,r13
 3518 07e4 01F4      		brne .L90
 3519 07e6 70E0      		ldi r23,lo8(0)
 3520               	.L90:
 3521 07e8 7093 0000 		sts ep_in_data,r23
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 3522               		.loc 2 72 0
 3523 07ec 6623      		tst r22
 3524 07ee 01F4      		brne .L91
 3525               	.LVL210:
 3526               	.LBB1137:
 3527               	.LBB1138:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3528               		.loc 4 168 0
 3529 07f0 4093 0000 		sts endpoints+28,r20
 3530 07f4 5093 0000 		sts endpoints+28+1,r21
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3531               		.loc 4 169 0
 3532 07f8 2093 0000 		sts endpoints+26,r18
 3533 07fc 3093 0000 		sts endpoints+26+1,r19
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 3534               		.loc 4 174 0
 3535 0800 F301      		movw r30,r6
 3536               	/* #APP */
 3537               	 ;  174 "usb/usb.h" 1
 3538 0802 02E2      		ldi r16, 34
 3539 0804 0693      		.dc.w 0x9306
 3540               		
 3541               	 ;  0 "" 2
 3542               	/* #NOAPP */
 3543 0806 00C0      		rjmp .L83
 3544               	.LVL211:
 3545               	.L158:
 3546               	.LBE1138:
 3547               	.LBE1137:
 3548               	.LBE1136:
 3549               	.LBE1135:
 3550               	.LBE1144:
 3551               	.LBE1147:
 3552               	.LBE1152:
 3553               	.LBE1154:
 3554               	.LBE1156:
 3555               	.LBE1158:
 3556               	.LBE1160:
 3557               	.LBE1164:
 3558               	.LBE1349:
 3559               	.LBB1350:
 3560               	.LBB1336:
 3561               	.LBB1332:
 3562               	.LBB1330:
 3563               	.LBB1328:
 3564               	.LBB1326:
 3565               	.LBB1324:
 3566               	.LBB1319:
 3567               	.LBB1316:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 3568               		.loc 2 88 0
 3569 0808 E092 0000 		sts ep_in_data+1,r14
 3570               	.LBB1305:
 3571               	.LBB1306:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 3572               		.loc 5 62 0
 3573 080c 4091 0000 		lds r20,ep_in_pipe_data
 3574 0810 5091 0000 		lds r21,ep_in_pipe_data+1
 3575               	.LBE1306:
 3576               	.LBE1305:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 3577               		.loc 2 90 0
 3578 0814 2091 0000 		lds r18,ep_in_data+2
 3579 0818 3091 0000 		lds r19,ep_in_data+2+1
 3580               	.LVL212:
 3581               	.LBB1307:
 3582               	.LBB1308:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 3583               		.loc 2 68 0
 3584 081c E091 0000 		lds r30,ep_in_data
 3585               	.LVL213:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 3586               		.loc 2 69 0
 3587 0820 8E2F      		mov r24,r30
 3588 0822 90E0      		ldi r25,lo8(0)
 3589               	.LVL214:
 3590 0824 F1E0      		ldi r31,lo8(1)
 3591 0826 8C15      		cp r24,r12
 3592 0828 9D05      		cpc r25,r13
 3593 082a 01F4      		brne .L120
 3594 082c F0E0      		ldi r31,lo8(0)
 3595               	.L120:
 3596 082e F093 0000 		sts ep_in_data,r31
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 3597               		.loc 2 72 0
 3598 0832 EE23      		tst r30
 3599 0834 01F4      		brne .L121
 3600               	.LVL215:
 3601               	.LBB1309:
 3602               	.LBB1310:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3603               		.loc 4 168 0
 3604 0836 4093 0000 		sts endpoints+28,r20
 3605 083a 5093 0000 		sts endpoints+28+1,r21
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3606               		.loc 4 169 0
 3607 083e 2093 0000 		sts endpoints+26,r18
 3608 0842 3093 0000 		sts endpoints+26+1,r19
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 3609               		.loc 4 174 0
 3610 0846 F301      		movw r30,r6
 3611               	/* #APP */
 3612               	 ;  174 "usb/usb.h" 1
 3613 0848 02E2      		ldi r16, 34
 3614 084a 0693      		.dc.w 0x9306
 3615               		
 3616               	 ;  0 "" 2
 3617               	/* #NOAPP */
 3618 084c 00C0      		rjmp .L113
 3619               	.LVL216:
 3620               	.L91:
 3621               	.LBE1310:
 3622               	.LBE1309:
 3623               	.LBE1308:
 3624               	.LBE1307:
 3625               	.LBE1316:
 3626               	.LBE1319:
 3627               	.LBE1324:
 3628               	.LBE1326:
 3629               	.LBE1328:
 3630               	.LBE1330:
 3631               	.LBE1332:
 3632               	.LBE1336:
 3633               	.LBE1350:
 3634               	.LBB1351:
 3635               	.LBB1165:
 3636               	.LBB1161:
 3637               	.LBB1159:
 3638               	.LBB1157:
 3639               	.LBB1155:
 3640               	.LBB1153:
 3641               	.LBB1148:
 3642               	.LBB1145:
 3643               	.LBB1142:
 3644               	.LBB1141:
 3645               	.LBB1139:
 3646               	.LBB1140:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3647               		.loc 4 168 0
 3648 084e 4093 0000 		sts endpoints+20,r20
 3649 0852 5093 0000 		sts endpoints+20+1,r21
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3650               		.loc 4 169 0
 3651 0856 2093 0000 		sts endpoints+18,r18
 3652 085a 3093 0000 		sts endpoints+18+1,r19
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 3653               		.loc 4 176 0
 3654 085e F301      		movw r30,r6
 3655               	/* #APP */
 3656               	 ;  176 "usb/usb.h" 1
 3657 0860 04E1      		ldi r16, 20
 3658 0862 0693      		.dc.w 0x9306
 3659               		
 3660               	 ;  0 "" 2
 3661               	/* #NOAPP */
 3662 0864 00C0      		rjmp .L83
 3663               	.LVL217:
 3664               	.L121:
 3665               	.LBE1140:
 3666               	.LBE1139:
 3667               	.LBE1141:
 3668               	.LBE1142:
 3669               	.LBE1145:
 3670               	.LBE1148:
 3671               	.LBE1153:
 3672               	.LBE1155:
 3673               	.LBE1157:
 3674               	.LBE1159:
 3675               	.LBE1161:
 3676               	.LBE1165:
 3677               	.LBE1351:
 3678               	.LBB1352:
 3679               	.LBB1337:
 3680               	.LBB1333:
 3681               	.LBB1331:
 3682               	.LBB1329:
 3683               	.LBB1327:
 3684               	.LBB1325:
 3685               	.LBB1320:
 3686               	.LBB1317:
 3687               	.LBB1314:
 3688               	.LBB1313:
 3689               	.LBB1311:
 3690               	.LBB1312:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3691               		.loc 4 168 0
 3692 0866 4093 0000 		sts endpoints+20,r20
 3693 086a 5093 0000 		sts endpoints+20+1,r21
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3694               		.loc 4 169 0
 3695 086e 2093 0000 		sts endpoints+18,r18
 3696 0872 3093 0000 		sts endpoints+18+1,r19
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 3697               		.loc 4 176 0
 3698 0876 F301      		movw r30,r6
 3699               	/* #APP */
 3700               	 ;  176 "usb/usb.h" 1
 3701 0878 04E1      		ldi r16, 20
 3702 087a 0693      		.dc.w 0x9306
 3703               		
 3704               	 ;  0 "" 2
 3705               	/* #NOAPP */
 3706 087c 00C0      		rjmp .L113
 3707               	.LBE1312:
 3708               	.LBE1311:
 3709               	.LBE1313:
 3710               	.LBE1314:
 3711               	.LBE1317:
 3712               	.LBE1320:
 3713               	.LBE1325:
 3714               	.LBE1327:
 3715               	.LBE1329:
 3716               	.LBE1331:
 3717               	.LBE1333:
 3718               	.LBE1337:
 3719               	.LBE1352:
 3720               	.LBE1353:
 3721               	.LBE960:
 3722               	.LBE959:
 3723               		.cfi_endproc
 3724               	.LFE65:
 3726               		.text
 3727               	.global	EVENT_USB_Device_ControlRequest
 3729               	EVENT_USB_Device_ControlRequest:
 3730               	.LFB66:
 180:main.c        **** bool EVENT_USB_Device_ControlRequest(USB_Request_Header_t* req){
 3731               		.loc 6 180 0
 3732               		.cfi_startproc
 3733               	.LVL218:
 3734 0580 0F93      		push r16
 3735               	.LCFI46:
 3736               		.cfi_def_cfa_offset 3
 3737               		.cfi_offset 16, -2
 3738 0582 1F93      		push r17
 3739               	.LCFI47:
 3740               		.cfi_def_cfa_offset 4
 3741               		.cfi_offset 17, -3
 3742 0584 CF93      		push r28
 3743               	.LCFI48:
 3744               		.cfi_def_cfa_offset 5
 3745               		.cfi_offset 28, -4
 3746 0586 DF93      		push r29
 3747               	.LCFI49:
 3748               		.cfi_def_cfa_offset 6
 3749               		.cfi_offset 29, -5
 3750               	/* prologue: function */
 3751               	/* frame size = 0 */
 3752               	/* stack size = 4 */
 3753               	.L__stack_usage = 4
 3754 0588 9C01      		movw r18,r24
 3755               	.LVL219:
 240:main.c        **** 	return false;
 3756               		.loc 6 240 0
 3757 058a A0E0      		ldi r26,lo8(ep0_buf_in)
 3758 058c B0E0      		ldi r27,hi8(ep0_buf_in)
 180:main.c        **** bool EVENT_USB_Device_ControlRequest(USB_Request_Header_t* req){
 3759               		.loc 6 180 0
 3760 058e 8D01      		movw r16,r26
 3761 0590 80E0      		ldi r24,lo8(ep0_buf_in+64)
 3762 0592 90E0      		ldi r25,hi8(ep0_buf_in+64)
 3763               	.LVL220:
 3764 0594 FD01      		movw r30,r26
 3765               	.LVL221:
 3766               	.L160:
 3767               	.LBB1354:
 182:main.c        **** 	for (uint8_t i = 0; i < 64; i++) ep0_buf_in[i] = 0;
 3768               		.loc 6 182 0 discriminator 2
 3769 0596 1192      		st Z+,__zero_reg__
 3770 0598 40E0      		ldi r20,hi8(ep0_buf_in+64)
 3771 059a E030      		cpi r30,lo8(ep0_buf_in+64)
 3772 059c F407      		cpc r31,r20
 3773 059e 01F4      		brne .L160
 3774               	.LBE1354:
 183:main.c        **** 	usb_cmd = 0;
 3775               		.loc 6 183 0
 3776 05a0 1092 0000 		sts usb_cmd,__zero_reg__
 184:main.c        **** 	if ((req->bmRequestType & CONTROL_REQTYPE_TYPE) == REQTYPE_VENDOR){
 3777               		.loc 6 184 0
 3778 05a4 F901      		movw r30,r18
 3779 05a6 C081      		ld r28,Z
 3780 05a8 D0E0      		ldi r29,lo8(0)
 3781 05aa C076      		andi r28,lo8(96)
 3782 05ac D070      		andi r29,hi8(96)
 3783 05ae C034      		cpi r28,64
 3784 05b0 D105      		cpc r29,__zero_reg__
 3785 05b2 01F0      		breq .L184
 3786               	.L178:
 240:main.c        **** 	return false;
 3787               		.loc 6 240 0
 3788 05b4 80E0      		ldi r24,lo8(0)
 3789               	.LVL222:
 3790               	.L161:
 3791               	/* epilogue start */
 241:main.c        **** }
 3792               		.loc 6 241 0
 3793 05b6 DF91      		pop r29
 3794 05b8 CF91      		pop r28
 3795 05ba 1F91      		pop r17
 3796 05bc 0F91      		pop r16
 3797 05be 0895      		ret
 3798               	.LVL223:
 3799               	.L184:
 185:main.c        **** 		switch(req->bRequest){
 3800               		.loc 6 185 0
 3801 05c0 4181      		ldd r20,Z+1
 3802 05c2 4631      		cpi r20,lo8(22)
 3803 05c4 01F4      		brne .+2
 3804 05c6 00C0      		rjmp .L166
 3805 05c8 4731      		cpi r20,lo8(23)
 3806 05ca 00F0      		brlo .L185
 3807 05cc 4B3B      		cpi r20,lo8(-69)
 3808 05ce 01F4      		brne .+2
 3809 05d0 00C0      		rjmp .L168
 3810 05d2 4C3B      		cpi r20,lo8(-68)
 3811 05d4 00F0      		brlo .+2
 3812 05d6 00C0      		rjmp .L173
 3813 05d8 4731      		cpi r20,lo8(23)
 3814 05da 01F4      		brne .L178
 3815               	.LBB1355:
 216:main.c        **** 				addr = (uint16_t *) req->wIndex;
 3816               		.loc 6 216 0
 3817 05dc 0480      		ldd __tmp_reg__,Z+4
 3818 05de F581      		ldd r31,Z+5
 3819 05e0 E02D      		mov r30,__tmp_reg__
 3820               	.LVL224:
 217:main.c        **** 				ep0_buf_in[0] = *addr & 0xFF;
 3821               		.loc 6 217 0
 3822 05e2 8081      		ld r24,Z
 3823 05e4 8093 0000 		sts ep0_buf_in,r24
 218:main.c        **** 				ep0_buf_in[1] = *addr >> 8;
 3824               		.loc 6 218 0
 3825 05e8 8181      		ldd r24,Z+1
 3826 05ea 8093 0000 		sts ep0_buf_in+1,r24
 3827               	.LVL225:
 3828               	.LBB1356:
 3829               	.LBB1357:
 3830               	.LBB1358:
 3831               	.LBB1359:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3832               		.loc 4 168 0
 3833 05ee 0093 0000 		sts endpoints+12,r16
 3834 05f2 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3835               		.loc 4 169 0
 3836 05f6 82E0      		ldi r24,lo8(2)
 3837 05f8 90E0      		ldi r25,hi8(2)
 3838 05fa 8093 0000 		sts endpoints+10,r24
 3839 05fe 9093 0000 		sts endpoints+10+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 3840               		.loc 4 174 0
 3841 0602 E0E0      		ldi r30,lo8(endpoints+8)
 3842 0604 F0E0      		ldi r31,hi8(endpoints+8)
 3843               	/* #APP */
 3844               	 ;  174 "usb/usb.h" 1
 3845 0606 02E2      		ldi r16, 34
 3846 0608 0693      		.dc.w 0x9306
 3847               		
 3848               	 ;  0 "" 2
 3849               	/* #NOAPP */
 3850               	.LBE1359:
 3851               	.LBE1358:
 3852               	.LBE1357:
 3853               	.LBE1356:
 3854               	.LBE1355:
 220:main.c        **** 				return true;
 3855               		.loc 6 220 0
 3856 060a 81E0      		ldi r24,lo8(1)
 3857 060c 00C0      		rjmp .L161
 3858               	.LVL226:
 3859               	.L185:
 185:main.c        **** 		switch(req->bRequest){
 3860               		.loc 6 185 0
 3861 060e 4230      		cpi r20,lo8(2)
 3862 0610 01F4      		brne .+2
 3863 0612 00C0      		rjmp .L163
 3864 0614 4330      		cpi r20,lo8(3)
 3865 0616 00F4      		brsh .L172
 3866 0618 4423      		tst r20
 3867 061a 01F4      		brne .L178
 187:main.c        **** 				if (req->wIndex == 0){
 3868               		.loc 6 187 0
 3869 061c 8481      		ldd r24,Z+4
 3870 061e 9581      		ldd r25,Z+5
 3871 0620 0097      		sbiw r24,0
 3872 0622 01F4      		brne .+2
 3873 0624 00C0      		rjmp .L186
 189:main.c        **** 				}else if (req->wIndex == 1){
 3874               		.loc 6 189 0
 3875 0626 8130      		cpi r24,1
 3876 0628 9105      		cpc r25,__zero_reg__
 3877 062a 01F4      		brne .+2
 3878 062c 00C0      		rjmp .L187
 192:main.c        **** 				return true;
 3879               		.loc 6 192 0
 3880 062e 81E0      		ldi r24,lo8(1)
 3881 0630 00C0      		rjmp .L161
 3882               	.L172:
 185:main.c        **** 		switch(req->bRequest){
 3883               		.loc 6 185 0
 3884 0632 4830      		cpi r20,lo8(8)
 3885 0634 01F0      		breq .L164
 3886 0636 4930      		cpi r20,lo8(9)
 3887 0638 01F0      		breq .+2
 3888 063a 00C0      		rjmp .L178
 207:main.c        **** 				ep0_buf_in[0] = * ((uint8_t *) req->wIndex);
 3889               		.loc 6 207 0
 3890 063c 0480      		ldd __tmp_reg__,Z+4
 3891 063e F581      		ldd r31,Z+5
 3892 0640 E02D      		mov r30,__tmp_reg__
 3893 0642 8081      		ld r24,Z
 3894 0644 8093 0000 		sts ep0_buf_in,r24
 3895               	.LVL227:
 3896               	.LBB1360:
 3897               	.LBB1361:
 3898               	.LBB1362:
 3899               	.LBB1363:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3900               		.loc 4 168 0
 3901 0648 0093 0000 		sts endpoints+12,r16
 3902 064c 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3903               		.loc 4 169 0
 3904 0650 81E0      		ldi r24,lo8(1)
 3905 0652 90E0      		ldi r25,hi8(1)
 3906 0654 8093 0000 		sts endpoints+10,r24
 3907 0658 9093 0000 		sts endpoints+10+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 3908               		.loc 4 174 0
 3909 065c E0E0      		ldi r30,lo8(endpoints+8)
 3910 065e F0E0      		ldi r31,hi8(endpoints+8)
 3911               	.LVL228:
 3912               	/* #APP */
 3913               	 ;  174 "usb/usb.h" 1
 3914 0660 02E2      		ldi r16, 34
 3915 0662 0693      		.dc.w 0x9306
 3916               		
 3917               	 ;  0 "" 2
 3918               	/* #NOAPP */
 3919               	.LBE1363:
 3920               	.LBE1362:
 3921               	.LBE1361:
 3922               	.LBE1360:
 209:main.c        **** 				return true;
 3923               		.loc 6 209 0
 3924 0664 81E0      		ldi r24,lo8(1)
 3925 0666 00C0      		rjmp .L161
 3926               	.LVL229:
 3927               	.L173:
 185:main.c        **** 		switch(req->bRequest){
 3928               		.loc 6 185 0
 3929 0668 403E      		cpi r20,lo8(-32)
 3930 066a 01F0      		breq .L169
 3931 066c 413E      		cpi r20,lo8(-31)
 3932 066e 01F0      		breq .+2
 3933 0670 00C0      		rjmp .L178
 229:main.c        **** 				usb_cmd = req->bRequest;
 3934               		.loc 6 229 0
 3935 0672 4093 0000 		sts usb_cmd,r20
 230:main.c        **** 				cmd_data = req->wIndex;
 3936               		.loc 6 230 0
 3937 0676 8481      		ldd r24,Z+4
 3938 0678 8093 0000 		sts cmd_data,r24
 3939               	.LVL230:
 3940               	.L183:
 3941               	.LBB1364:
 3942               	.LBB1365:
 3943               	.LBB1366:
 3944               	.LBB1367:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3945               		.loc 4 168 0
 3946 067c 0093 0000 		sts endpoints+12,r16
 3947 0680 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3948               		.loc 4 169 0
 3949 0684 1092 0000 		sts endpoints+10,__zero_reg__
 3950 0688 1092 0000 		sts endpoints+10+1,__zero_reg__
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 3951               		.loc 4 174 0
 3952 068c E0E0      		ldi r30,lo8(endpoints+8)
 3953 068e F0E0      		ldi r31,hi8(endpoints+8)
 3954               	.LVL231:
 3955               	/* #APP */
 3956               	 ;  174 "usb/usb.h" 1
 3957 0690 02E2      		ldi r16, 34
 3958 0692 0693      		.dc.w 0x9306
 3959               		
 3960               	 ;  0 "" 2
 3961               	/* #NOAPP */
 3962               	.LBE1367:
 3963               	.LBE1366:
 3964               	.LBE1365:
 3965               	.LBE1364:
 213:main.c        **** 				return true;
 3966               		.loc 6 213 0
 3967 0694 81E0      		ldi r24,lo8(1)
 3968               	/* epilogue start */
 241:main.c        **** }
 3969               		.loc 6 241 0
 3970 0696 DF91      		pop r29
 3971 0698 CF91      		pop r28
 3972 069a 1F91      		pop r17
 3973 069c 0F91      		pop r16
 3974 069e 0895      		ret
 3975               	.LVL232:
 3976               	.L164:
 203:main.c        **** 				* ((uint8_t *) req->wIndex) = req->wValue;
 3977               		.loc 6 203 0
 3978 06a0 D901      		movw r26,r18
 3979 06a2 0480      		ldd __tmp_reg__,Z+4
 3980 06a4 F581      		ldd r31,Z+5
 3981 06a6 E02D      		mov r30,__tmp_reg__
 3982 06a8 1296      		adiw r26,2
 3983 06aa 8C91      		ld r24,X
 3984 06ac 1297      		sbiw r26,2
 3985 06ae 8083      		st Z,r24
 3986               	.LVL233:
 3987 06b0 00C0      		rjmp .L183
 3988               	.LVL234:
 3989               	.L169:
 223:main.c        **** 				eeprom_read_block(ep0_buf_in, (void*)(req->wIndex*64), 64);
 3990               		.loc 6 223 0
 3991 06b2 F901      		movw r30,r18
 3992 06b4 6481      		ldd r22,Z+4
 3993 06b6 7581      		ldd r23,Z+5
 3994 06b8 0024      		clr __tmp_reg__
 3995 06ba 7695      		lsr r23
 3996 06bc 6795      		ror r22
 3997 06be 0794      		ror __tmp_reg__
 3998 06c0 7695      		lsr r23
 3999 06c2 6795      		ror r22
 4000 06c4 0794      		ror __tmp_reg__
 4001 06c6 762F      		mov r23,r22
 4002 06c8 602D      		mov r22,__tmp_reg__
 4003 06ca 80E0      		ldi r24,lo8(ep0_buf_in)
 4004 06cc 90E0      		ldi r25,hi8(ep0_buf_in)
 4005 06ce 40E4      		ldi r20,lo8(64)
 4006 06d0 50E0      		ldi r21,hi8(64)
 4007 06d2 0E94 0000 		call __eerd_block_x32a4u
 4008               	.LVL235:
 4009               	.LBB1368:
 4010               	.LBB1369:
 4011               	.LBB1370:
 4012               	.LBB1371:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 4013               		.loc 4 168 0
 4014 06d6 0093 0000 		sts endpoints+12,r16
 4015 06da 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 4016               		.loc 4 169 0
 4017 06de C093 0000 		sts endpoints+10,r28
 4018 06e2 D093 0000 		sts endpoints+10+1,r29
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 4019               		.loc 4 174 0
 4020 06e6 E0E0      		ldi r30,lo8(endpoints+8)
 4021 06e8 F0E0      		ldi r31,hi8(endpoints+8)
 4022               	.LVL236:
 4023               	/* #APP */
 4024               	 ;  174 "usb/usb.h" 1
 4025 06ea 02E2      		ldi r16, 34
 4026 06ec 0693      		.dc.w 0x9306
 4027               		
 4028               	 ;  0 "" 2
 4029               	/* #NOAPP */
 4030               	.LBE1371:
 4031               	.LBE1370:
 4032               	.LBE1369:
 4033               	.LBE1368:
 225:main.c        **** 				return true;
 4034               		.loc 6 225 0
 4035 06ee 81E0      		ldi r24,lo8(1)
 4036 06f0 00C0      		rjmp .L161
 4037               	.LVL237:
 4038               	.L168:
 4039               	.LBB1372:
 4040               	.LBB1373:
 330:usb/usb.h     **** 		USB_ep0_enableOut();
 331:usb/usb.h     **** 	}
 332:usb/usb.h     **** }
 333:usb/usb.h     **** 
 334:usb/usb.h     **** static inline void USB_enter_bootloader(void){
 335:usb/usb.h     **** 	cli();
 4041               		.loc 4 335 0
 4042               	/* #APP */
 4043               	 ;  335 "usb/usb.h" 1
 4044 06f2 F894      		cli
 4045               	 ;  0 "" 2
 4046               	.LVL238:
 4047               	/* #NOAPP */
 4048               	.LBB1374:
 4049               	.LBB1375:
 4050               	.LBB1376:
 4051               	.LBB1377:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 4052               		.loc 4 168 0
 4053 06f4 0093 0000 		sts endpoints+12,r16
 4054 06f8 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 4055               		.loc 4 169 0
 4056 06fc 1092 0000 		sts endpoints+10,__zero_reg__
 4057 0700 1092 0000 		sts endpoints+10+1,__zero_reg__
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 4058               		.loc 4 174 0
 4059 0704 E0E0      		ldi r30,lo8(endpoints+8)
 4060 0706 F0E0      		ldi r31,hi8(endpoints+8)
 4061               	.LVL239:
 4062               	/* #APP */
 4063               	 ;  174 "usb/usb.h" 1
 4064 0708 02E2      		ldi r16, 34
 4065 070a 0693      		.dc.w 0x9306
 4066               		
 4067               	 ;  0 "" 2
 4068               	/* #NOAPP */
 4069               	.LBE1377:
 4070               	.LBE1376:
 4071               	.LBE1375:
 4072               	.LBE1374:
 4073               	.LBB1378:
 4074               	.LBB1379:
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 4075               		.loc 4 280 0
 4076 070c 3897      		sbiw r30,8
 4077               	.LVL240:
 4078               	/* #APP */
 4079               	 ;  280 "usb/usb.h" 1
 4080 070e 02E7      		ldi r16, 114
 4081 0710 0693      		.dc.w 0x9306
 4082               		
 4083               	 ;  0 "" 2
 4084               	.LVL241:
 4085               	/* #NOAPP */
 4086               	.L176:
 4087               	.LBE1379:
 4088               	.LBE1378:
 4089               	.LBB1380:
 4090               	.LBB1381:
 4091               	.LBB1382:
 4092               	.LBB1383:
 202:usb/usb.h     **** 		return e->STATUS & USB_EP_TRNCOMPL0_bm;
 4093               		.loc 4 202 0
 4094 0712 8091 0000 		lds r24,endpoints
 4095               	.LBE1383:
 4096               	.LBE1382:
 253:usb/usb.h     **** 	while (!USB_ep_done(ep)){};
 4097               		.loc 4 253 0
 4098 0716 85FF      		sbrs r24,5
 4099 0718 00C0      		rjmp .L176
 4100               	.LVL242:
 4101               	.LBE1381:
 4102               	.LBE1380:
 4103               	.LBB1384:
 4104               	.LBB1385:
 4105               		.file 7 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h"
   1:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
 103:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 104:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /**
 105:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 109:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 112:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 120:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 129:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 132:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 140:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** {
 144:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 156:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 159:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 164:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 4106               		.loc 7 164 0
 4107 071a 8FEF      		 ldi r24,lo8(63999)
 4108 071c 99EF      	    ldi r25,hi8(63999)
 4109 071e A0E0      	    ldi r26,hlo8(63999)
 4110 0720 8150      	    1:subi r24,1
 4111 0722 9040      	    sbci r25,0
 4112 0724 A040      	    sbci r26,0
 4113 0726 01F4      	    brne 1b
 4114 0728 00C0      		rjmp .
 4115 072a 0000      		nop
 4116               	.LBE1385:
 4117               	.LBE1384:
 4118               	.LBB1386:
 4119               	.LBB1387:
 296:usb/usb.h     **** 	USB.CTRLB &= ~USB_ATTACH_bm;
 4120               		.loc 4 296 0
 4121 072c 8091 C104 		lds r24,1217
 4122 0730 8E7F      		andi r24,lo8(-2)
 4123 0732 E0EC      		ldi r30,lo8(1216)
 4124 0734 F4E0      		ldi r31,hi8(1216)
 4125               	.LVL243:
 4126 0736 8183      		std Z+1,r24
 4127               	.LVL244:
 4128               	.LBE1387:
 4129               	.LBE1386:
 4130               	.LBB1388:
 4131               	.LBB1389:
 4132               		.loc 7 164 0
 4133 0738 8FEF      		 ldi r24,lo8(639999)
 4134 073a 93EC      	    ldi r25,hi8(639999)
 4135 073c A9E0      	    ldi r26,hlo8(639999)
 4136 073e 8150      	    1:subi r24,1
 4137 0740 9040      	    sbci r25,0
 4138 0742 A040      	    sbci r26,0
 4139 0744 01F4      	    brne 1b
 4140 0746 00C0      		rjmp .
 4141 0748 0000      		nop
 4142               	.LVL245:
 4143               	.LBE1389:
 4144               	.LBE1388:
 336:usb/usb.h     **** 	USB_ep0_send(0);
 337:usb/usb.h     **** 	USB_ep0_enableOut();
 338:usb/usb.h     **** 	USB_ep_wait(0x00); // Wait for the status stage to complete
 339:usb/usb.h     **** 	_delay_ms(10);
 340:usb/usb.h     **** 	USB_Detach();
 341:usb/usb.h     **** 	_delay_ms(100);
 342:usb/usb.h     **** 	void (*enter_bootloader)(void) = (void*) 0x47fc /*0x8ff8/2*/;
 343:usb/usb.h     **** 	enter_bootloader();
 4145               		.loc 4 343 0
 4146 074a ECEF      		ldi r30,lo8(18428)
 4147 074c F7E4      		ldi r31,hi8(18428)
 4148 074e 0995      		icall
 4149               	.LVL246:
 4150               	.LBE1373:
 4151               	.LBE1372:
 237:main.c        **** 				return true;
 4152               		.loc 6 237 0
 4153 0750 81E0      		ldi r24,lo8(1)
 4154 0752 00C0      		rjmp .L161
 4155               	.LVL247:
 4156               	.L163:
 4157               	.LBB1390:
 195:main.c        **** 					int l = strlen(message);
 4158               		.loc 6 195 0
 4159 0754 3091 0000 		lds r19,message
 4160 0758 2091 0000 		lds r18,message+1
 4161               	.LVL248:
 4162 075c C32F      		mov r28,r19
 4163 075e D22F      		mov r29,r18
 4164 0760 FE01      		movw r30,r28
 4165               	.LVL249:
 4166 0762 0190      		ld __tmp_reg__,Z+
 4167 0764 0020      		tst __tmp_reg__
 4168 0766 01F4      		brne .-6
 4169 0768 3197      		sbiw r30,1
 4170 076a E31B      		sub r30,r19
 4171               	.LVL250:
 4172               	.L175:
 4173               	.LBB1391:
 197:main.c        **** 						ep0_buf_in[i] = message[i];
 4174               		.loc 6 197 0 discriminator 2
 4175 076c 2991      		ld r18,Y+
 4176 076e 2D93      		st X+,r18
 196:main.c        **** 					for (uint8_t i=0; i<64; i++) {
 4177               		.loc 6 196 0 discriminator 2
 4178 0770 8A17      		cp r24,r26
 4179 0772 9B07      		cpc r25,r27
 4180 0774 01F4      		brne .L175
 4181               	.LVL251:
 4182               	.LBE1391:
 4183               	.LBB1392:
 4184               	.LBB1393:
 247:usb/usb.h     **** 	USB_ep_in_start(0x80, ep0_buf_in, size);
 4185               		.loc 4 247 0
 4186 0776 8E2F      		mov r24,r30
 4187 0778 90E0      		ldi r25,lo8(0)
 4188               	.LVL252:
 4189               	.LBB1394:
 4190               	.LBB1395:
 4191               	.LBB1396:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 4192               		.loc 4 168 0
 4193 077a 0093 0000 		sts endpoints+12,r16
 4194 077e 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 4195               		.loc 4 169 0
 4196 0782 8093 0000 		sts endpoints+10,r24
 4197 0786 9093 0000 		sts endpoints+10+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 4198               		.loc 4 174 0
 4199 078a E0E0      		ldi r30,lo8(endpoints+8)
 4200 078c F0E0      		ldi r31,hi8(endpoints+8)
 4201               	.LVL253:
 4202               	/* #APP */
 4203               	 ;  174 "usb/usb.h" 1
 4204 078e 02E2      		ldi r16, 34
 4205 0790 0693      		.dc.w 0x9306
 4206               		
 4207               	 ;  0 "" 2
 4208               	/* #NOAPP */
 4209               	.LBE1396:
 4210               	.LBE1395:
 4211               	.LBE1394:
 4212               	.LBE1393:
 4213               	.LBE1392:
 200:main.c        **** 					return true;
 4214               		.loc 6 200 0
 4215 0792 81E0      		ldi r24,lo8(1)
 4216               	.LVL254:
 4217 0794 00C0      		rjmp .L161
 4218               	.LVL255:
 4219               	.L166:
 4220               	.LBE1390:
 211:main.c        **** 				* ((uint16_t *) req->wIndex) = req->wValue;
 4221               		.loc 6 211 0
 4222 0796 F901      		movw r30,r18
 4223 0798 8281      		ldd r24,Z+2
 4224 079a 9381      		ldd r25,Z+3
 4225 079c 0480      		ldd __tmp_reg__,Z+4
 4226 079e F581      		ldd r31,Z+5
 4227 07a0 E02D      		mov r30,__tmp_reg__
 4228 07a2 8083      		st Z,r24
 4229 07a4 9183      		std Z+1,r25
 4230 07a6 00C0      		rjmp .L183
 4231               	.L187:
 190:main.c        **** 					USB_ep0_send_progmem((uint8_t*)fwversion, sizeof(fwversion));
 4232               		.loc 6 190 0
 4233 07a8 80E0      		ldi r24,lo8(fwversion)
 4234 07aa 90E0      		ldi r25,hi8(fwversion)
 4235 07ac 6BE0      		ldi r22,lo8(11)
 4236 07ae 70E0      		ldi r23,hi8(11)
 4237 07b0 0E94 0000 		call USB_ep0_send_progmem
 4238               	.LVL256:
 192:main.c        **** 				return true;
 4239               		.loc 6 192 0
 4240 07b4 81E0      		ldi r24,lo8(1)
 4241 07b6 00C0      		rjmp .L161
 4242               	.LVL257:
 4243               	.L186:
 188:main.c        **** 					USB_ep0_send_progmem((uint8_t*)hwversion, sizeof(hwversion));
 4244               		.loc 6 188 0
 4245 07b8 80E0      		ldi r24,lo8(hwversion)
 4246 07ba 90E0      		ldi r25,hi8(hwversion)
 4247 07bc 6BE0      		ldi r22,lo8(11)
 4248 07be 70E0      		ldi r23,hi8(11)
 4249 07c0 0E94 0000 		call USB_ep0_send_progmem
 4250               	.LVL258:
 192:main.c        **** 				return true;
 4251               		.loc 6 192 0
 4252 07c4 81E0      		ldi r24,lo8(1)
 4253 07c6 00C0      		rjmp .L161
 4254               		.cfi_endproc
 4255               	.LFE66:
 4257               	.global	EVENT_USB_Device_ControlOUT
 4259               	EVENT_USB_Device_ControlOUT:
 4260               	.LFB67:
 243:main.c        **** void EVENT_USB_Device_ControlOUT(uint8_t* buf, uint8_t count){
 4261               		.loc 6 243 0
 4262               		.cfi_startproc
 4263               	.LVL259:
 4264               	/* prologue: function */
 4265               	/* frame size = 0 */
 4266               	/* stack size = 0 */
 4267               	.L__stack_usage = 0
 4268 07c8 462F      		mov r20,r22
 244:main.c        **** 	switch (usb_cmd){
 4269               		.loc 6 244 0
 4270 07ca 2091 0000 		lds r18,usb_cmd
 4271 07ce 213E      		cpi r18,lo8(-31)
 4272 07d0 01F0      		breq .L191
 4273               	.LVL260:
 4274 07d2 0895      		ret
 4275               	.L191:
 4276               		.loc 6 246 0
 4277 07d4 2091 0000 		lds r18,cmd_data
 4278 07d8 30E0      		ldi r19,lo8(0)
 4279 07da 0024      		clr __tmp_reg__
 4280 07dc 3695      		lsr r19
 4281 07de 2795      		ror r18
 4282 07e0 0794      		ror __tmp_reg__
 4283 07e2 3695      		lsr r19
 4284 07e4 2795      		ror r18
 4285 07e6 0794      		ror __tmp_reg__
 4286 07e8 322F      		mov r19,r18
 4287 07ea 202D      		mov r18,__tmp_reg__
 4288 07ec B901      		movw r22,r18
 4289 07ee 50E0      		ldi r21,lo8(0)
 4290 07f0 0E94 0000 		call __eeupd_block_x32a4u
 4291               	.LVL261:
 4292 07f4 0895      		ret
 4293               		.cfi_endproc
 4294               	.LFE67:
 4296               	.global	cmd_data
 4297               	.global	cmd_data
 4298               		.section .bss
 4301               	cmd_data:
 4302 0000 00        		.skip 1,0
 4303               	.global	usb_cmd
 4304               	.global	usb_cmd
 4307               	usb_cmd:
 4308 0001 00        		.skip 1,0
 4309               	.global	fwversion
 4310               		.section	.progmem.data,"a",@progbits
 4313               	fwversion:
 4314 0000 4657 5F56 		.string	"FW_VERSION"
 4314      4552 5349 
 4314      4F4E 00
 4315               	.global	hwversion
 4318               	hwversion:
 4319 000b 4857 5F56 		.string	"HW_VERSION"
 4319      4552 5349 
 4319      4F4E 00
 4320               		.comm message,2,1
 4321               	.global	updating
 4322               	.global	updating
 4323               		.section .bss
 4326               	updating:
 4327 0002 00        		.skip 1,0
 4328               	.global	timeout_or_sampling_no_longer_enabled
 4329               	.global	timeout_or_sampling_no_longer_enabled
 4332               	timeout_or_sampling_no_longer_enabled:
 4333 0003 00        		.skip 1,0
 4334               	.global	ep_in_data
 4335               	.global	ep_in_data
 4338               	ep_in_data:
 4339 0004 0000 0000 		.skip 4,0
 4340               	.global	ep_in_pipe_data
 4341               		.data
 4344               	ep_in_pipe_data:
 4345 008b 0000      		.word	ep_in_pipe_buffer
 4346 008d 0000      		.word	ep_in_pipe_buffer
 4347 008f 00        		.byte	0
 4348               		.comm ep_in_pipe_buffer,512,1
 4349               		.text
 4350               	.Letext0:
 4351               		.file 8 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/stdint.h"
 4352               		.file 9 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/avr/iox32a4u.h"
 4353               		.file 10 "usb/StdRequestType.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccsvw1nw.s:2      *ABS*:000000000000003f __SREG__
     /tmp/ccsvw1nw.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/ccsvw1nw.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/ccsvw1nw.s:5      *ABS*:0000000000000034 __CCP__
     /tmp/ccsvw1nw.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccsvw1nw.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccsvw1nw.s:14     .text:0000000000000000 break_and_flush
     /tmp/ccsvw1nw.s:4338   .bss:0000000000000004 ep_in_data
     /tmp/ccsvw1nw.s:4332   .bss:0000000000000003 timeout_or_sampling_no_longer_enabled
     /tmp/ccsvw1nw.s:4344   .data:000000000000008b ep_in_pipe_data
                            *COM*:0000000000000200 ep_in_pipe_buffer
     /tmp/ccsvw1nw.s:492    .text:00000000000001be EVENT_USB_Device_ConfigurationChanged
     /tmp/ccsvw1nw.s:580    .text:000000000000020c __vector_125
     /tmp/ccsvw1nw.s:718    .text:0000000000000296 __vector_126
     /tmp/ccsvw1nw.s:4307   .bss:0000000000000001 usb_cmd
     /tmp/ccsvw1nw.s:4301   .bss:0000000000000000 cmd_data
     /tmp/ccsvw1nw.s:1254   .text:00000000000004a8 concat
     /tmp/ccsvw1nw.s:1352   .text:0000000000000514 parse_nmea_string
     /tmp/ccsvw1nw.s:1461   .text.startup:0000000000000000 main
     /tmp/ccsvw1nw.s:3729   .text:0000000000000580 EVENT_USB_Device_ControlRequest
                            *COM*:0000000000000002 message
     /tmp/ccsvw1nw.s:4313   .progmem.data:0000000000000000 fwversion
     /tmp/ccsvw1nw.s:4318   .progmem.data:000000000000000b hwversion
     /tmp/ccsvw1nw.s:4259   .text:00000000000007c8 EVENT_USB_Device_ControlOUT
     /tmp/ccsvw1nw.s:4326   .bss:0000000000000002 updating

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
endpoints
USB_Init
USB_HandleSetup
ep0_buf_out
__eeupd_block_x32a4u
malloc
strcpy
strcat
strtok
USB_ConfigureClock
ep0_buf_in
__eerd_block_x32a4u
USB_ep0_send_progmem
