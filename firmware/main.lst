   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	EVENT_USB_Device_ConfigurationChanged
  15               	EVENT_USB_Device_ConfigurationChanged:
  16               	.LFB57:
  17               		.file 1 "Framework.h"
   1:Framework.h   **** #pragma once
   2:Framework.h   **** #define F_CPU 32000000UL
   3:Framework.h   **** 
   4:Framework.h   **** // includes
   5:Framework.h   **** #include <avr/interrupt.h>
   6:Framework.h   **** #include <util/delay.h>
   7:Framework.h   **** #include "Descriptors.h"
   8:Framework.h   **** #include "usb/usb.h"
   9:Framework.h   **** #include "usb/usb_pipe.h"
  10:Framework.h   **** #include <avr/eeprom.h>
  11:Framework.h   **** #include <avr/io.h>
  12:Framework.h   **** 
  13:Framework.h   **** USB_PIPE(ep_in, 0x81 | USB_EP_PP, USB_EP_TYPE_BULK_gc, 64, 8, PIPE_ENABLE_FLUSH);
  14:Framework.h   **** 
  15:Framework.h   **** bool timeout_or_sampling_no_longer_enabled = 0;
  16:Framework.h   **** 
  17:Framework.h   **** // Queue a byte to be sent over the bulk EP. Blocks if the buffer is full
  18:Framework.h   **** static inline void send_byte(uint8_t byte){
  19:Framework.h   ****     // this should never actually block if your buffer is big enough
  20:Framework.h   ****     while (!usb_pipe_can_write(&ep_in));
  21:Framework.h   **** 	usb_pipe_write_byte(&ep_in, byte);
  22:Framework.h   **** }
  23:Framework.h   **** 
  24:Framework.h   **** // Sends a break to end the USB read and flushes the USB pipe
  25:Framework.h   **** static inline void break_and_flush(){
  26:Framework.h   ****     usb_pipe_flush(&ep_in);
  27:Framework.h   ****     USB.INTFLAGSBSET = USB_TRNIF_bm;
  28:Framework.h   ****     while (!usb_pipe_can_write(&ep_in)){
  29:Framework.h   ****         if (timeout_or_sampling_no_longer_enabled){
  30:Framework.h   ****             usb_pipe_reset(&ep_in);
  31:Framework.h   ****             return;
  32:Framework.h   ****         }
  33:Framework.h   ****     }
  34:Framework.h   **** } 
  35:Framework.h   **** 
  36:Framework.h   **** void EVENT_USB_Device_ConfigurationChanged(uint8_t config){
  18               		.loc 1 36 0
  19               		.cfi_startproc
  20               	.LVL0:
  21               	/* prologue: function */
  22               	/* frame size = 0 */
  23               	/* stack size = 0 */
  24               	.L__stack_usage = 0
  25               	.LBB411:
  26               	.LBB412:
  27               		.file 2 "usb/usb_pipe.h"
   1:usb/usb_pipe.h **** #include "pipe.h"
   2:usb/usb_pipe.h **** #include "usb.h"
   3:usb/usb_pipe.h **** 
   4:usb/usb_pipe.h **** #include <util/atomic.h>
   5:usb/usb_pipe.h **** #ifndef PIPE_ATOMIC
   6:usb/usb_pipe.h **** #define PIPE_ATOMIC ATOMIC_RESTORESTATE
   7:usb/usb_pipe.h **** #endif 
   8:usb/usb_pipe.h **** 
   9:usb/usb_pipe.h **** typedef struct USB_Pipe_data{
  10:usb/usb_pipe.h **** 	bool bank;
  11:usb/usb_pipe.h **** 	uint8_t flush;
  12:usb/usb_pipe.h **** 	uint16_t packet_offset; // Index into current packet for byte mode
  13:usb/usb_pipe.h **** } USB_Pipe_data;
  14:usb/usb_pipe.h **** 
  15:usb/usb_pipe.h **** // Immutable part, constant-folded at compile time
  16:usb/usb_pipe.h **** typedef struct USB_Pipe{
  17:usb/usb_pipe.h **** 	uint8_t ep;
  18:usb/usb_pipe.h **** 	uint8_t type;
  19:usb/usb_pipe.h **** 	USB_Pipe_data* data;
  20:usb/usb_pipe.h **** 	const Pipe* pipe;
  21:usb/usb_pipe.h **** 	uint8_t features;
  22:usb/usb_pipe.h **** } USB_Pipe;
  23:usb/usb_pipe.h **** 
  24:usb/usb_pipe.h **** #define PIPE_ENABLE_FLUSH (1<<0)
  25:usb/usb_pipe.h **** 
  26:usb/usb_pipe.h **** #define USB_PIPE(NAME, EPNO, TYPE, PACKET_SIZE, BUFFER_PACKETS, FEATURES) \
  27:usb/usb_pipe.h **** 	PIPE(NAME##_pipe, (BUFFER_PACKETS), (PACKET_SIZE),               \
  28:usb/usb_pipe.h **** 		((EPNO)&USB_EP_IN)?0:2,                      \
  29:usb/usb_pipe.h **** 		((EPNO)&USB_EP_IN)?2:0                       \
  30:usb/usb_pipe.h **** 	);                                               \
  31:usb/usb_pipe.h **** 	USB_Pipe_data NAME##_data = {      \
  32:usb/usb_pipe.h **** 		.bank = 0,                   \
  33:usb/usb_pipe.h **** 		.flush = 0,                    \
  34:usb/usb_pipe.h **** 	};                                 \
  35:usb/usb_pipe.h **** 	const static USB_Pipe NAME = {     \
  36:usb/usb_pipe.h **** 		.ep = (EPNO),                  \
  37:usb/usb_pipe.h **** 		.type = (TYPE),                \
  38:usb/usb_pipe.h **** 		.data = &(NAME##_data),        \
  39:usb/usb_pipe.h **** 		.pipe = &(NAME##_pipe),        \
  40:usb/usb_pipe.h **** 		.features = (FEATURES),        \
  41:usb/usb_pipe.h **** 	};                                 \
  42:usb/usb_pipe.h **** 
  43:usb/usb_pipe.h **** static inline void usb_pipe_init(const USB_Pipe* p){
  44:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
  28               		.loc 2 44 0
  29 0000 2FB7      		in r18,__SREG__
  30               	.LVL1:
  31               	.LBB413:
  32               	.LBB414:
  33               		.file 3 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h"
   1:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    All rights reserved.
   3:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
   4:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
   7:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  10:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      distribution.
  14:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  15:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      from this software without specific prior written permission.
  18:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  19:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** */
  31:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  32:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** /* $Id: atomic.h 2158 2010-06-10 15:48:28Z joerg_wunsch $ */
  33:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  34:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  37:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #include <avr/io.h>
  38:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #include <avr/interrupt.h>
  39:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  40:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #if !defined(__DOXYGEN__)
  41:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** /* Internal helper functions. */
  42:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  44:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     sei();
  45:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     return 1;
  46:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** }
  47:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  48:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
  49:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
  34               		.loc 3 50 0
  35               	/* #APP */
  36               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
  37 0002 F894      		cli
  38               	 ;  0 "" 2
  39               	.LVL2:
  40               	/* #NOAPP */
  41               	.LBE414:
  42               	.LBE413:
  43               	.LBB415:
  44               	.LBB416:
  45               		.file 4 "usb/pipe.h"
   1:usb/pipe.h    **** // Ring buffer that takes heavy advantage of constant folding
   2:usb/pipe.h    **** #pragma once
   3:usb/pipe.h    **** 
   4:usb/pipe.h    **** #include "Common.h"
   5:usb/pipe.h    **** 
   6:usb/pipe.h    **** // Mutable part, becomes an actual struct
   7:usb/pipe.h    **** typedef struct Pipe_data{
   8:usb/pipe.h    **** 	uint8_t* read_ptr;
   9:usb/pipe.h    **** 	uint8_t* write_ptr;
  10:usb/pipe.h    **** 	int8_t count; // available slots
  11:usb/pipe.h    **** } Pipe_data;
  12:usb/pipe.h    **** 
  13:usb/pipe.h    **** // Immutable part, constant-folded at compile time
  14:usb/pipe.h    **** typedef struct Pipe{
  15:usb/pipe.h    **** 	Pipe_data* data;
  16:usb/pipe.h    **** 	uint8_t* buffer;
  17:usb/pipe.h    **** 	uint8_t  slots;         // Number of slots in the buffer
  18:usb/pipe.h    **** 	uint8_t reserve_read;  // Slots to prevent reading so they are available to writer
  19:usb/pipe.h    **** 	uint8_t reserve_write; // Slots to prevent writing so they are available to reader
  20:usb/pipe.h    **** 	uint16_t size;          // Size of a buffer slot in bytes
  21:usb/pipe.h    **** } Pipe;
  22:usb/pipe.h    **** 
  23:usb/pipe.h    **** #define PIPE_H(NAME, SLOTS, SIZE, RESERVE_READ, RESERVE_WRITE)       \
  24:usb/pipe.h    **** 	extern Pipe_data NAME##_data;         \
  25:usb/pipe.h    **** 	extern uint8_t NAME##_buffer[(SLOTS)*(SIZE)]; \
  26:usb/pipe.h    **** 	const static Pipe NAME = {            \
  27:usb/pipe.h    **** 		.data = &(NAME##_data),           \
  28:usb/pipe.h    **** 		.buffer = &((NAME##_buffer)[0]),  \
  29:usb/pipe.h    **** 		.slots = (SLOTS),                 \
  30:usb/pipe.h    **** 		.size = (SIZE),                   \
  31:usb/pipe.h    **** 		.reserve_read = (RESERVE_READ),   \
  32:usb/pipe.h    **** 		.reserve_write = (RESERVE_WRITE), \
  33:usb/pipe.h    **** 	};
  34:usb/pipe.h    **** 
  35:usb/pipe.h    **** 
  36:usb/pipe.h    **** #define PIPE_C(NAME, SLOTS, SIZE)                   \
  37:usb/pipe.h    **** 	uint8_t NAME##_buffer[(SLOTS)*(SIZE)];           \
  38:usb/pipe.h    **** 	Pipe_data NAME##_data = {                \
  39:usb/pipe.h    **** 		.count = 0,                          \
  40:usb/pipe.h    **** 		.read_ptr = &((NAME##_buffer)[0]),                       \
  41:usb/pipe.h    **** 		.write_ptr = &((NAME##_buffer)[0]),                      \
  42:usb/pipe.h    **** 	};
  43:usb/pipe.h    **** 
  44:usb/pipe.h    **** #define PIPE(NAME, SLOTS, SIZE, RESERVE_READ, RESERVE_WRITE) \
  45:usb/pipe.h    **** 	PIPE_H(NAME, SLOTS, SIZE, RESERVE_READ, RESERVE_WRITE)   \
  46:usb/pipe.h    **** 	PIPE_C(NAME, SLOTS, SIZE)
  47:usb/pipe.h    **** 
  48:usb/pipe.h    **** // Number of slots available to read
  49:usb/pipe.h    **** static inline int8_t pipe_can_read(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  50:usb/pipe.h    **** static inline int8_t pipe_can_read(const Pipe* pipe){
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
  52:usb/pipe.h    **** }
  53:usb/pipe.h    **** 
  54:usb/pipe.h    **** // Number of slots available to write
  55:usb/pipe.h    **** static inline int8_t pipe_can_write(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  56:usb/pipe.h    **** static inline int8_t pipe_can_write(const Pipe* pipe){
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
  58:usb/pipe.h    **** }
  59:usb/pipe.h    **** 
  60:usb/pipe.h    **** static inline uint8_t* pipe_read_ptr(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  61:usb/pipe.h    **** static inline uint8_t* pipe_read_ptr(const Pipe* pipe){
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
  63:usb/pipe.h    **** }
  64:usb/pipe.h    **** 
  65:usb/pipe.h    **** static inline uint8_t* pipe_write_ptr(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  66:usb/pipe.h    **** static inline uint8_t* pipe_write_ptr(const Pipe* pipe){
  67:usb/pipe.h    **** 	return pipe->data->write_ptr;
  68:usb/pipe.h    **** }
  69:usb/pipe.h    **** 
  70:usb/pipe.h    **** static inline void pipe_done_read(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  71:usb/pipe.h    **** static inline void pipe_done_read(const Pipe* pipe){
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
  74:usb/pipe.h    **** 	// Assumes buffer_size % slot_size == 0 and all accesses aligned
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
  77:usb/pipe.h    **** }
  78:usb/pipe.h    **** 
  79:usb/pipe.h    **** static inline void pipe_done_write(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  80:usb/pipe.h    **** static inline void pipe_done_write(const Pipe* pipe){
  81:usb/pipe.h    **** 	pipe->data->count += 1;
  82:usb/pipe.h    **** 	pipe->data->write_ptr += pipe->size;
  83:usb/pipe.h    **** 	// Assumes buffer_size % slot_size == 0 and all accesses aligned
  84:usb/pipe.h    **** 	if (pipe->data->write_ptr == &pipe->buffer[pipe->slots*pipe->size])
  85:usb/pipe.h    **** 		pipe->data->write_ptr = &pipe->buffer[0];
  86:usb/pipe.h    **** }
  87:usb/pipe.h    **** 
  88:usb/pipe.h    **** static inline void pipe_reset(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  89:usb/pipe.h    **** static inline void pipe_reset(const Pipe* pipe){
  90:usb/pipe.h    **** 	pipe->data->count = 0;
  46               		.loc 4 90 0
  47 0004 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
  91:usb/pipe.h    **** 	pipe->data->read_ptr = pipe->data->write_ptr = pipe->buffer;
  48               		.loc 4 91 0
  49 0008 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
  50 000a 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
  51               	.LVL3:
  52 000c 8093 0000 		sts ep_in_pipe_data+2,r24
  53 0010 9093 0000 		sts ep_in_pipe_data+2+1,r25
  54 0014 8093 0000 		sts ep_in_pipe_data,r24
  55 0018 9093 0000 		sts ep_in_pipe_data+1,r25
  56               	.LVL4:
  57               	.LBE416:
  58               	.LBE415:
  59               	.LBB417:
  60               	.LBB418:
  61               	.LBB419:
  62               		.file 5 "usb/usb.h"
   1:usb/usb.h     **** // Minimal USB Stack for ATxmega32a4u and related
   2:usb/usb.h     **** // http://nonolithlabs.com
   3:usb/usb.h     **** // (C) 2011 Kevin Mehall (Nonolith Labs) <km@kevinmehall.net>
   4:usb/usb.h     **** //
   5:usb/usb.h     **** // Heavily borrows from LUFA
   6:usb/usb.h     **** // Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
   7:usb/usb.h     **** //
   8:usb/usb.h     **** // Licensed under the terms of the GNU GPLv3+
   9:usb/usb.h     **** 
  10:usb/usb.h     **** #pragma once
  11:usb/usb.h     **** 
  12:usb/usb.h     **** #include <avr/io.h>
  13:usb/usb.h     **** 
  14:usb/usb.h     **** #define CPU_TO_LE16(x) x
  15:usb/usb.h     **** 
  16:usb/usb.h     **** struct USB_Request_Header;
  17:usb/usb.h     **** typedef struct USB_Request_Header USB_Requst_Header_t;
  18:usb/usb.h     **** 
  19:usb/usb.h     **** #include "StdDescriptors.h"
  20:usb/usb.h     **** #include "StdRequestType.h"
  21:usb/usb.h     **** #include "Events.h"
  22:usb/usb.h     **** 
  23:usb/usb.h     **** #ifndef USB_MAXEP
  24:usb/usb.h     **** 	#define USB_MAXEP 1
  25:usb/usb.h     **** #endif
  26:usb/usb.h     **** 
  27:usb/usb.h     **** #ifndef USB_EP0SIZE
  28:usb/usb.h     **** 	#define EP0SIZE 64
  29:usb/usb.h     **** #endif
  30:usb/usb.h     **** 
  31:usb/usb.h     **** typedef union USB_EP_pair{
  32:usb/usb.h     **** 	union{
  33:usb/usb.h     **** 		struct{
  34:usb/usb.h     **** 			USB_EP_t out;
  35:usb/usb.h     **** 			USB_EP_t in;
  36:usb/usb.h     **** 		};
  37:usb/usb.h     **** 		USB_EP_t ep[2];
  38:usb/usb.h     **** 	};
  39:usb/usb.h     **** } ATTR_PACKED USB_EP_pair_t;
  40:usb/usb.h     **** 
  41:usb/usb.h     **** extern uint8_t ep0_buf_in[USB_EP0SIZE];
  42:usb/usb.h     **** extern uint8_t ep0_buf_out[USB_EP0SIZE];
  43:usb/usb.h     **** extern USB_EP_pair_t endpoints[USB_MAXEP+1];
  44:usb/usb.h     **** 
  45:usb/usb.h     **** /** String descriptor index for the device's unique serial number string descriptor within the devi
  46:usb/usb.h     ****  *  This unique serial number is used by the host to associate resources to the device (such as dri
  47:usb/usb.h     ****  *  number allocations) to a device regardless of the port it is plugged in to on the host. Some mi
  48:usb/usb.h     ****  *  a unique serial number internally, and setting the device descriptors serial number string inde
  49:usb/usb.h     ****  *  will cause it to use the internal serial number.
  50:usb/usb.h     ****  *
  51:usb/usb.h     ****  *  On unsupported devices, this will evaluate to \ref NO_DESCRIPTOR and so will force the host to 
  52:usb/usb.h     ****  *  number for the device.
  53:usb/usb.h     ****  */
  54:usb/usb.h     **** #define USE_INTERNAL_SERIAL            0xDC
  55:usb/usb.h     **** 
  56:usb/usb.h     **** /** Length of the device's unique internal serial number, in bits, if present on the selected micro
  57:usb/usb.h     ****  *  model.
  58:usb/usb.h     ****  */
  59:usb/usb.h     **** #define INTERNAL_SERIAL_LENGTH_BITS    (8 * (1 + (offsetof(NVM_PROD_SIGNATURES_t, COORDY1) - offset
  60:usb/usb.h     **** 
  61:usb/usb.h     **** /** Start address of the internal serial number, in the appropriate address space, if present on th
  62:usb/usb.h     ****  *  model.
  63:usb/usb.h     ****  */
  64:usb/usb.h     **** #define INTERNAL_SERIAL_START_ADDRESS  offsetof(NVM_PROD_SIGNATURES_t, LOTNUM0)
  65:usb/usb.h     **** 
  66:usb/usb.h     **** /* Enums: */
  67:usb/usb.h     **** 	/** Enum for the various states of the USB Device state machine. Only some states are
  68:usb/usb.h     **** 	 *  implemented in the LUFA library - other states are left to the user to implement.
  69:usb/usb.h     **** 	 *
  70:usb/usb.h     **** 	 *  For information on each possible USB device state, refer to the USB 2.0 specification.
  71:usb/usb.h     **** 	 *
  72:usb/usb.h     **** 	 *  \see \ref USB_DeviceState, which stores the current device state machine state.
  73:usb/usb.h     **** 	 */
  74:usb/usb.h     **** 	enum USB_Device_States_t
  75:usb/usb.h     **** 	{
  76:usb/usb.h     **** 		DEVICE_STATE_Unattached                   = 0, /**< Internally implemented by the library. This s
  77:usb/usb.h     **** 		                                                *   that the device is not currently connected to
  78:usb/usb.h     **** 		                                                */
  79:usb/usb.h     **** 		DEVICE_STATE_Powered                      = 1, /**< Internally implemented by the library. This s
  80:usb/usb.h     **** 		                                                *   that the device is connected to a host, but e
  81:usb/usb.h     **** 		                                                *   yet begun.
  82:usb/usb.h     **** 		                                                */
  83:usb/usb.h     **** 		DEVICE_STATE_Default                      = 2, /**< Internally implemented by the library. This s
  84:usb/usb.h     **** 		                                                *   that the device's USB bus has been reset by t
  85:usb/usb.h     **** 		                                                *   now waiting for the host to begin the enumera
  86:usb/usb.h     **** 		                                                */
  87:usb/usb.h     **** 		DEVICE_STATE_Addressed                    = 3, /**< Internally implemented by the library. This s
  88:usb/usb.h     **** 		                                                *   that the device has been addressed by the USB
  89:usb/usb.h     **** 		                                                *   yet configured.
  90:usb/usb.h     **** 		                                                */
  91:usb/usb.h     **** 		DEVICE_STATE_Configured                   = 4, /**< May be implemented by the user project. This 
  92:usb/usb.h     **** 		                                                *   that the device has been enumerated by the ho
  93:usb/usb.h     **** 		                                                *   for USB communications to begin.
  94:usb/usb.h     **** 		                                                */
  95:usb/usb.h     **** 		DEVICE_STATE_Suspended                    = 5, /**< May be implemented by the user project. This 
  96:usb/usb.h     **** 		                                                *   that the USB bus has been suspended by the ho
  97:usb/usb.h     **** 		                                                *   should power down to a minimal power level un
  98:usb/usb.h     **** 		                                                *   resumed.
  99:usb/usb.h     **** 		                                                */
 100:usb/usb.h     **** 	};
 101:usb/usb.h     **** 
 102:usb/usb.h     **** #define USB_EP_size_to_gc(x)  ((x <= 8   )?USB_EP_BUFSIZE_8_gc:\
 103:usb/usb.h     ****                                (x <= 16  )?USB_EP_BUFSIZE_16_gc:\
 104:usb/usb.h     ****                                (x <= 32  )?USB_EP_BUFSIZE_32_gc:\
 105:usb/usb.h     ****                                (x <= 64  )?USB_EP_BUFSIZE_64_gc:\
 106:usb/usb.h     ****                                (x <= 128 )?USB_EP_BUFSIZE_128_gc:\
 107:usb/usb.h     ****                                (x <= 256 )?USB_EP_BUFSIZE_256_gc:\
 108:usb/usb.h     ****                                (x <= 512 )?USB_EP_BUFSIZE_512_gc:\
 109:usb/usb.h     ****                                            USB_EP_BUFSIZE_1023_gc)
 110:usb/usb.h     **** 
 111:usb/usb.h     **** #define USB_EP_IN 0x80
 112:usb/usb.h     **** 
 113:usb/usb.h     **** // Flag in the endpoint address to indicate that the endpoint should use
 114:usb/usb.h     **** // PingPong (double buffer) mode. This is not actually part of the endpoint
 115:usb/usb.h     **** // address as seen by the host. If PP is enabled, this flag needs to be part
 116:usb/usb.h     **** // of the address passed to all USB_EP_* functions.
 117:usb/usb.h     **** #define USB_EP_PP 0x40
 118:usb/usb.h     **** 	
 119:usb/usb.h     **** extern volatile uint8_t USB_DeviceState;
 120:usb/usb.h     **** extern volatile uint8_t USB_Device_ConfigurationNumber;
 121:usb/usb.h     **** 
 122:usb/usb.h     **** /** Configure the XMEGA's clock for use with USB.  */
 123:usb/usb.h     **** void USB_ConfigureClock(void);
 124:usb/usb.h     **** 
 125:usb/usb.h     **** /** Initialize USB functionality */
 126:usb/usb.h     **** void USB_Init(void);
 127:usb/usb.h     **** void USB_ResetInterface(void);
 128:usb/usb.h     **** 
 129:usb/usb.h     **** #define _USB_EP(epaddr) \
 130:usb/usb.h     **** 	USB_EP_pair_t* pair = &endpoints[(epaddr & 0x3F)]; \
 131:usb/usb.h     **** 	USB_EP_t* e __attribute__ ((unused)) = &pair->ep[!!(epaddr&0x80)]; \
 132:usb/usb.h     **** 	
 133:usb/usb.h     **** #define _USB_EP_OTHER(epaddr) \
 134:usb/usb.h     **** 	USB_EP_t* other = &pair->ep[!(epaddr&0x80)]
 135:usb/usb.h     **** 	
 136:usb/usb.h     **** #define _USB_EP_BANK(epaddr, bank) \
 137:usb/usb.h     **** 	USB_EP_t* b = &pair->ep[!!(epaddr&0x80) != bank]
 138:usb/usb.h     **** 
 139:usb/usb.h     **** inline void USB_ep_init(uint8_t ep, uint8_t type, uint16_t bufsize) ATTR_ALWAYS_INLINE;
 140:usb/usb.h     **** inline void USB_ep_init(uint8_t ep, uint8_t type, uint16_t bufsize){
 141:usb/usb.h     **** 	_USB_EP(ep);
 142:usb/usb.h     **** 	if (ep & USB_EP_PP){
 143:usb/usb.h     **** 		_USB_EP_OTHER(ep);
 144:usb/usb.h     **** 		e->STATUS = USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm;
  63               		.loc 5 144 0
  64 001c 80E0      		ldi r24,lo8(endpoints+24)
  65 001e 90E0      		ldi r25,hi8(endpoints+24)
  66 0020 36E0      		ldi r19,lo8(6)
  67 0022 3093 0000 		sts endpoints+24,r19
 145:usb/usb.h     **** 		e->CTRL = type | USB_EP_size_to_gc(bufsize) | USB_EP_PINGPONG_bm;
  68               		.loc 5 145 0
  69 0026 33E9      		ldi r19,lo8(-109)
  70 0028 3093 0000 		sts endpoints+25,r19
 146:usb/usb.h     **** 		other->CTRL = 0;
  71               		.loc 5 146 0
  72 002c FC01      		movw r30,r24
  73 002e 3797      		sbiw r30,7
  74 0030 1082      		st Z,__zero_reg__
 147:usb/usb.h     **** 		other->STATUS = USB_EP_BUSNACK0_bm;
  75               		.loc 5 147 0
  76 0032 0897      		sbiw r24,8
  77 0034 32E0      		ldi r19,lo8(2)
  78 0036 FC01      		movw r30,r24
  79 0038 3083      		st Z,r19
  80               	.LBE419:
  81               	.LBE418:
  82               	.LBE417:
  45:usb/usb_pipe.h **** 		pipe_reset(p->pipe);
  46:usb/usb_pipe.h **** 		USB_ep_init(p->ep, p->type, p->pipe->size);
  47:usb/usb_pipe.h **** 		p->data->bank = 0;
  83               		.loc 2 47 0
  84 003a 1092 0000 		sts ep_in_data,__zero_reg__
  48:usb/usb_pipe.h **** 		p->data->flush = 0;
  85               		.loc 2 48 0
  86 003e 1092 0000 		sts ep_in_data+1,__zero_reg__
  49:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
  87               		.loc 2 49 0
  88 0042 1092 0000 		sts ep_in_data+2,__zero_reg__
  89 0046 1092 0000 		sts ep_in_data+2+1,__zero_reg__
  90               	.LVL5:
  91               	.LBB420:
  92               	.LBB421:
  51:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     return 1;
  52:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** }
  53:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  54:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
  55:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  56:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     sei();
  57:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  58:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     (void)__s;
  59:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** }
  60:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  61:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ void __iCliParam(const uint8_t *__s)
  62:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  63:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
  64:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  65:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     (void)__s;
  66:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** }
  67:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  68:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ void __iRestore(const  uint8_t *__s)
  69:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
  93               		.loc 3 70 0
  94 004a 2FBF      		out __SREG__,r18
  71:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  95               		.loc 3 71 0
  96               	/* epilogue start */
  97               	.LBE421:
  98               	.LBE420:
  99               	.LBE412:
 100               	.LBE411:
  37:Framework.h   **** 	usb_pipe_init(&ep_in);
  38:Framework.h   **** }
 101               		.loc 1 38 0
 102 004c 0895      		ret
 103               		.cfi_endproc
 104               	.LFE57:
 106               	.global	__vector_125
 108               	__vector_125:
 109               	.LFB58:
  39:Framework.h   **** 
  40:Framework.h   **** ISR(USB_BUSEVENT_vect){
 110               		.loc 1 40 0
 111               		.cfi_startproc
 112 004e 1F92      		push r1
 113               	.LCFI0:
 114               		.cfi_def_cfa_offset 3
 115               		.cfi_offset 1, -2
 116 0050 0F92      		push r0
 117               	.LCFI1:
 118               		.cfi_def_cfa_offset 4
 119               		.cfi_offset 0, -3
 120 0052 0FB6      		in r0,__SREG__
 121 0054 0F92      		push r0
 122 0056 1124      		clr __zero_reg__
 123 0058 2F93      		push r18
 124               	.LCFI2:
 125               		.cfi_def_cfa_offset 5
 126               		.cfi_offset 18, -4
 127 005a 3F93      		push r19
 128               	.LCFI3:
 129               		.cfi_def_cfa_offset 6
 130               		.cfi_offset 19, -5
 131 005c 4F93      		push r20
 132               	.LCFI4:
 133               		.cfi_def_cfa_offset 7
 134               		.cfi_offset 20, -6
 135 005e 5F93      		push r21
 136               	.LCFI5:
 137               		.cfi_def_cfa_offset 8
 138               		.cfi_offset 21, -7
 139 0060 6F93      		push r22
 140               	.LCFI6:
 141               		.cfi_def_cfa_offset 9
 142               		.cfi_offset 22, -8
 143 0062 7F93      		push r23
 144               	.LCFI7:
 145               		.cfi_def_cfa_offset 10
 146               		.cfi_offset 23, -9
 147 0064 8F93      		push r24
 148               	.LCFI8:
 149               		.cfi_def_cfa_offset 11
 150               		.cfi_offset 24, -10
 151 0066 9F93      		push r25
 152               	.LCFI9:
 153               		.cfi_def_cfa_offset 12
 154               		.cfi_offset 25, -11
 155 0068 AF93      		push r26
 156               	.LCFI10:
 157               		.cfi_def_cfa_offset 13
 158               		.cfi_offset 26, -12
 159 006a BF93      		push r27
 160               	.LCFI11:
 161               		.cfi_def_cfa_offset 14
 162               		.cfi_offset 27, -13
 163 006c EF93      		push r30
 164               	.LCFI12:
 165               		.cfi_def_cfa_offset 15
 166               		.cfi_offset 30, -14
 167 006e FF93      		push r31
 168               	.LCFI13:
 169               		.cfi_def_cfa_offset 16
 170               		.cfi_offset 31, -15
 171               	/* prologue: Signal */
 172               	/* frame size = 0 */
 173               	/* stack size = 15 */
 174               	.L__stack_usage = 15
  41:Framework.h   **** 	if (USB.INTFLAGSACLR & USB_SOFIF_bm){
 175               		.loc 1 41 0
 176 0070 E0EC      		ldi r30,lo8(1216)
 177 0072 F4E0      		ldi r31,hi8(1216)
 178 0074 8091 CA04 		lds r24,1226
 179 0078 87FD      		sbrc r24,7
 180 007a 00C0      		rjmp .L8
  42:Framework.h   **** 		USB.INTFLAGSACLR = USB_SOFIF_bm;
  43:Framework.h   **** 	}else if (USB.INTFLAGSACLR & (USB_CRCIF_bm | USB_UNFIF_bm | USB_OVFIF_bm)){
 181               		.loc 1 43 0
 182 007c 8091 CA04 		lds r24,1226
 183 0080 8E70      		andi r24,lo8(14)
 184 0082 01F4      		brne .L9
  44:Framework.h   **** 		USB.INTFLAGSACLR = (USB_CRCIF_bm | USB_UNFIF_bm | USB_OVFIF_bm);
  45:Framework.h   **** 	}else if (USB.INTFLAGSACLR & USB_STALLIF_bm){
 185               		.loc 1 45 0
 186 0084 8091 CA04 		lds r24,1226
 187 0088 80FD      		sbrc r24,0
 188 008a 00C0      		rjmp .L10
  46:Framework.h   **** 		USB.INTFLAGSACLR = USB_STALLIF_bm;
  47:Framework.h   **** 	}else{
  48:Framework.h   **** 		USB.INTFLAGSACLR = USB_SUSPENDIF_bm | USB_RESUMEIF_bm | USB_RSTIF_bm;
 189               		.loc 1 48 0
 190 008c 80E7      		ldi r24,lo8(112)
 191 008e 8287      		std Z+10,r24
 192               	.LBB422:
 193               	.LBB423:
 148:usb/usb.h     **** 	}else{
 149:usb/usb.h     **** 		e->STATUS = USB_EP_BUSNACK0_bm;
 150:usb/usb.h     **** 		e->CTRL = type | USB_EP_size_to_gc(bufsize);
 151:usb/usb.h     **** 	}
 152:usb/usb.h     **** }
 153:usb/usb.h     **** 
 154:usb/usb.h     **** inline void USB_ep_cancel(uint8_t ep) ATTR_ALWAYS_INLINE;
 155:usb/usb.h     **** inline void USB_ep_cancel(uint8_t ep){
 156:usb/usb.h     **** 	_USB_EP(ep);
 157:usb/usb.h     **** 	if (ep & USB_EP_PP){
 158:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 159:usb/usb.h     **** 		LACR16(&e->STATUS, USB_EP_BANK_bm);
 160:usb/usb.h     **** 	}else{
 161:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm);
 162:usb/usb.h     **** 	}
 163:usb/usb.h     **** }
 164:usb/usb.h     **** 
 165:usb/usb.h     **** inline void USB_ep_start_bank(uint8_t ep, uint8_t bank, uint8_t* addr, uint16_t size){
 166:usb/usb.h     **** 	_USB_EP(ep);
 167:usb/usb.h     **** 	_USB_EP_BANK(ep, bank);
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 170:usb/usb.h     **** 	
 171:usb/usb.h     **** 	//TODO: the OVF, STALL, and TRNCOMPL flags are in b->STATUS. Clear them if anyone cares.
 172:usb/usb.h     **** 
 173:usb/usb.h     **** 	if (bank==0){
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 175:usb/usb.h     **** 	}else{
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 177:usb/usb.h     **** 	}
 178:usb/usb.h     **** }
 179:usb/usb.h     **** 
 180:usb/usb.h     **** inline void USB_ep_out_start(uint8_t ep, uint8_t* addr) ATTR_ALWAYS_INLINE;
 181:usb/usb.h     **** inline void USB_ep_out_start(uint8_t ep, uint8_t* addr){
 182:usb/usb.h     **** 	USB_ep_start_bank(ep, 0, addr, 0);
 183:usb/usb.h     **** }
 184:usb/usb.h     **** 
 185:usb/usb.h     **** inline void USB_ep_in_start(uint8_t ep, uint8_t* addr, uint16_t size) ATTR_ALWAYS_INLINE;
 186:usb/usb.h     **** inline void USB_ep_in_start(uint8_t ep, uint8_t* addr, uint16_t size){
 187:usb/usb.h     **** 	USB_ep_start_bank(ep, 0, addr, size);
 188:usb/usb.h     **** }
 189:usb/usb.h     **** 
 190:usb/usb.h     **** inline bool USB_ep_done_bank(uint8_t ep, uint8_t bank){
 191:usb/usb.h     **** 	_USB_EP(ep);
 192:usb/usb.h     **** 	return e->STATUS & (bank?USB_EP_TRNCOMPL1_bm:USB_EP_TRNCOMPL0_bm);
 193:usb/usb.h     **** }
 194:usb/usb.h     **** 
 195:usb/usb.h     **** inline bool USB_ep_done(uint8_t ep) ATTR_ALWAYS_INLINE;
 196:usb/usb.h     **** inline bool USB_ep_done(uint8_t ep){
 197:usb/usb.h     **** 	_USB_EP(ep);
 198:usb/usb.h     **** 	if (ep & USB_EP_PP){
 199:usb/usb.h     **** 		return e->STATUS & (USB_EP_TRNCOMPL0_bm|USB_EP_TRNCOMPL1_bm);
 200:usb/usb.h     **** 	}else{
 201:usb/usb.h     **** 		// Because for ep0, TRNCOMPL1 is SETUP
 202:usb/usb.h     **** 		return e->STATUS & USB_EP_TRNCOMPL0_bm;
 203:usb/usb.h     **** 	}
 204:usb/usb.h     **** }
 205:usb/usb.h     **** 
 206:usb/usb.h     **** inline void USB_ep_clear_done(uint8_t ep) ATTR_ALWAYS_INLINE;
 207:usb/usb.h     **** inline void USB_ep_clear_done(uint8_t ep){
 208:usb/usb.h     **** 	_USB_EP(ep);
 209:usb/usb.h     **** 	if (ep & USB_EP_PP){
 210:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_TRNCOMPL0_bm|USB_EP_TRNCOMPL1_bm);
 211:usb/usb.h     **** 	}else{
 212:usb/usb.h     **** 		// Because for ep0, TRNCOMPL1 is SETUP
 213:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_TRNCOMPL0_bm);
 214:usb/usb.h     **** 	}
 215:usb/usb.h     **** }
 216:usb/usb.h     **** 
 217:usb/usb.h     **** inline bool USB_ep_ready(uint8_t ep) ATTR_ALWAYS_INLINE;
 218:usb/usb.h     **** inline bool USB_ep_ready(uint8_t ep){
 219:usb/usb.h     **** 	_USB_EP(ep);
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 221:usb/usb.h     **** }
 222:usb/usb.h     **** 
 223:usb/usb.h     **** inline bool USB_ep_empty(uint8_t ep) ATTR_ALWAYS_INLINE;
 224:usb/usb.h     **** inline bool USB_ep_empty(uint8_t ep){
 225:usb/usb.h     **** 	_USB_EP(ep);
 226:usb/usb.h     **** 	if (ep & USB_EP_PP){
 227:usb/usb.h     **** 		const uint8_t mask = (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 229:usb/usb.h     **** 	}else{
 230:usb/usb.h     **** 		return e->STATUS & USB_EP_BUSNACK0_bm;
 231:usb/usb.h     **** 	}
 232:usb/usb.h     **** }
 233:usb/usb.h     **** 
 234:usb/usb.h     **** inline uint16_t USB_ep_count_bank(uint8_t ep, uint8_t bank) ATTR_ALWAYS_INLINE;
 235:usb/usb.h     **** inline uint16_t USB_ep_count_bank(uint8_t ep, uint8_t bank){
 236:usb/usb.h     **** 	_USB_EP(ep);
 237:usb/usb.h     **** 	_USB_EP_BANK(ep, bank);
 238:usb/usb.h     **** 	return b->CNT;
 239:usb/usb.h     **** }
 240:usb/usb.h     **** 
 241:usb/usb.h     **** inline uint16_t USB_ep_count(uint8_t ep) ATTR_ALWAYS_INLINE;
 242:usb/usb.h     **** inline uint16_t USB_ep_count(uint8_t ep){
 243:usb/usb.h     **** 	return USB_ep_count_bank(ep, 0);
 244:usb/usb.h     **** }
 245:usb/usb.h     **** 
 246:usb/usb.h     **** inline void USB_ep0_send(uint8_t size){
 247:usb/usb.h     **** 	USB_ep_in_start(0x80, ep0_buf_in, size);
 248:usb/usb.h     **** }
 249:usb/usb.h     **** void USB_ep0_send_progmem(const uint8_t* addr, uint16_t size);
 250:usb/usb.h     **** 
 251:usb/usb.h     **** inline void USB_ep_wait(uint8_t ep) ATTR_ALWAYS_INLINE;
 252:usb/usb.h     **** inline void USB_ep_wait(uint8_t ep){
 253:usb/usb.h     **** 	while (!USB_ep_done(ep)){};
 254:usb/usb.h     **** }
 255:usb/usb.h     **** 
 256:usb/usb.h     **** /// Select a certain bank of an endpoint for the next transfer
 257:usb/usb.h     **** inline void USB_ep_set_bank(uint8_t ep, uint8_t bank) ATTR_ALWAYS_INLINE;
 258:usb/usb.h     **** inline void USB_ep_set_bank(uint8_t ep, uint8_t bank){
 259:usb/usb.h     **** 	_USB_EP(ep);
 260:usb/usb.h     **** 	if (bank){
 261:usb/usb.h     **** 		LASR16(&(e->STATUS), USB_EP_BANK_bm);
 262:usb/usb.h     **** 	}else{
 263:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BANK_bm);
 264:usb/usb.h     **** 	}
 265:usb/usb.h     **** }
 266:usb/usb.h     **** 
 267:usb/usb.h     **** /// Get the bank 0/1 which will handle the next request on this endpoint
 268:usb/usb.h     **** inline uint8_t USB_ep_get_bank(uint8_t ep) ATTR_ALWAYS_INLINE;
 269:usb/usb.h     **** inline uint8_t USB_ep_get_bank(uint8_t ep){
 270:usb/usb.h     **** 	_USB_EP(ep);
 271:usb/usb.h     **** 	return !!(e->STATUS & USB_EP_BANK_bm);
 272:usb/usb.h     **** }
 273:usb/usb.h     **** 
 274:usb/usb.h     **** 
 275:usb/usb.h     **** // Enable the OUT stage on the default control pipe. This happens automatically
 276:usb/usb.h     **** // upon the return of HandleSetup, but use this function if it needs to happen
 277:usb/usb.h     **** // before returning (e.g. with USB_ep_wait()).
 278:usb/usb.h     **** inline void USB_ep0_enableOut(void) ATTR_ALWAYS_INLINE;
 279:usb/usb.h     **** inline void USB_ep0_enableOut(void){
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 281:usb/usb.h     **** }
 282:usb/usb.h     **** 
 283:usb/usb.h     **** bool USB_HandleSetup(void);
 284:usb/usb.h     **** 
 285:usb/usb.h     **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 286:usb/usb.h     ****                                     const uint8_t wIndex,
 287:usb/usb.h     ****                                     const void** const DescriptorAddress);
 288:usb/usb.h     **** 
 289:usb/usb.h     **** /** Detaches the device from the USB bus. This has the effect of removing the device from any
 290:usb/usb.h     ****  *  attached host, ceasing USB communications. If no host is present, this prevents any host from
 291:usb/usb.h     ****  *  enumerating the device once attached until \ref USB_Attach() is called.
 292:usb/usb.h     ****  */
 293:usb/usb.h     **** static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
 294:usb/usb.h     **** static inline void USB_Detach(void)
 295:usb/usb.h     **** {
 296:usb/usb.h     **** 	USB.CTRLB &= ~USB_ATTACH_bm;
 297:usb/usb.h     **** }
 298:usb/usb.h     **** 
 299:usb/usb.h     **** /** Attaches the device to the USB bus. This announces the device's presence to any attached
 300:usb/usb.h     ****  *  USB host, starting the enumeration process. If no host is present, attaching the device
 301:usb/usb.h     ****  *  will allow for enumeration once a host is connected to the device.
 302:usb/usb.h     ****  */
 303:usb/usb.h     **** static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
 304:usb/usb.h     **** static inline void USB_Attach(void)
 305:usb/usb.h     **** {
 306:usb/usb.h     **** 	USB.CTRLB |= USB_ATTACH_bm;
 307:usb/usb.h     **** }
 308:usb/usb.h     **** 
 309:usb/usb.h     **** inline void USB_Evt_Task(void) ATTR_ALWAYS_INLINE;
 310:usb/usb.h     **** inline void USB_Evt_Task(void){
 311:usb/usb.h     **** 	if (USB.STATUS & USB_BUSRST_bm){
 194               		.loc 5 311 0
 195 0090 8091 C204 		lds r24,1218
 196 0094 80FF      		sbrs r24,0
 197 0096 00C0      		rjmp .L2
 312:usb/usb.h     **** 		USB.STATUS &= ~USB_BUSRST_bm;
 198               		.loc 5 312 0
 199 0098 8091 C204 		lds r24,1218
 200 009c 8E7F      		andi r24,lo8(-2)
 201 009e 8283      		std Z+2,r24
 313:usb/usb.h     **** 		USB_Init();
 202               		.loc 5 313 0
 203 00a0 0E94 0000 		call USB_Init
 204 00a4 00C0      		rjmp .L2
 205               	.L9:
 206               	.LBE423:
 207               	.LBE422:
  44:Framework.h   **** 		USB.INTFLAGSACLR = (USB_CRCIF_bm | USB_UNFIF_bm | USB_OVFIF_bm);
 208               		.loc 1 44 0
 209 00a6 8EE0      		ldi r24,lo8(14)
 210 00a8 8287      		std Z+10,r24
 211               	.L2:
 212               	/* epilogue start */
  49:Framework.h   **** 		USB_Evt_Task();
  50:Framework.h   **** 	}
  51:Framework.h   **** }
 213               		.loc 1 51 0
 214 00aa FF91      		pop r31
 215 00ac EF91      		pop r30
 216 00ae BF91      		pop r27
 217 00b0 AF91      		pop r26
 218 00b2 9F91      		pop r25
 219 00b4 8F91      		pop r24
 220 00b6 7F91      		pop r23
 221 00b8 6F91      		pop r22
 222 00ba 5F91      		pop r21
 223 00bc 4F91      		pop r20
 224 00be 3F91      		pop r19
 225 00c0 2F91      		pop r18
 226 00c2 0F90      		pop r0
 227 00c4 0FBE      		out __SREG__,r0
 228 00c6 0F90      		pop r0
 229 00c8 1F90      		pop r1
 230 00ca 1895      		reti
 231               	.L10:
  46:Framework.h   **** 		USB.INTFLAGSACLR = USB_STALLIF_bm;
 232               		.loc 1 46 0
 233 00cc 81E0      		ldi r24,lo8(1)
 234 00ce 8287      		std Z+10,r24
 235 00d0 00C0      		rjmp .L2
 236               	.L8:
  42:Framework.h   **** 		USB.INTFLAGSACLR = USB_SOFIF_bm;
 237               		.loc 1 42 0
 238 00d2 80E8      		ldi r24,lo8(-128)
 239 00d4 8287      		std Z+10,r24
 240 00d6 00C0      		rjmp .L2
 241               		.cfi_endproc
 242               	.LFE58:
 244               	.global	__vector_126
 246               	__vector_126:
 247               	.LFB59:
  52:Framework.h   **** 
  53:Framework.h   **** ISR(USB_TRNCOMPL_vect){
 248               		.loc 1 53 0
 249               		.cfi_startproc
 250 00d8 1F92      		push r1
 251               	.LCFI14:
 252               		.cfi_def_cfa_offset 3
 253               		.cfi_offset 1, -2
 254 00da 0F92      		push r0
 255               	.LCFI15:
 256               		.cfi_def_cfa_offset 4
 257               		.cfi_offset 0, -3
 258 00dc 0FB6      		in r0,__SREG__
 259 00de 0F92      		push r0
 260 00e0 1124      		clr __zero_reg__
 261 00e2 0F93      		push r16
 262               	.LCFI16:
 263               		.cfi_def_cfa_offset 5
 264               		.cfi_offset 16, -4
 265 00e4 2F93      		push r18
 266               	.LCFI17:
 267               		.cfi_def_cfa_offset 6
 268               		.cfi_offset 18, -5
 269 00e6 3F93      		push r19
 270               	.LCFI18:
 271               		.cfi_def_cfa_offset 7
 272               		.cfi_offset 19, -6
 273 00e8 4F93      		push r20
 274               	.LCFI19:
 275               		.cfi_def_cfa_offset 8
 276               		.cfi_offset 20, -7
 277 00ea 5F93      		push r21
 278               	.LCFI20:
 279               		.cfi_def_cfa_offset 9
 280               		.cfi_offset 21, -8
 281 00ec 6F93      		push r22
 282               	.LCFI21:
 283               		.cfi_def_cfa_offset 10
 284               		.cfi_offset 22, -9
 285 00ee 7F93      		push r23
 286               	.LCFI22:
 287               		.cfi_def_cfa_offset 11
 288               		.cfi_offset 23, -10
 289 00f0 8F93      		push r24
 290               	.LCFI23:
 291               		.cfi_def_cfa_offset 12
 292               		.cfi_offset 24, -11
 293 00f2 9F93      		push r25
 294               	.LCFI24:
 295               		.cfi_def_cfa_offset 13
 296               		.cfi_offset 25, -12
 297 00f4 AF93      		push r26
 298               	.LCFI25:
 299               		.cfi_def_cfa_offset 14
 300               		.cfi_offset 26, -13
 301 00f6 BF93      		push r27
 302               	.LCFI26:
 303               		.cfi_def_cfa_offset 15
 304               		.cfi_offset 27, -14
 305 00f8 EF93      		push r30
 306               	.LCFI27:
 307               		.cfi_def_cfa_offset 16
 308               		.cfi_offset 30, -15
 309 00fa FF93      		push r31
 310               	.LCFI28:
 311               		.cfi_def_cfa_offset 17
 312               		.cfi_offset 31, -16
 313               	/* prologue: Signal */
 314               	/* frame size = 0 */
 315               	/* stack size = 16 */
 316               	.L__stack_usage = 16
  54:Framework.h   **** 	USB.FIFOWP = 0;
 317               		.loc 1 54 0
 318 00fc E0EC      		ldi r30,lo8(1216)
 319 00fe F4E0      		ldi r31,hi8(1216)
 320 0100 1482      		std Z+4,__zero_reg__
  55:Framework.h   **** 	USB.INTFLAGSBCLR = USB_SETUPIF_bm | USB_TRNIF_bm;
 321               		.loc 1 55 0
 322 0102 83E0      		ldi r24,lo8(3)
 323 0104 8487      		std Z+12,r24
 324               	.LVL6:
 325               	.LBB480:
 326               	.LBB481:
 327               	.LBB482:
  50:usb/usb_pipe.h **** 	}
  51:usb/usb_pipe.h **** }
  52:usb/usb_pipe.h **** 
  53:usb/usb_pipe.h **** static inline void usb_pipe_reset(const USB_Pipe* p){
  54:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
  55:usb/usb_pipe.h **** 		pipe_reset(p->pipe);
  56:usb/usb_pipe.h **** 		USB_ep_cancel(p->ep);
  57:usb/usb_pipe.h **** 		p->data->flush = 0;
  58:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
  59:usb/usb_pipe.h **** 		p->data->bank = 0;
  60:usb/usb_pipe.h **** 	}
  61:usb/usb_pipe.h **** }
  62:usb/usb_pipe.h **** 
  63:usb/usb_pipe.h **** static inline void _usb_pipe_ep_start(const USB_Pipe* p, uint8_t* data, uint16_t size) ATTR_ALWAYS_
  64:usb/usb_pipe.h **** static inline void _usb_pipe_ep_start(const USB_Pipe* p, uint8_t* data, uint16_t size){
  65:usb/usb_pipe.h **** 	bool bank = 0;
  66:usb/usb_pipe.h **** 
  67:usb/usb_pipe.h **** 	if (p->ep & USB_EP_PP){
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
  70:usb/usb_pipe.h **** 	}
  71:usb/usb_pipe.h **** 
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
  73:usb/usb_pipe.h **** 		USB_ep_start_bank(p->ep, 0, data, size);
  74:usb/usb_pipe.h **** 	}else{
  75:usb/usb_pipe.h **** 		USB_ep_start_bank(p->ep, 1, data, size);
  76:usb/usb_pipe.h **** 	}
  77:usb/usb_pipe.h **** }
  78:usb/usb_pipe.h **** 
  79:usb/usb_pipe.h **** static inline void usb_pipe_handle(const USB_Pipe* p){
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 328               		.loc 2 80 0
 329 0106 2FB7      		in r18,__SREG__
 330               	.LVL7:
 331               	.LBB483:
 332               	.LBB484:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 333               		.loc 3 50 0
 334               	/* #APP */
 335               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 336 0108 F894      		cli
 337               	 ;  0 "" 2
 338               	.LVL8:
 339               	/* #NOAPP */
 340               	.LBE484:
 341               	.LBE483:
 342               	.LBB485:
 343               	.LBB486:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 344               		.loc 5 220 0
 345 010a 8091 0000 		lds r24,endpoints+24
 346 010e 8670      		andi r24,lo8(6)
 347               	.LBE486:
 348               	.LBE485:
  81:usb/usb_pipe.h **** 		if (p->ep & USB_EP_IN){
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 349               		.loc 2 82 0
 350 0110 01F4      		brne .L26
 351               	.LVL9:
 352               	.L12:
 353               	.LBB487:
 354               	.LBB488:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 355               		.loc 3 70 0
 356 0112 2FBF      		out __SREG__,r18
 357               		.loc 3 71 0
 358               	.LBE488:
 359               	.LBE487:
 360               	.LBE482:
 361               	.LBE481:
 362               	.LBE480:
 363               	.LBB526:
 364               	.LBB527:
 314:usb/usb.h     **** 	}
 315:usb/usb.h     **** }
 316:usb/usb.h     **** 
 317:usb/usb.h     **** inline void USB_Task(void) ATTR_ALWAYS_INLINE;
 318:usb/usb.h     **** inline void USB_Task(void){
 319:usb/usb.h     **** 	// Read once to prevent race condition where SETUP packet is interpreted as OUT
 320:usb/usb.h     **** 	uint8_t status = endpoints[0].out.STATUS;
 365               		.loc 5 320 0
 366 0114 8091 0000 		lds r24,endpoints
 367               	.LVL10:
 321:usb/usb.h     **** 
 322:usb/usb.h     **** 	if (status & USB_EP_SETUP_bm){
 368               		.loc 5 322 0
 369 0118 84FD      		sbrc r24,4
 370 011a 00C0      		rjmp .L27
 371               	.L21:
 323:usb/usb.h     **** 		if (!USB_HandleSetup()){
 324:usb/usb.h     **** 			endpoints[0].out.CTRL |= USB_EP_STALL_bm;
 325:usb/usb.h     **** 			endpoints[0].in.CTRL |= USB_EP_STALL_bm; 
 326:usb/usb.h     **** 		}
 327:usb/usb.h     **** 		USB_ep0_enableOut();
 328:usb/usb.h     **** 	}else if(status & USB_EP_TRNCOMPL0_bm){
 372               		.loc 5 328 0
 373 011c 85FD      		sbrc r24,5
 374 011e 00C0      		rjmp .L28
 375               	.LVL11:
 376               	.L11:
 377               	/* epilogue start */
 378               	.LBE527:
 379               	.LBE526:
  56:Framework.h   **** 	usb_pipe_handle(&ep_in);
  57:Framework.h   **** 	USB_Task();
  58:Framework.h   **** }
 380               		.loc 1 58 0
 381 0120 FF91      		pop r31
 382 0122 EF91      		pop r30
 383 0124 BF91      		pop r27
 384 0126 AF91      		pop r26
 385 0128 9F91      		pop r25
 386 012a 8F91      		pop r24
 387 012c 7F91      		pop r23
 388 012e 6F91      		pop r22
 389 0130 5F91      		pop r21
 390 0132 4F91      		pop r20
 391 0134 3F91      		pop r19
 392 0136 2F91      		pop r18
 393 0138 0F91      		pop r16
 394 013a 0F90      		pop r0
 395 013c 0FBE      		out __SREG__,r0
 396 013e 0F90      		pop r0
 397 0140 1F90      		pop r1
 398 0142 1895      		reti
 399               	.LVL12:
 400               	.L26:
 401               	.LBB536:
 402               	.LBB523:
 403               	.LBB520:
 404               	.LBB490:
 405               	.LBB491:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 406               		.loc 4 51 0
 407 0144 3091 0000 		lds r19,ep_in_pipe_data+4
 408               	.LBE491:
 409               	.LBE490:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 410               		.loc 2 83 0
 411 0148 1316      		cp __zero_reg__,r19
 412 014a 04F0      		brlt .+2
 413 014c 00C0      		rjmp .L13
 414               	.LBB492:
 415               	.LBB493:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 416               		.loc 4 62 0
 417 014e 8091 0000 		lds r24,ep_in_pipe_data
 418 0152 9091 0000 		lds r25,ep_in_pipe_data+1
 419               	.LVL13:
 420               	.LBE493:
 421               	.LBE492:
 422               	.LBB494:
 423               	.LBB495:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 424               		.loc 2 68 0
 425 0156 4091 0000 		lds r20,ep_in_data
 426               	.LVL14:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 427               		.loc 2 69 0
 428 015a 51E0      		ldi r21,lo8(1)
 429 015c 4130      		cpi r20,lo8(1)
 430 015e 01F4      		brne .+2
 431 0160 00C0      		rjmp .L29
 432 0162 5093 0000 		sts ep_in_data,r21
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 433               		.loc 2 72 0
 434 0166 4423      		tst r20
 435 0168 01F4      		brne .+2
 436 016a 00C0      		rjmp .L30
 437               	.L15:
 438               	.LVL15:
 439               	.LBB496:
 440               	.LBB497:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 441               		.loc 5 168 0
 442 016c 8093 0000 		sts endpoints+20,r24
 443 0170 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 444               		.loc 5 169 0
 445 0174 40E4      		ldi r20,lo8(64)
 446 0176 50E0      		ldi r21,hi8(64)
 447 0178 4093 0000 		sts endpoints+18,r20
 448 017c 5093 0000 		sts endpoints+18+1,r21
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 449               		.loc 5 176 0
 450 0180 E0E0      		ldi r30,lo8(endpoints+24)
 451 0182 F0E0      		ldi r31,hi8(endpoints+24)
 452               	/* #APP */
 453               	 ;  176 "usb/usb.h" 1
 454 0184 04E1      		ldi r16, 20
 455 0186 0693      		.dc.w 0x9306
 456               		
 457               	 ;  0 "" 2
 458               	.LVL16:
 459               	/* #NOAPP */
 460               	.L16:
 461               	.LBE497:
 462               	.LBE496:
 463               	.LBE495:
 464               	.LBE494:
 465               	.LBB501:
 466               	.LBB502:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 467               		.loc 4 72 0
 468 0188 3150      		subi r19,lo8(-(-1))
 469 018a 3093 0000 		sts ep_in_pipe_data+4,r19
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 470               		.loc 4 73 0
 471 018e 805C      		subi r24,lo8(-(64))
 472 0190 9F4F      		sbci r25,hi8(-(64))
 473 0192 8093 0000 		sts ep_in_pipe_data,r24
 474 0196 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 475               		.loc 4 75 0
 476 019a 30E0      		ldi r19,hi8(ep_in_pipe_buffer+512)
 477 019c 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 478 019e 9307      		cpc r25,r19
 479 01a0 01F0      		breq .+2
 480 01a2 00C0      		rjmp .L12
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
 481               		.loc 4 76 0
 482 01a4 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 483 01a6 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 484 01a8 8093 0000 		sts ep_in_pipe_data,r24
 485 01ac 9093 0000 		sts ep_in_pipe_data+1,r25
 486               	.LBE502:
 487               	.LBE501:
 488               	.LBB503:
 489               	.LBB489:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 490               		.loc 3 70 0
 491 01b0 2FBF      		out __SREG__,r18
 492               		.loc 3 71 0
 493               	.LBE489:
 494               	.LBE503:
 495               	.LBE520:
 496               	.LBE523:
 497               	.LBE536:
 498               	.LBB537:
 499               	.LBB534:
 320:usb/usb.h     **** 	uint8_t status = endpoints[0].out.STATUS;
 500               		.loc 5 320 0
 501 01b2 8091 0000 		lds r24,endpoints
 502               	.LVL17:
 322:usb/usb.h     **** 	if (status & USB_EP_SETUP_bm){
 503               		.loc 5 322 0
 504 01b6 84FF      		sbrs r24,4
 505 01b8 00C0      		rjmp .L21
 506               	.LVL18:
 507               	.L27:
 323:usb/usb.h     **** 		if (!USB_HandleSetup()){
 508               		.loc 5 323 0
 509 01ba 0E94 0000 		call USB_HandleSetup
 510               	.LVL19:
 511 01be 8823      		tst r24
 512 01c0 01F4      		brne .L24
 324:usb/usb.h     **** 			endpoints[0].out.CTRL |= USB_EP_STALL_bm;
 513               		.loc 5 324 0
 514 01c2 8091 0000 		lds r24,endpoints+1
 515 01c6 8460      		ori r24,lo8(4)
 516 01c8 8093 0000 		sts endpoints+1,r24
 325:usb/usb.h     **** 			endpoints[0].in.CTRL |= USB_EP_STALL_bm; 
 517               		.loc 5 325 0
 518 01cc 8091 0000 		lds r24,endpoints+9
 519 01d0 8460      		ori r24,lo8(4)
 520 01d2 8093 0000 		sts endpoints+9,r24
 521               	.L24:
 522               	.LBB528:
 523               	.LBB529:
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 524               		.loc 5 280 0
 525 01d6 E0E0      		ldi r30,lo8(endpoints)
 526 01d8 F0E0      		ldi r31,hi8(endpoints)
 527               	/* #APP */
 528               	 ;  280 "usb/usb.h" 1
 529 01da 02E7      		ldi r16, 114
 530 01dc 0693      		.dc.w 0x9306
 531               		
 532               	 ;  0 "" 2
 533               	/* #NOAPP */
 534 01de 00C0      		rjmp .L11
 535               	.LVL20:
 536               	.L29:
 537               	.LBE529:
 538               	.LBE528:
 539               	.LBE534:
 540               	.LBE537:
 541               	.LBB538:
 542               	.LBB524:
 543               	.LBB521:
 544               	.LBB504:
 545               	.LBB500:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 546               		.loc 2 69 0
 547 01e0 50E0      		ldi r21,lo8(0)
 548 01e2 5093 0000 		sts ep_in_data,r21
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 549               		.loc 2 72 0
 550 01e6 4423      		tst r20
 551 01e8 01F0      		breq .+2
 552 01ea 00C0      		rjmp .L15
 553               	.L30:
 554               	.LVL21:
 555               	.LBB498:
 556               	.LBB499:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 557               		.loc 5 168 0
 558 01ec 8093 0000 		sts endpoints+28,r24
 559 01f0 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 560               		.loc 5 169 0
 561 01f4 40E4      		ldi r20,lo8(64)
 562 01f6 50E0      		ldi r21,hi8(64)
 563               	.LVL22:
 564 01f8 4093 0000 		sts endpoints+26,r20
 565 01fc 5093 0000 		sts endpoints+26+1,r21
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 566               		.loc 5 174 0
 567 0200 E0E0      		ldi r30,lo8(endpoints+24)
 568 0202 F0E0      		ldi r31,hi8(endpoints+24)
 569               	.LVL23:
 570               	/* #APP */
 571               	 ;  174 "usb/usb.h" 1
 572 0204 02E2      		ldi r16, 34
 573 0206 0693      		.dc.w 0x9306
 574               		
 575               	 ;  0 "" 2
 576               	/* #NOAPP */
 577 0208 00C0      		rjmp .L16
 578               	.LVL24:
 579               	.L28:
 580               	.LBE499:
 581               	.LBE498:
 582               	.LBE500:
 583               	.LBE504:
 584               	.LBE521:
 585               	.LBE524:
 586               	.LBE538:
 587               	.LBB539:
 588               	.LBB535:
 329:usb/usb.h     **** 		EVENT_USB_Device_ControlOUT((uint8_t *) ep0_buf_out, endpoints[0].out.CNT);
 589               		.loc 5 329 0
 590 020a 4091 0000 		lds r20,endpoints+2
 591 020e 5091 0000 		lds r21,endpoints+2+1
 592               	.LVL25:
 593               	.LBB531:
 594               	.LBB532:
 595               		.file 6 "main.c"
   1:main.c        **** #include "Framework.h"
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <inttypes.h>
   4:main.c        **** #include <stdio.h> 
   5:main.c        **** #include <stdlib.h>
   6:main.c        **** #include <util/delay.h>
   7:main.c        **** #include <string.h> 
   8:main.c        **** #include <math.h>
   9:main.c        **** #include "utils/utils.h"
  10:main.c        **** #include "nmea/nmea.h"
  11:main.c        **** #include "uart/uart.h"
  12:main.c        **** #include "gps/gps.h"
  13:main.c        **** #include "gprs/gprs.h"
  14:main.c        **** #include "sms/sms.h"
  15:main.c        **** 
  16:main.c        **** #define HIGH_FREQ 1
  17:main.c        **** #define LOW_FREQ 0
  18:main.c        **** 
  19:main.c        **** const uint16_t low_freq = 1000*30;
  20:main.c        **** const uint16_t high_freq = 1000*30;
  21:main.c        **** uint8_t freq = 0; // 0 --> low_freq, 1 --> high_freq
  22:main.c        **** char* phonenumber = "+18572080246";
  23:main.c        **** char* twilio_number = "+13042493059";
  24:main.c        **** char *message;
  25:main.c        **** bool updating = false;
  26:main.c        **** uint8_t count;
  27:main.c        **** latlng gps;
  28:main.c        **** 
  29:main.c        **** int main(void){
  30:main.c        **** 
  31:main.c        ****   //usb configuration
  32:main.c        **** 	USB_ConfigureClock();
  33:main.c        **** 	USB_Init();
  34:main.c        **** 	USB.INTCTRLA = USB_BUSEVIE_bm | USB_INTLVL_MED_gc;
  35:main.c        **** 	USB.INTCTRLB = USB_TRNIE_bm | USB_SETUPIE_bm;
  36:main.c        **** 	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
  37:main.c        **** 	sei();
  38:main.c        **** 
  39:main.c        ****   if (true) {
  40:main.c        ****   	//USART, PORT, TXPIN_bm
  41:main.c        ****     gprs_init(&USARTC0, &PORTC, PIN3_bm);
  42:main.c        ****   }
  43:main.c        **** 
  44:main.c        ****   //uart init code -- change condition to true when we're ready to communicate with the gps
  45:main.c        **** 	if (true) {
  46:main.c        **** 		//USART, PORT, POWERPIN_bm, TXPIN_bm, RESETPIN_bm
  47:main.c        **** 		gps_init(&USARTD0, &PORTD, PIN0_bm, PIN3_bm, PIN4_bm);
  48:main.c        **** 	}
  49:main.c        **** 
  50:main.c        **** 
  51:main.c        ****   //call break and flush to make sure the buffer is cleared
  52:main.c        **** 	break_and_flush();
  53:main.c        **** 
  54:main.c        ****   // parse nmea string and send result over usb
  55:main.c        ****   // char* text_message = parse_nmea();
  56:main.c        **** 	// char* text_message = "Whatsup?";
  57:main.c        ****   // send_message(phonenumber, text_message, &USARTC0);
  58:main.c        ****   // send_message(twilio_number, text_message, &USARTD0);
  59:main.c        ****   // SimpleReceive(&USARTD0);
  60:main.c        **** 
  61:main.c        **** 	for (;;){
  62:main.c        ****     gps_receive(&USARTD0, &gps);
  63:main.c        ****     if (gps.valid) {
  64:main.c        ****     	if (gps.roaming) {
  65:main.c        **** 		  	send_message(phonenumber, gps.sms, &USARTC0);
  66:main.c        ****       	send_message(twilio_number, gps.sms, &USARTC0);
  67:main.c        ****       	freq = HIGH_FREQ;
  68:main.c        ****     	} else {
  69:main.c        ****     		freq = LOW_FREQ;
  70:main.c        ****     	}
  71:main.c        ****     }
  72:main.c        ****     if (freq == HIGH_FREQ) {
  73:main.c        ****     	_delay_ms(high_freq);
  74:main.c        ****     } else {
  75:main.c        ****     	_delay_ms(low_freq);
  76:main.c        ****     }
  77:main.c        **** 	}
  78:main.c        **** }
  79:main.c        **** 
  80:main.c        **** #define stringify(s) #s
  81:main.c        **** 
  82:main.c        **** const char PROGMEM hwversion[] = stringify(HW_VERSION);
  83:main.c        **** const char PROGMEM fwversion[] = stringify(FW_VERSION);
  84:main.c        **** 
  85:main.c        **** uint8_t usb_cmd = 0;
  86:main.c        **** uint8_t cmd_data = 0;
  87:main.c        **** 
  88:main.c        **** // void send_usb_data(char *message) {
  89:main.c        **** // 	for (uint8_t = 0; i < 64; i++) ep0_buf_in[i] = 0;
  90:main.c        **** // 	int l = strlen(message);
  91:main.c        **** // 	for (int i=0; i<l; i++) {
  92:main.c        **** // 		ep0_buf_in[i] = message[i];
  93:main.c        **** // 	}
  94:main.c        **** // }
  95:main.c        **** 
  96:main.c        **** /** Event handler for the library USB Control Request reception event. */
  97:main.c        **** bool EVENT_USB_Device_ControlRequest(USB_Request_Header_t* req){
  98:main.c        **** 	// zero out ep0_buf_in
  99:main.c        **** 	for (uint8_t i = 0; i < 64; i++) ep0_buf_in[i] = 0;
 100:main.c        **** 	usb_cmd = 0;
 101:main.c        **** 	if ((req->bmRequestType & CONTROL_REQTYPE_TYPE) == REQTYPE_VENDOR){
 102:main.c        **** 		switch(req->bRequest){
 103:main.c        **** 			case 0x00: // Info
 104:main.c        **** 				if (req->wIndex == 0){
 105:main.c        **** 					USB_ep0_send_progmem((uint8_t*)hwversion, sizeof(hwversion));
 106:main.c        **** 				}else if (req->wIndex == 1){
 107:main.c        **** 					USB_ep0_send_progmem((uint8_t*)fwversion, sizeof(fwversion));
 108:main.c        **** 				}
 109:main.c        **** 				return true;
 110:main.c        **** 			case 0x02:
 111:main.c        **** 				{
 112:main.c        **** 					int l = strlen(message);
 113:main.c        **** 					for (uint8_t i=0; i<64; i++) {
 114:main.c        **** 						ep0_buf_in[i] = message[i];
 115:main.c        **** 					}
 116:main.c        **** 					USB_ep0_send(l);
 117:main.c        **** 					return true;
 118:main.c        **** 				}
 119:main.c        **** 			case 0x08:
 120:main.c        **** 				* ((uint8_t *) req->wIndex) = req->wValue;
 121:main.c        **** 				USB_ep0_send(0);
 122:main.c        **** 				return true;
 123:main.c        **** 			case 0x09:
 124:main.c        **** 				ep0_buf_in[0] = * ((uint8_t *) req->wIndex);
 125:main.c        **** 				USB_ep0_send(1);
 126:main.c        **** 				return true;
 127:main.c        **** 			case 0x16:
 128:main.c        **** 				* ((uint16_t *) req->wIndex) = req->wValue;
 129:main.c        **** 				USB_ep0_send(0);
 130:main.c        **** 				return true;
 131:main.c        **** 			case 0x17:{
 132:main.c        **** 				uint16_t *addr;
 133:main.c        **** 				addr = (uint16_t *) req->wIndex;
 134:main.c        **** 				ep0_buf_in[0] = *addr & 0xFF;
 135:main.c        **** 				ep0_buf_in[1] = *addr >> 8;
 136:main.c        **** 				USB_ep0_send(2);}
 137:main.c        **** 				return true;
 138:main.c        **** 			// read EEPROM	
 139:main.c        **** 			case 0xE0: 
 140:main.c        **** 				eeprom_read_block(ep0_buf_in, (void*)(req->wIndex*64), 64);
 141:main.c        **** 				USB_ep0_send(64);
 142:main.c        **** 				return true;
 143:main.c        **** 
 144:main.c        **** 			// write EEPROM	
 145:main.c        **** 			case 0xE1: 
 146:main.c        **** 				usb_cmd = req->bRequest;
 147:main.c        **** 				cmd_data = req->wIndex;
 148:main.c        **** 				USB_ep0_send(0);
 149:main.c        **** 				return true; // Wait for OUT data (expecting an OUT transfer)
 150:main.c        **** 
 151:main.c        **** 			// disconnect from USB, jump to bootloader	
 152:main.c        **** 			case 0xBB: 
 153:main.c        **** 				USB_enter_bootloader();
 154:main.c        **** 				return true;
 155:main.c        **** 		}
 156:main.c        **** 	}
 157:main.c        **** 	return false;
 158:main.c        **** }
 159:main.c        **** 
 160:main.c        **** void EVENT_USB_Device_ControlOUT(uint8_t* buf, uint8_t count){
 161:main.c        **** 	switch (usb_cmd){
 596               		.loc 6 161 0
 597 0212 8091 0000 		lds r24,usb_cmd
 598               	.LVL26:
 599 0216 813E      		cpi r24,lo8(-31)
 600 0218 01F4      		brne .L24
 162:main.c        **** 		case 0xE1: // Write EEPROM
 163:main.c        **** 			eeprom_update_block(buf, (void*)(cmd_data*64), count);
 601               		.loc 6 163 0
 602 021a 6091 0000 		lds r22,cmd_data
 603 021e 70E0      		ldi r23,lo8(0)
 604 0220 0024      		clr __tmp_reg__
 605 0222 7695      		lsr r23
 606 0224 6795      		ror r22
 607 0226 0794      		ror __tmp_reg__
 608 0228 7695      		lsr r23
 609 022a 6795      		ror r22
 610 022c 0794      		ror __tmp_reg__
 611 022e 762F      		mov r23,r22
 612 0230 602D      		mov r22,__tmp_reg__
 613 0232 80E0      		ldi r24,lo8(ep0_buf_out)
 614 0234 90E0      		ldi r25,hi8(ep0_buf_out)
 615 0236 50E0      		ldi r21,lo8(0)
 616 0238 0E94 0000 		call __eeupd_block_x32a4u
 617               	.LVL27:
 618               	.LBE532:
 619               	.LBE531:
 620               	.LBB533:
 621               	.LBB530:
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 622               		.loc 5 280 0
 623 023c E0E0      		ldi r30,lo8(endpoints)
 624 023e F0E0      		ldi r31,hi8(endpoints)
 625               	/* #APP */
 626               	 ;  280 "usb/usb.h" 1
 627 0240 02E7      		ldi r16, 114
 628 0242 0693      		.dc.w 0x9306
 629               		
 630               	 ;  0 "" 2
 631               	/* #NOAPP */
 632 0244 00C0      		rjmp .L11
 633               	.LVL28:
 634               	.L13:
 635               	.LBE530:
 636               	.LBE533:
 637               	.LBE535:
 638               	.LBE539:
 639               	.LBB540:
 640               	.LBB525:
 641               	.LBB522:
  84:usb/usb_pipe.h **** 					_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->pipe->size);
  85:usb/usb_pipe.h **** 					pipe_done_read(p->pipe);
  86:usb/usb_pipe.h **** 				}else if (p->features & PIPE_ENABLE_FLUSH){
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 642               		.loc 2 87 0
 643 0246 8091 0000 		lds r24,ep_in_data+1
 644 024a 8130      		cpi r24,lo8(1)
 645 024c 01F0      		breq .L31
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
  89:usb/usb_pipe.h **** 						// Send short packet
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 646               		.loc 2 91 0
 647 024e 8230      		cpi r24,lo8(2)
 648 0250 01F0      		breq .+2
 649 0252 00C0      		rjmp .L12
 650               	.LVL29:
 651               	.LBB505:
 652               	.LBB506:
 653               	.LBB507:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 654               		.loc 5 228 0
 655 0254 8091 0000 		lds r24,endpoints+24
 656 0258 8670      		andi r24,lo8(6)
 657               	.LBE507:
 658               	.LBE506:
 659               	.LBE505:
 660               		.loc 2 91 0
 661 025a 8630      		cpi r24,lo8(6)
 662 025c 01F0      		breq .+2
 663 025e 00C0      		rjmp .L12
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 664               		.loc 2 92 0
 665 0260 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 666               		.loc 2 93 0
 667 0264 1092 0000 		sts ep_in_data+2,__zero_reg__
 668 0268 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 669               	.LBB508:
 670               	.LBB509:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 671               		.loc 4 90 0
 672 026c 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 673               		.loc 4 91 0
 674 0270 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 675 0272 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 676 0274 8093 0000 		sts ep_in_pipe_data+2,r24
 677 0278 9093 0000 		sts ep_in_pipe_data+2+1,r25
 678 027c 8093 0000 		sts ep_in_pipe_data,r24
 679 0280 9093 0000 		sts ep_in_pipe_data+1,r25
 680               	.LVL30:
 681 0284 00C0      		rjmp .L12
 682               	.LVL31:
 683               	.L31:
 684               	.LBE509:
 685               	.LBE508:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 686               		.loc 2 88 0
 687 0286 82E0      		ldi r24,lo8(2)
 688 0288 8093 0000 		sts ep_in_data+1,r24
 689               	.LBB510:
 690               	.LBB511:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 691               		.loc 4 62 0
 692 028c 7091 0000 		lds r23,ep_in_pipe_data
 693 0290 6091 0000 		lds r22,ep_in_pipe_data+1
 694               	.LBE511:
 695               	.LBE510:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 696               		.loc 2 90 0
 697 0294 8091 0000 		lds r24,ep_in_data+2
 698 0298 9091 0000 		lds r25,ep_in_data+2+1
 699               	.LVL32:
 700               	.LBB512:
 701               	.LBB513:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 702               		.loc 2 68 0
 703 029c 3091 0000 		lds r19,ep_in_data
 704               	.LVL33:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 705               		.loc 2 69 0
 706 02a0 41E0      		ldi r20,lo8(1)
 707 02a2 3130      		cpi r19,lo8(1)
 708 02a4 01F0      		breq .L32
 709               	.L19:
 710 02a6 4093 0000 		sts ep_in_data,r20
 711               	.LBB514:
 712               	.LBB515:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 713               		.loc 5 168 0
 714 02aa 472F      		mov r20,r23
 715 02ac 562F      		mov r21,r22
 716               	.LBE515:
 717               	.LBE514:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 718               		.loc 2 72 0
 719 02ae 3323      		tst r19
 720 02b0 01F4      		brne .L20
 721               	.LVL34:
 722               	.LBB517:
 723               	.LBB516:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 724               		.loc 5 168 0
 725 02b2 4093 0000 		sts endpoints+28,r20
 726 02b6 5093 0000 		sts endpoints+28+1,r21
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 727               		.loc 5 169 0
 728 02ba 8093 0000 		sts endpoints+26,r24
 729 02be 9093 0000 		sts endpoints+26+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 730               		.loc 5 174 0
 731 02c2 E0E0      		ldi r30,lo8(endpoints+24)
 732 02c4 F0E0      		ldi r31,hi8(endpoints+24)
 733               	.LVL35:
 734               	/* #APP */
 735               	 ;  174 "usb/usb.h" 1
 736 02c6 02E2      		ldi r16, 34
 737 02c8 0693      		.dc.w 0x9306
 738               		
 739               	 ;  0 "" 2
 740               	/* #NOAPP */
 741 02ca 00C0      		rjmp .L12
 742               	.LVL36:
 743               	.L20:
 744               	.LBE516:
 745               	.LBE517:
 746               	.LBB518:
 747               	.LBB519:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 748               		.loc 5 168 0
 749 02cc 4093 0000 		sts endpoints+20,r20
 750 02d0 5093 0000 		sts endpoints+20+1,r21
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 751               		.loc 5 169 0
 752 02d4 8093 0000 		sts endpoints+18,r24
 753 02d8 9093 0000 		sts endpoints+18+1,r25
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 754               		.loc 5 176 0
 755 02dc E0E0      		ldi r30,lo8(endpoints+24)
 756 02de F0E0      		ldi r31,hi8(endpoints+24)
 757               	/* #APP */
 758               	 ;  176 "usb/usb.h" 1
 759 02e0 04E1      		ldi r16, 20
 760 02e2 0693      		.dc.w 0x9306
 761               		
 762               	 ;  0 "" 2
 763               	/* #NOAPP */
 764 02e4 00C0      		rjmp .L12
 765               	.LVL37:
 766               	.L32:
 767               	.LBE519:
 768               	.LBE518:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 769               		.loc 2 69 0
 770 02e6 40E0      		ldi r20,lo8(0)
 771 02e8 00C0      		rjmp .L19
 772               	.LBE513:
 773               	.LBE512:
 774               	.LBE522:
 775               	.LBE525:
 776               	.LBE540:
 777               		.cfi_endproc
 778               	.LFE59:
 780               	.global	send_string
 782               	send_string:
 783               	.LFB61:
 784               		.file 7 "utils/utils.h"
   1:utils/utils.h **** void send_string(char* s);
   2:utils/utils.h **** char* concat(char*, char*);
   3:utils/utils.h **** 
   4:utils/utils.h **** void send_string(char* s) {
 785               		.loc 7 4 0
 786               		.cfi_startproc
 787               	.LVL38:
 788 02ea AF92      		push r10
 789               	.LCFI29:
 790               		.cfi_def_cfa_offset 3
 791               		.cfi_offset 10, -2
 792 02ec BF92      		push r11
 793               	.LCFI30:
 794               		.cfi_def_cfa_offset 4
 795               		.cfi_offset 11, -3
 796 02ee CF92      		push r12
 797               	.LCFI31:
 798               		.cfi_def_cfa_offset 5
 799               		.cfi_offset 12, -4
 800 02f0 DF92      		push r13
 801               	.LCFI32:
 802               		.cfi_def_cfa_offset 6
 803               		.cfi_offset 13, -5
 804 02f2 EF92      		push r14
 805               	.LCFI33:
 806               		.cfi_def_cfa_offset 7
 807               		.cfi_offset 14, -6
 808 02f4 FF92      		push r15
 809               	.LCFI34:
 810               		.cfi_def_cfa_offset 8
 811               		.cfi_offset 15, -7
 812 02f6 0F93      		push r16
 813               	.LCFI35:
 814               		.cfi_def_cfa_offset 9
 815               		.cfi_offset 16, -8
 816 02f8 1F93      		push r17
 817               	.LCFI36:
 818               		.cfi_def_cfa_offset 10
 819               		.cfi_offset 17, -9
 820 02fa CF93      		push r28
 821               	.LCFI37:
 822               		.cfi_def_cfa_offset 11
 823               		.cfi_offset 28, -10
 824 02fc DF93      		push r29
 825               	.LCFI38:
 826               		.cfi_def_cfa_offset 12
 827               		.cfi_offset 29, -11
 828               	/* prologue: function */
 829               	/* frame size = 0 */
 830               	/* stack size = 10 */
 831               	.L__stack_usage = 10
   5:utils/utils.h ****   while (*s != '\0' && s != NULL) {  
 832               		.loc 7 5 0
 833 02fe FC01      		movw r30,r24
 834 0300 2081      		ld r18,Z
 835 0302 2223      		tst r18
 836 0304 01F4      		brne .+2
 837 0306 00C0      		rjmp .L34
 838 0308 0097      		sbiw r24,0
 839 030a 01F4      		brne .+2
 840 030c 00C0      		rjmp .L34
   4:utils/utils.h **** void send_string(char* s) {
 841               		.loc 7 4 0
 842 030e 6C01      		movw r12,r24
 843 0310 0894      		sec
 844 0312 C11C      		adc r12,__zero_reg__
 845 0314 D11C      		adc r13,__zero_reg__
 846               	.LBB706:
 847               	.LBB707:
 848               	.LBB708:
 849               	.LBB709:
 850               	.LBB710:
 851               	.LBB711:
 852               	.LBB712:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 853               		.loc 4 57 0
 854 0316 46E0      		ldi r20,lo8(6)
 855               	.LBE712:
 856               	.LBE711:
 857               	.LBE710:
 858               	.LBE709:
 859               	.LBE708:
 860               	.LBB725:
 861               	.LBB726:
 862               	.LBB727:
 863               	.LBB728:
 864               	.LBB729:
 865               	.LBB730:
 866               	.LBB731:
 867               	.LBB732:
 868               	.LBB733:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 869               		.loc 5 220 0
 870 0318 60E0      		ldi r22,lo8(endpoints+24)
 871 031a 70E0      		ldi r23,hi8(endpoints+24)
 872               	.LBE733:
 873               	.LBE732:
 874               	.LBB735:
 875               	.LBB736:
 876               		.loc 4 91 0
 877 031c 30E0      		ldi r19,lo8(ep_in_pipe_buffer)
 878 031e A32E      		mov r10,r19
 879 0320 30E0      		ldi r19,hi8(ep_in_pipe_buffer)
 880 0322 B32E      		mov r11,r19
 881               	.LBE736:
 882               	.LBE735:
 883               	.LBB739:
 884               	.LBB740:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 885               		.loc 2 69 0
 886 0324 C1E0      		ldi r28,lo8(1)
 887 0326 D0E0      		ldi r29,hi8(1)
 888               	.LBE740:
 889               	.LBE739:
 890               	.LBB749:
 891               	.LBB750:
 892               	.LBB751:
 893               	.LBB752:
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 894               		.loc 5 169 0
 895 0328 50E4      		ldi r21,lo8(64)
 896 032a E52E      		mov r14,r21
 897 032c F12C      		mov r15,__zero_reg__
 898               	.LVL39:
 899               	.L72:
 900               	.LBE752:
 901               	.LBE751:
 902               	.LBE750:
 903               	.LBE749:
 904               	.LBE731:
 905               	.LBE730:
 906               	.LBE729:
 907               	.LBE728:
 908               	.LBE727:
 909               	.LBE726:
 910               	.LBE725:
 911               	.LBB805:
 912               	.LBB723:
 913               	.LBB721:
  94:usb/usb_pipe.h **** 						pipe_reset(p->pipe);
  95:usb/usb_pipe.h **** 					}
  96:usb/usb_pipe.h **** 				}
  97:usb/usb_pipe.h **** 			}
  98:usb/usb_pipe.h **** 		}else{
  99:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep) && pipe_can_write(p->pipe) >= 1){
 100:usb/usb_pipe.h **** 				_usb_pipe_ep_start(p, pipe_write_ptr(p->pipe), p->pipe->size);
 101:usb/usb_pipe.h **** 				pipe_done_write(p->pipe);
 102:usb/usb_pipe.h **** 			}
 103:usb/usb_pipe.h **** 		}
 104:usb/usb_pipe.h **** 	}
 105:usb/usb_pipe.h **** }
 106:usb/usb_pipe.h **** 
 107:usb/usb_pipe.h **** static inline void usb_pipe_flush(const USB_Pipe* p) ATTR_ALWAYS_INLINE;
 108:usb/usb_pipe.h **** static inline void usb_pipe_flush(const USB_Pipe* p){
 109:usb/usb_pipe.h **** 	GCC_ASSERT(p->features&PIPE_ENABLE_FLUSH && p->ep&USB_EP_IN);
 110:usb/usb_pipe.h **** 	p->data->flush = 1;
 111:usb/usb_pipe.h **** 	usb_pipe_handle(p);
 112:usb/usb_pipe.h **** }
 113:usb/usb_pipe.h **** 
 114:usb/usb_pipe.h **** static inline bool usb_pipe_flush_done(const USB_Pipe* p) ATTR_ALWAYS_INLINE;
 115:usb/usb_pipe.h **** static inline bool usb_pipe_flush_done(const USB_Pipe* p){
 116:usb/usb_pipe.h **** 	GCC_ASSERT(p->features&PIPE_ENABLE_FLUSH);
 117:usb/usb_pipe.h **** 	return p->data->flush;
 118:usb/usb_pipe.h **** }
 119:usb/usb_pipe.h **** 
 120:usb/usb_pipe.h **** static inline bool usb_pipe_can_write(const USB_Pipe* p) ATTR_ALWAYS_INLINE;
 121:usb/usb_pipe.h **** static inline bool usb_pipe_can_write(const USB_Pipe* p){
 122:usb/usb_pipe.h **** 	bool r;
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 914               		.loc 2 123 0
 915 032e 9FB7      		in r25,__SREG__
 916               	.LVL40:
 917               	.LBB714:
 918               	.LBB715:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 919               		.loc 3 50 0
 920               	/* #APP */
 921               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 922 0330 F894      		cli
 923               	 ;  0 "" 2
 924               	.LVL41:
 925               	/* #NOAPP */
 926               	.LBE715:
 927               	.LBE714:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 928               		.loc 2 124 0
 929 0332 8091 0000 		lds r24,ep_in_data+1
 930 0336 8823      		tst r24
 931 0338 01F0      		breq .L74
 932               	.L64:
 125:usb/usb_pipe.h **** 			r = false;
 933               		.loc 2 125 0
 934 033a 80E0      		ldi r24,lo8(0)
 935               	.L35:
 936               	.LBB717:
 937               	.LBB718:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 938               		.loc 3 70 0
 939 033c 9FBF      		out __SREG__,r25
 940               		.loc 3 71 0
 941               	.LBE718:
 942               	.LBE717:
 943               	.LBE721:
 944               	.LBE723:
 945               	.LBE805:
  20:Framework.h   ****     while (!usb_pipe_can_write(&ep_in));
 946               		.loc 1 20 0
 947 033e 8823      		tst r24
 948 0340 01F0      		breq .L72
 949               	.LVL42:
 950               	.LBB806:
 951               	.LBB807:
 126:usb/usb_pipe.h **** 		}else{
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 128:usb/usb_pipe.h **** 		}
 129:usb/usb_pipe.h **** 	}
 130:usb/usb_pipe.h **** 	return r;
 131:usb/usb_pipe.h **** }
 132:usb/usb_pipe.h **** 
 133:usb/usb_pipe.h **** static inline uint8_t* usb_pipe_write_ptr(const USB_Pipe* p){
 134:usb/usb_pipe.h **** 	return pipe_write_ptr(p->pipe);
 135:usb/usb_pipe.h **** }
 136:usb/usb_pipe.h **** 
 137:usb/usb_pipe.h **** static inline void usb_pipe_done_write(const USB_Pipe* p){
 138:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 139:usb/usb_pipe.h **** 		pipe_done_write(p->pipe);
 140:usb/usb_pipe.h **** 	}
 141:usb/usb_pipe.h **** }
 142:usb/usb_pipe.h **** 
 143:usb/usb_pipe.h **** static inline bool usb_pipe_can_read(const USB_Pipe* p) ATTR_ALWAYS_INLINE;
 144:usb/usb_pipe.h **** static inline bool usb_pipe_can_read(const USB_Pipe* p){
 145:usb/usb_pipe.h **** 	bool r;
 146:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 147:usb/usb_pipe.h **** 		r = pipe_can_read(p->pipe) > 0;
 148:usb/usb_pipe.h **** 	}
 149:usb/usb_pipe.h **** 	return r;
 150:usb/usb_pipe.h **** }
 151:usb/usb_pipe.h **** 
 152:usb/usb_pipe.h **** static inline uint8_t* usb_pipe_read_ptr(const USB_Pipe* p){
 153:usb/usb_pipe.h **** 	return pipe_read_ptr(p->pipe);
 154:usb/usb_pipe.h **** }
 155:usb/usb_pipe.h **** 
 156:usb/usb_pipe.h **** static inline void usb_pipe_done_read(const USB_Pipe* p){
 157:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 158:usb/usb_pipe.h **** 		pipe_done_read(p->pipe);
 159:usb/usb_pipe.h **** 	}
 160:usb/usb_pipe.h **** }
 161:usb/usb_pipe.h **** 
 162:usb/usb_pipe.h **** static inline uint8_t usb_pipe_read_byte(const USB_Pipe* p){
 163:usb/usb_pipe.h **** 	uint8_t r = p->pipe->data->read_ptr[p->data->packet_offset++];
 164:usb/usb_pipe.h **** 	if (p->data->packet_offset == p->pipe->size){
 165:usb/usb_pipe.h **** 		ATOMIC_BLOCK(PIPE_ATOMIC){
 166:usb/usb_pipe.h **** 			p->data->packet_offset = 0;
 167:usb/usb_pipe.h **** 			pipe_done_read(p->pipe);
 168:usb/usb_pipe.h **** 			usb_pipe_handle(p);
 169:usb/usb_pipe.h **** 		}
 170:usb/usb_pipe.h **** 	}
 171:usb/usb_pipe.h **** 	return r;
 172:usb/usb_pipe.h **** }
 173:usb/usb_pipe.h **** 
 174:usb/usb_pipe.h **** static inline void usb_pipe_write_byte(const USB_Pipe* p, uint8_t v){
 175:usb/usb_pipe.h **** 	p->pipe->data->write_ptr[p->data->packet_offset++] = v;
 952               		.loc 2 175 0
 953 0342 8091 0000 		lds r24,ep_in_data+2
 954 0346 9091 0000 		lds r25,ep_in_data+2+1
 955 034a E091 0000 		lds r30,ep_in_pipe_data+2
 956 034e F091 0000 		lds r31,ep_in_pipe_data+2+1
 957 0352 E80F      		add r30,r24
 958 0354 F91F      		adc r31,r25
 959 0356 2083      		st Z,r18
 960 0358 0196      		adiw r24,1
 961 035a 8093 0000 		sts ep_in_data+2,r24
 962 035e 9093 0000 		sts ep_in_data+2+1,r25
 176:usb/usb_pipe.h **** 	if (p->data->packet_offset == p->pipe->size){
 963               		.loc 2 176 0
 964 0362 8034      		cpi r24,64
 965 0364 9105      		cpc r25,__zero_reg__
 966 0366 01F0      		breq .L75
 967               	.LBE807:
 968               	.LBE806:
 969               	.LBE707:
 970               	.LBE706:
 971               		.loc 7 5 0
 972 0368 F601      		movw r30,r12
 973 036a 2191      		ld r18,Z+
 974               	.LVL43:
 975 036c 2223      		tst r18
 976 036e 01F4      		brne .+2
 977 0370 00C0      		rjmp .L34
 978               	.LVL44:
 979               	.L77:
 980               		.loc 7 5 0 is_stmt 0 discriminator 2
 981 0372 C114      		cp r12,__zero_reg__
 982 0374 D104      		cpc r13,__zero_reg__
 983 0376 01F4      		brne .+2
 984 0378 00C0      		rjmp .L34
 985               		.loc 7 5 0
 986 037a 6F01      		movw r12,r30
 987               	.LBB815:
 988               	.LBB812:
 989               	.LBB808:
 990               	.LBB724:
 991               	.LBB722:
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 992               		.loc 2 123 0 is_stmt 1
 993 037c 9FB7      		in r25,__SREG__
 994               	.LVL45:
 995               	.LBB719:
 996               	.LBB716:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 997               		.loc 3 50 0
 998               	/* #APP */
 999               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 1000 037e F894      		cli
 1001               	 ;  0 "" 2
 1002               	/* #NOAPP */
 1003               	.LBE716:
 1004               	.LBE719:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 1005               		.loc 2 124 0
 1006 0380 8091 0000 		lds r24,ep_in_data+1
 1007 0384 8823      		tst r24
 1008 0386 01F4      		brne .L64
 1009               	.LVL46:
 1010               	.L74:
 1011               	.LBB720:
 1012               	.LBB713:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 1013               		.loc 4 57 0
 1014 0388 8091 0000 		lds r24,ep_in_pipe_data+4
 1015 038c 342F      		mov r19,r20
 1016 038e 381B      		sub r19,r24
 1017               	.LBE713:
 1018               	.LBE720:
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 1019               		.loc 2 127 0
 1020 0390 81E0      		ldi r24,lo8(1)
 1021 0392 1316      		cp __zero_reg__,r19
 1022 0394 04F0      		brlt .L35
 1023 0396 00C0      		rjmp .L64
 1024               	.LVL47:
 1025               	.L75:
 1026               	.LBE722:
 1027               	.LBE724:
 1028               	.LBE808:
 1029               	.LBB809:
 1030               	.LBB802:
 1031               	.LBB799:
 1032               	.LBB796:
 177:usb/usb_pipe.h **** 		ATOMIC_BLOCK(PIPE_ATOMIC){
 1033               		.loc 2 177 0
 1034 0398 BFB7      		in r27,__SREG__
 1035               	.LVL48:
 1036               	.LBB787:
 1037               	.LBB788:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 1038               		.loc 3 50 0
 1039               	/* #APP */
 1040               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 1041 039a F894      		cli
 1042               	 ;  0 "" 2
 1043               	.LVL49:
 1044               	/* #NOAPP */
 1045               	.LBE788:
 1046               	.LBE787:
 178:usb/usb_pipe.h **** 			p->data->packet_offset = 0;
 1047               		.loc 2 178 0
 1048 039c 1092 0000 		sts ep_in_data+2,__zero_reg__
 1049 03a0 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 1050               	.LVL50:
 1051               	.LBB789:
 1052               	.LBB790:
  81:usb/pipe.h    **** 	pipe->data->count += 1;
 1053               		.loc 4 81 0
 1054 03a4 8091 0000 		lds r24,ep_in_pipe_data+4
 1055 03a8 8F5F      		subi r24,lo8(-(1))
 1056 03aa 8093 0000 		sts ep_in_pipe_data+4,r24
  82:usb/pipe.h    **** 	pipe->data->write_ptr += pipe->size;
 1057               		.loc 4 82 0
 1058 03ae 8091 0000 		lds r24,ep_in_pipe_data+2
 1059 03b2 9091 0000 		lds r25,ep_in_pipe_data+2+1
 1060 03b6 805C      		subi r24,lo8(-(64))
 1061 03b8 9F4F      		sbci r25,hi8(-(64))
 1062 03ba 8093 0000 		sts ep_in_pipe_data+2,r24
 1063 03be 9093 0000 		sts ep_in_pipe_data+2+1,r25
  84:usb/pipe.h    **** 	if (pipe->data->write_ptr == &pipe->buffer[pipe->slots*pipe->size])
 1064               		.loc 4 84 0
 1065 03c2 F0E0      		ldi r31,hi8(ep_in_pipe_buffer+512)
 1066 03c4 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 1067 03c6 9F07      		cpc r25,r31
 1068 03c8 01F4      		brne .L39
  85:usb/pipe.h    **** 		pipe->data->write_ptr = &pipe->buffer[0];
 1069               		.loc 4 85 0
 1070 03ca A092 0000 		sts ep_in_pipe_data+2,r10
 1071 03ce B092 0000 		sts ep_in_pipe_data+2+1,r11
 1072               	.L39:
 1073               	.LVL51:
 1074               	.LBE790:
 1075               	.LBE789:
 1076               	.LBB791:
 1077               	.LBB784:
 1078               	.LBB781:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1079               		.loc 2 80 0
 1080 03d2 5FB7      		in r21,__SREG__
 1081               	.LVL52:
 1082               	.LBB759:
 1083               	.LBB760:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 1084               		.loc 3 50 0
 1085               	/* #APP */
 1086               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 1087 03d4 F894      		cli
 1088               	 ;  0 "" 2
 1089               	.LVL53:
 1090               	/* #NOAPP */
 1091               	.LBE760:
 1092               	.LBE759:
 1093               	.LBB761:
 1094               	.LBB734:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 1095               		.loc 5 220 0
 1096 03d6 8091 0000 		lds r24,endpoints+24
 1097 03da 8670      		andi r24,lo8(6)
 1098               	.LBE734:
 1099               	.LBE761:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 1100               		.loc 2 82 0
 1101 03dc 01F0      		breq .+2
 1102 03de 00C0      		rjmp .L76
 1103               	.LVL54:
 1104               	.L40:
 1105               	.LBB762:
 1106               	.LBB763:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 1107               		.loc 3 70 0
 1108 03e0 5FBF      		out __SREG__,r21
 1109               		.loc 3 71 0
 1110               	.LVL55:
 1111               	.LBE763:
 1112               	.LBE762:
 1113               	.LBE781:
 1114               	.LBE784:
 1115               	.LBE791:
 1116               	.LBB792:
 1117               	.LBB793:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 1118               		.loc 3 70 0
 1119 03e2 BFBF      		out __SREG__,r27
 1120               		.loc 3 71 0
 1121               	.LBE793:
 1122               	.LBE792:
 1123               	.LBE796:
 1124               	.LBE799:
 1125               	.LBE802:
 1126               	.LBE809:
 1127               	.LBE812:
 1128               	.LBE815:
 1129               		.loc 7 5 0
 1130 03e4 F601      		movw r30,r12
 1131 03e6 2191      		ld r18,Z+
 1132 03e8 2223      		tst r18
 1133 03ea 01F0      		breq .+2
 1134 03ec 00C0      		rjmp .L77
 1135               	.LVL56:
 1136               	.L34:
 1137               	.LBB816:
 1138               	.LBB817:
 1139               	.LBB818:
 1140               	.LBB819:
 110:usb/usb_pipe.h **** 	p->data->flush = 1;
 1141               		.loc 2 110 0
 1142 03ee 81E0      		ldi r24,lo8(1)
 1143 03f0 8093 0000 		sts ep_in_data+1,r24
 1144               	.LVL57:
 1145               	.LBB820:
 1146               	.LBB821:
 1147               	.LBB822:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1148               		.loc 2 80 0
 1149 03f4 2FB7      		in r18,__SREG__
 1150               	.LVL58:
 1151               	.LBB823:
 1152               	.LBB824:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 1153               		.loc 3 50 0
 1154               	/* #APP */
 1155               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 1156 03f6 F894      		cli
 1157               	 ;  0 "" 2
 1158               	.LVL59:
 1159               	/* #NOAPP */
 1160               	.LBE824:
 1161               	.LBE823:
 1162               	.LBB825:
 1163               	.LBB826:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 1164               		.loc 5 220 0
 1165 03f8 8091 0000 		lds r24,endpoints+24
 1166 03fc 8670      		andi r24,lo8(6)
 1167               	.LBE826:
 1168               	.LBE825:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 1169               		.loc 2 82 0
 1170 03fe 01F0      		breq .+2
 1171 0400 00C0      		rjmp .L78
 1172               	.LVL60:
 1173               	.L50:
 1174               	.LBB827:
 1175               	.LBB828:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 1176               		.loc 3 70 0
 1177 0402 2FBF      		out __SREG__,r18
 1178               		.loc 3 71 0
 1179               	.LBE828:
 1180               	.LBE827:
 1181               	.LBE822:
 1182               	.LBE821:
 1183               	.LBE820:
 1184               	.LBE819:
 1185               	.LBE818:
  27:Framework.h   ****     USB.INTFLAGSBSET = USB_TRNIF_bm;
 1186               		.loc 1 27 0
 1187 0404 82E0      		ldi r24,lo8(2)
 1188 0406 E0EC      		ldi r30,lo8(1216)
 1189 0408 F4E0      		ldi r31,hi8(1216)
 1190 040a 8587      		std Z+13,r24
 1191               	.LBB864:
 1192               	.LBB865:
 1193               	.LBB866:
 1194               	.LBB867:
 1195               	.LBB868:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 1196               		.loc 4 57 0
 1197 040c 36E0      		ldi r19,lo8(6)
 1198               	.LVL61:
 1199               	.L59:
 1200               	.LBE868:
 1201               	.LBE867:
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1202               		.loc 2 123 0
 1203 040e 9FB7      		in r25,__SREG__
 1204               	.LVL62:
 1205               	.LBB870:
 1206               	.LBB871:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 1207               		.loc 3 50 0
 1208               	/* #APP */
 1209               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 1210 0410 F894      		cli
 1211               	 ;  0 "" 2
 1212               	.LVL63:
 1213               	/* #NOAPP */
 1214               	.LBE871:
 1215               	.LBE870:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 1216               		.loc 2 124 0
 1217 0412 8091 0000 		lds r24,ep_in_data+1
 1218 0416 8823      		tst r24
 1219 0418 01F4      		brne .+2
 1220 041a 00C0      		rjmp .L79
 1221               	.L66:
 125:usb/usb_pipe.h **** 			r = false;
 1222               		.loc 2 125 0
 1223 041c 80E0      		ldi r24,lo8(0)
 1224               	.L61:
 1225               	.LBB872:
 1226               	.LBB873:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 1227               		.loc 3 70 0
 1228 041e 9FBF      		out __SREG__,r25
 1229               		.loc 3 71 0
 1230               	.LBE873:
 1231               	.LBE872:
 1232               	.LBE866:
 1233               	.LBE865:
 1234               	.LBE864:
  28:Framework.h   ****     while (!usb_pipe_can_write(&ep_in)){
 1235               		.loc 1 28 0
 1236 0420 8823      		tst r24
 1237 0422 01F4      		brne .L33
  29:Framework.h   ****         if (timeout_or_sampling_no_longer_enabled){
 1238               		.loc 1 29 0
 1239 0424 8091 0000 		lds r24,timeout_or_sampling_no_longer_enabled
 1240 0428 8823      		tst r24
 1241 042a 01F0      		breq .L59
 1242               	.LVL64:
 1243               	.LBB877:
 1244               	.LBB878:
 1245               	.LBB879:
  54:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1246               		.loc 2 54 0
 1247 042c 2FB7      		in r18,__SREG__
 1248               	.LVL65:
 1249               	.LBB880:
 1250               	.LBB881:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 1251               		.loc 3 50 0
 1252               	/* #APP */
 1253               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 1254 042e F894      		cli
 1255               	 ;  0 "" 2
 1256               	.LVL66:
 1257               	/* #NOAPP */
 1258               	.LBE881:
 1259               	.LBE880:
 1260               	.LBB882:
 1261               	.LBB883:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 1262               		.loc 4 90 0
 1263 0430 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 1264               		.loc 4 91 0
 1265 0434 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 1266 0436 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 1267 0438 8093 0000 		sts ep_in_pipe_data+2,r24
 1268 043c 9093 0000 		sts ep_in_pipe_data+2+1,r25
 1269 0440 8093 0000 		sts ep_in_pipe_data,r24
 1270 0444 9093 0000 		sts ep_in_pipe_data+1,r25
 1271               	.LVL67:
 1272               	.LBE883:
 1273               	.LBE882:
 1274               	.LBB884:
 1275               	.LBB885:
 158:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 1276               		.loc 5 158 0
 1277 0448 E0E0      		ldi r30,lo8(endpoints+24)
 1278 044a F0E0      		ldi r31,hi8(endpoints+24)
 1279               	/* #APP */
 1280               	 ;  158 "usb/usb.h" 1
 1281 044c 06E0      		ldi r16, 6
 1282 044e 0593      		.dc.w 0x9305
 1283               		
 1284               	 ;  0 "" 2
 159:usb/usb.h     **** 		LACR16(&e->STATUS, USB_EP_BANK_bm);
 1285               		.loc 5 159 0
 1286               	 ;  159 "usb/usb.h" 1
 1287 0450 08E0      		ldi r16, 8
 1288 0452 0693      		.dc.w 0x9306
 1289               		
 1290               	 ;  0 "" 2
 1291               	/* #NOAPP */
 1292               	.LBE885:
 1293               	.LBE884:
  57:usb/usb_pipe.h **** 		p->data->flush = 0;
 1294               		.loc 2 57 0
 1295 0454 1092 0000 		sts ep_in_data+1,__zero_reg__
  58:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
 1296               		.loc 2 58 0
 1297 0458 1092 0000 		sts ep_in_data+2,__zero_reg__
 1298 045c 1092 0000 		sts ep_in_data+2+1,__zero_reg__
  59:usb/usb_pipe.h **** 		p->data->bank = 0;
 1299               		.loc 2 59 0
 1300 0460 1092 0000 		sts ep_in_data,__zero_reg__
 1301               	.LVL68:
 1302               	.LBB886:
 1303               	.LBB887:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 1304               		.loc 3 70 0
 1305 0464 2FBF      		out __SREG__,r18
 1306               		.loc 3 71 0
 1307               	.LVL69:
 1308               	.L33:
 1309               	/* epilogue start */
 1310               	.LBE887:
 1311               	.LBE886:
 1312               	.LBE879:
 1313               	.LBE878:
 1314               	.LBE877:
 1315               	.LBE817:
 1316               	.LBE816:
   6:utils/utils.h ****     send_byte(*s);
   7:utils/utils.h ****     s++;
   8:utils/utils.h ****   }
   9:utils/utils.h ****   break_and_flush();
  10:utils/utils.h ****   s = NULL;
  11:utils/utils.h **** }
 1317               		.loc 7 11 0
 1318 0466 DF91      		pop r29
 1319 0468 CF91      		pop r28
 1320 046a 1F91      		pop r17
 1321 046c 0F91      		pop r16
 1322 046e FF90      		pop r15
 1323 0470 EF90      		pop r14
 1324 0472 DF90      		pop r13
 1325 0474 CF90      		pop r12
 1326 0476 BF90      		pop r11
 1327 0478 AF90      		pop r10
 1328 047a 0895      		ret
 1329               	.LVL70:
 1330               	.L76:
 1331               	.LBB893:
 1332               	.LBB813:
 1333               	.LBB810:
 1334               	.LBB803:
 1335               	.LBB800:
 1336               	.LBB797:
 1337               	.LBB794:
 1338               	.LBB785:
 1339               	.LBB782:
 1340               	.LBB764:
 1341               	.LBB765:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 1342               		.loc 4 51 0
 1343 047c A091 0000 		lds r26,ep_in_pipe_data+4
 1344               	.LBE765:
 1345               	.LBE764:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 1346               		.loc 2 83 0
 1347 0480 1A16      		cp __zero_reg__,r26
 1348 0482 04F0      		brlt .+2
 1349 0484 00C0      		rjmp .L41
 1350               	.LBB766:
 1351               	.LBB767:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 1352               		.loc 4 62 0
 1353 0486 2091 0000 		lds r18,ep_in_pipe_data
 1354 048a 3091 0000 		lds r19,ep_in_pipe_data+1
 1355               	.LVL71:
 1356               	.LBE767:
 1357               	.LBE766:
 1358               	.LBB768:
 1359               	.LBB757:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 1360               		.loc 2 68 0
 1361 048e E091 0000 		lds r30,ep_in_data
 1362               	.LVL72:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 1363               		.loc 2 69 0
 1364 0492 8E2F      		mov r24,r30
 1365 0494 90E0      		ldi r25,lo8(0)
 1366               	.LVL73:
 1367 0496 F1E0      		ldi r31,lo8(1)
 1368 0498 8C17      		cp r24,r28
 1369 049a 9D07      		cpc r25,r29
 1370 049c 01F4      		brne .L42
 1371 049e F0E0      		ldi r31,lo8(0)
 1372               	.L42:
 1373 04a0 F093 0000 		sts ep_in_data,r31
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 1374               		.loc 2 72 0
 1375 04a4 EE23      		tst r30
 1376 04a6 01F4      		brne .L43
 1377               	.LVL74:
 1378               	.LBB754:
 1379               	.LBB755:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1380               		.loc 5 168 0
 1381 04a8 2093 0000 		sts endpoints+28,r18
 1382 04ac 3093 0000 		sts endpoints+28+1,r19
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1383               		.loc 5 169 0
 1384 04b0 E092 0000 		sts endpoints+26,r14
 1385 04b4 F092 0000 		sts endpoints+26+1,r15
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1386               		.loc 5 174 0
 1387 04b8 FB01      		movw r30,r22
 1388               	/* #APP */
 1389               	 ;  174 "usb/usb.h" 1
 1390 04ba 02E2      		ldi r16, 34
 1391 04bc 0693      		.dc.w 0x9306
 1392               		
 1393               	 ;  0 "" 2
 1394               	.LVL75:
 1395               	/* #NOAPP */
 1396               	.L44:
 1397               	.LBE755:
 1398               	.LBE754:
 1399               	.LBE757:
 1400               	.LBE768:
 1401               	.LBB769:
 1402               	.LBB770:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 1403               		.loc 4 72 0
 1404 04be A150      		subi r26,lo8(-(-1))
 1405 04c0 A093 0000 		sts ep_in_pipe_data+4,r26
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 1406               		.loc 4 73 0
 1407 04c4 C901      		movw r24,r18
 1408 04c6 805C      		subi r24,lo8(-(64))
 1409 04c8 9F4F      		sbci r25,hi8(-(64))
 1410 04ca 8093 0000 		sts ep_in_pipe_data,r24
 1411 04ce 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 1412               		.loc 4 75 0
 1413 04d2 F0E0      		ldi r31,hi8(ep_in_pipe_buffer+512)
 1414 04d4 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 1415 04d6 9F07      		cpc r25,r31
 1416 04d8 01F0      		breq .+2
 1417 04da 00C0      		rjmp .L40
 1418               	.LBE770:
 1419               	.LBE769:
 1420               	.LBB771:
 1421               	.LBB737:
 1422               		.loc 4 91 0
 1423 04dc A092 0000 		sts ep_in_pipe_data,r10
 1424 04e0 B092 0000 		sts ep_in_pipe_data+1,r11
 1425               	.LVL76:
 1426 04e4 00C0      		rjmp .L40
 1427               	.LVL77:
 1428               	.L43:
 1429               	.LBE737:
 1430               	.LBE771:
 1431               	.LBB772:
 1432               	.LBB758:
 1433               	.LBB756:
 1434               	.LBB753:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1435               		.loc 5 168 0
 1436 04e6 2093 0000 		sts endpoints+20,r18
 1437 04ea 3093 0000 		sts endpoints+20+1,r19
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1438               		.loc 5 169 0
 1439 04ee E092 0000 		sts endpoints+18,r14
 1440 04f2 F092 0000 		sts endpoints+18+1,r15
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 1441               		.loc 5 176 0
 1442 04f6 FB01      		movw r30,r22
 1443               	/* #APP */
 1444               	 ;  176 "usb/usb.h" 1
 1445 04f8 04E1      		ldi r16, 20
 1446 04fa 0693      		.dc.w 0x9306
 1447               		
 1448               	 ;  0 "" 2
 1449               	/* #NOAPP */
 1450 04fc 00C0      		rjmp .L44
 1451               	.LVL78:
 1452               	.L41:
 1453               	.LBE753:
 1454               	.LBE756:
 1455               	.LBE758:
 1456               	.LBE772:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 1457               		.loc 2 87 0
 1458 04fe 8091 0000 		lds r24,ep_in_data+1
 1459 0502 8130      		cpi r24,lo8(1)
 1460 0504 01F0      		breq .L80
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 1461               		.loc 2 91 0
 1462 0506 8230      		cpi r24,lo8(2)
 1463 0508 01F0      		breq .+2
 1464 050a 00C0      		rjmp .L40
 1465               	.LVL79:
 1466               	.LBB773:
 1467               	.LBB774:
 1468               	.LBB775:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 1469               		.loc 5 228 0
 1470 050c 8091 0000 		lds r24,endpoints+24
 1471 0510 8670      		andi r24,lo8(6)
 1472               	.LBE775:
 1473               	.LBE774:
 1474               	.LBE773:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 1475               		.loc 2 91 0
 1476 0512 8630      		cpi r24,lo8(6)
 1477 0514 01F0      		breq .+2
 1478 0516 00C0      		rjmp .L40
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 1479               		.loc 2 92 0
 1480 0518 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 1481               		.loc 2 93 0
 1482 051c 1092 0000 		sts ep_in_data+2,__zero_reg__
 1483 0520 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 1484               	.LBB776:
 1485               	.LBB738:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 1486               		.loc 4 90 0
 1487 0524 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 1488               		.loc 4 91 0
 1489 0528 A092 0000 		sts ep_in_pipe_data+2,r10
 1490 052c B092 0000 		sts ep_in_pipe_data+2+1,r11
 1491 0530 A092 0000 		sts ep_in_pipe_data,r10
 1492 0534 B092 0000 		sts ep_in_pipe_data+1,r11
 1493               	.LVL80:
 1494 0538 00C0      		rjmp .L40
 1495               	.LVL81:
 1496               	.L80:
 1497               	.LBE738:
 1498               	.LBE776:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 1499               		.loc 2 88 0
 1500 053a 22E0      		ldi r18,lo8(2)
 1501               	.LVL82:
 1502 053c 2093 0000 		sts ep_in_data+1,r18
 1503               	.LBB777:
 1504               	.LBB778:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 1505               		.loc 4 62 0
 1506 0540 A091 0000 		lds r26,ep_in_pipe_data
 1507 0544 1091 0000 		lds r17,ep_in_pipe_data+1
 1508               	.LBE778:
 1509               	.LBE777:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 1510               		.loc 2 90 0
 1511 0548 2091 0000 		lds r18,ep_in_data+2
 1512 054c 3091 0000 		lds r19,ep_in_data+2+1
 1513               	.LVL83:
 1514               	.LBB779:
 1515               	.LBB747:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 1516               		.loc 2 68 0
 1517 0550 F091 0000 		lds r31,ep_in_data
 1518               	.LVL84:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 1519               		.loc 2 69 0
 1520 0554 8F2F      		mov r24,r31
 1521 0556 90E0      		ldi r25,lo8(0)
 1522 0558 E1E0      		ldi r30,lo8(1)
 1523               	.LVL85:
 1524 055a 8C17      		cp r24,r28
 1525 055c 9D07      		cpc r25,r29
 1526 055e 01F4      		brne .L47
 1527 0560 E0E0      		ldi r30,lo8(0)
 1528               	.L47:
 1529 0562 E093 0000 		sts ep_in_data,r30
 1530               	.LBB741:
 1531               	.LBB742:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1532               		.loc 5 168 0
 1533 0566 8A2F      		mov r24,r26
 1534 0568 912F      		mov r25,r17
 1535               	.LBE742:
 1536               	.LBE741:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 1537               		.loc 2 72 0
 1538 056a FF23      		tst r31
 1539 056c 01F0      		breq .+2
 1540 056e 00C0      		rjmp .L48
 1541               	.LVL86:
 1542               	.LBB744:
 1543               	.LBB743:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1544               		.loc 5 168 0
 1545 0570 8093 0000 		sts endpoints+28,r24
 1546 0574 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1547               		.loc 5 169 0
 1548 0578 2093 0000 		sts endpoints+26,r18
 1549 057c 3093 0000 		sts endpoints+26+1,r19
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1550               		.loc 5 174 0
 1551 0580 FB01      		movw r30,r22
 1552               	/* #APP */
 1553               	 ;  174 "usb/usb.h" 1
 1554 0582 02E2      		ldi r16, 34
 1555 0584 0693      		.dc.w 0x9306
 1556               		
 1557               	 ;  0 "" 2
 1558               	/* #NOAPP */
 1559 0586 00C0      		rjmp .L40
 1560               	.LVL87:
 1561               	.L79:
 1562               	.LBE743:
 1563               	.LBE744:
 1564               	.LBE747:
 1565               	.LBE779:
 1566               	.LBE782:
 1567               	.LBE785:
 1568               	.LBE794:
 1569               	.LBE797:
 1570               	.LBE800:
 1571               	.LBE803:
 1572               	.LBE810:
 1573               	.LBE813:
 1574               	.LBE893:
 1575               	.LBB894:
 1576               	.LBB891:
 1577               	.LBB888:
 1578               	.LBB876:
 1579               	.LBB875:
 1580               	.LBB874:
 1581               	.LBB869:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 1582               		.loc 4 57 0
 1583 0588 8091 0000 		lds r24,ep_in_pipe_data+4
 1584 058c 232F      		mov r18,r19
 1585 058e 281B      		sub r18,r24
 1586               	.LBE869:
 1587               	.LBE874:
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 1588               		.loc 2 127 0
 1589 0590 81E0      		ldi r24,lo8(1)
 1590 0592 1216      		cp __zero_reg__,r18
 1591 0594 04F4      		brge .+2
 1592 0596 00C0      		rjmp .L61
 1593 0598 00C0      		rjmp .L66
 1594               	.LVL88:
 1595               	.L78:
 1596               	.LBE875:
 1597               	.LBE876:
 1598               	.LBE888:
 1599               	.LBB889:
 1600               	.LBB862:
 1601               	.LBB860:
 1602               	.LBB858:
 1603               	.LBB856:
 1604               	.LBB829:
 1605               	.LBB830:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 1606               		.loc 4 51 0
 1607 059a 3091 0000 		lds r19,ep_in_pipe_data+4
 1608               	.LBE830:
 1609               	.LBE829:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 1610               		.loc 2 83 0
 1611 059e 1316      		cp __zero_reg__,r19
 1612 05a0 04F0      		brlt .+2
 1613 05a2 00C0      		rjmp .L51
 1614               	.LBB831:
 1615               	.LBB832:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 1616               		.loc 4 62 0
 1617 05a4 8091 0000 		lds r24,ep_in_pipe_data
 1618 05a8 9091 0000 		lds r25,ep_in_pipe_data+1
 1619               	.LVL89:
 1620               	.LBE832:
 1621               	.LBE831:
 1622               	.LBB833:
 1623               	.LBB834:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 1624               		.loc 2 68 0
 1625 05ac 4091 0000 		lds r20,ep_in_data
 1626               	.LVL90:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 1627               		.loc 2 69 0
 1628 05b0 51E0      		ldi r21,lo8(1)
 1629 05b2 4130      		cpi r20,lo8(1)
 1630 05b4 01F4      		brne .L52
 1631 05b6 50E0      		ldi r21,lo8(0)
 1632               	.L52:
 1633 05b8 5093 0000 		sts ep_in_data,r21
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 1634               		.loc 2 72 0
 1635 05bc 4423      		tst r20
 1636 05be 01F4      		brne .L53
 1637               	.LVL91:
 1638               	.LBB835:
 1639               	.LBB836:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1640               		.loc 5 168 0
 1641 05c0 8093 0000 		sts endpoints+28,r24
 1642 05c4 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1643               		.loc 5 169 0
 1644 05c8 40E4      		ldi r20,lo8(64)
 1645 05ca 50E0      		ldi r21,hi8(64)
 1646 05cc 4093 0000 		sts endpoints+26,r20
 1647 05d0 5093 0000 		sts endpoints+26+1,r21
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1648               		.loc 5 174 0
 1649 05d4 E0E0      		ldi r30,lo8(endpoints+24)
 1650 05d6 F0E0      		ldi r31,hi8(endpoints+24)
 1651               	.LVL92:
 1652               	/* #APP */
 1653               	 ;  174 "usb/usb.h" 1
 1654 05d8 02E2      		ldi r16, 34
 1655 05da 0693      		.dc.w 0x9306
 1656               		
 1657               	 ;  0 "" 2
 1658               	.LVL93:
 1659               	/* #NOAPP */
 1660               	.L54:
 1661               	.LBE836:
 1662               	.LBE835:
 1663               	.LBE834:
 1664               	.LBE833:
 1665               	.LBB840:
 1666               	.LBB841:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 1667               		.loc 4 72 0
 1668 05dc 3150      		subi r19,lo8(-(-1))
 1669 05de 3093 0000 		sts ep_in_pipe_data+4,r19
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 1670               		.loc 4 73 0
 1671 05e2 805C      		subi r24,lo8(-(64))
 1672 05e4 9F4F      		sbci r25,hi8(-(64))
 1673 05e6 8093 0000 		sts ep_in_pipe_data,r24
 1674 05ea 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 1675               		.loc 4 75 0
 1676 05ee F0E0      		ldi r31,hi8(ep_in_pipe_buffer+512)
 1677 05f0 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 1678 05f2 9F07      		cpc r25,r31
 1679 05f4 01F0      		breq .+2
 1680 05f6 00C0      		rjmp .L50
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
 1681               		.loc 4 76 0
 1682 05f8 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 1683 05fa 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 1684 05fc 8093 0000 		sts ep_in_pipe_data,r24
 1685 0600 9093 0000 		sts ep_in_pipe_data+1,r25
 1686 0604 00C0      		rjmp .L50
 1687               	.LVL94:
 1688               	.L48:
 1689               	.LBE841:
 1690               	.LBE840:
 1691               	.LBE856:
 1692               	.LBE858:
 1693               	.LBE860:
 1694               	.LBE862:
 1695               	.LBE889:
 1696               	.LBE891:
 1697               	.LBE894:
 1698               	.LBB895:
 1699               	.LBB814:
 1700               	.LBB811:
 1701               	.LBB804:
 1702               	.LBB801:
 1703               	.LBB798:
 1704               	.LBB795:
 1705               	.LBB786:
 1706               	.LBB783:
 1707               	.LBB780:
 1708               	.LBB748:
 1709               	.LBB745:
 1710               	.LBB746:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1711               		.loc 5 168 0
 1712 0606 8093 0000 		sts endpoints+20,r24
 1713 060a 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1714               		.loc 5 169 0
 1715 060e 2093 0000 		sts endpoints+18,r18
 1716 0612 3093 0000 		sts endpoints+18+1,r19
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 1717               		.loc 5 176 0
 1718 0616 FB01      		movw r30,r22
 1719               	/* #APP */
 1720               	 ;  176 "usb/usb.h" 1
 1721 0618 04E1      		ldi r16, 20
 1722 061a 0693      		.dc.w 0x9306
 1723               		
 1724               	 ;  0 "" 2
 1725               	/* #NOAPP */
 1726 061c 00C0      		rjmp .L40
 1727               	.LVL95:
 1728               	.L53:
 1729               	.LBE746:
 1730               	.LBE745:
 1731               	.LBE748:
 1732               	.LBE780:
 1733               	.LBE783:
 1734               	.LBE786:
 1735               	.LBE795:
 1736               	.LBE798:
 1737               	.LBE801:
 1738               	.LBE804:
 1739               	.LBE811:
 1740               	.LBE814:
 1741               	.LBE895:
 1742               	.LBB896:
 1743               	.LBB892:
 1744               	.LBB890:
 1745               	.LBB863:
 1746               	.LBB861:
 1747               	.LBB859:
 1748               	.LBB857:
 1749               	.LBB842:
 1750               	.LBB839:
 1751               	.LBB837:
 1752               	.LBB838:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1753               		.loc 5 168 0
 1754 061e 8093 0000 		sts endpoints+20,r24
 1755 0622 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1756               		.loc 5 169 0
 1757 0626 40E4      		ldi r20,lo8(64)
 1758 0628 50E0      		ldi r21,hi8(64)
 1759               	.LVL96:
 1760 062a 4093 0000 		sts endpoints+18,r20
 1761 062e 5093 0000 		sts endpoints+18+1,r21
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 1762               		.loc 5 176 0
 1763 0632 E0E0      		ldi r30,lo8(endpoints+24)
 1764 0634 F0E0      		ldi r31,hi8(endpoints+24)
 1765               	/* #APP */
 1766               	 ;  176 "usb/usb.h" 1
 1767 0636 04E1      		ldi r16, 20
 1768 0638 0693      		.dc.w 0x9306
 1769               		
 1770               	 ;  0 "" 2
 1771               	/* #NOAPP */
 1772 063a 00C0      		rjmp .L54
 1773               	.LVL97:
 1774               	.L51:
 1775               	.LBE838:
 1776               	.LBE837:
 1777               	.LBE839:
 1778               	.LBE842:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 1779               		.loc 2 87 0
 1780 063c 8091 0000 		lds r24,ep_in_data+1
 1781 0640 8130      		cpi r24,lo8(1)
 1782 0642 01F0      		breq .L81
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 1783               		.loc 2 91 0
 1784 0644 8230      		cpi r24,lo8(2)
 1785 0646 01F0      		breq .+2
 1786 0648 00C0      		rjmp .L50
 1787               	.LVL98:
 1788               	.LBB843:
 1789               	.LBB844:
 1790               	.LBB845:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 1791               		.loc 5 228 0
 1792 064a 8091 0000 		lds r24,endpoints+24
 1793 064e 8670      		andi r24,lo8(6)
 1794               	.LBE845:
 1795               	.LBE844:
 1796               	.LBE843:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 1797               		.loc 2 91 0
 1798 0650 8630      		cpi r24,lo8(6)
 1799 0652 01F0      		breq .+2
 1800 0654 00C0      		rjmp .L50
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 1801               		.loc 2 92 0
 1802 0656 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 1803               		.loc 2 93 0
 1804 065a 1092 0000 		sts ep_in_data+2,__zero_reg__
 1805 065e 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 1806               	.LBB846:
 1807               	.LBB847:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 1808               		.loc 4 90 0
 1809 0662 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 1810               		.loc 4 91 0
 1811 0666 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 1812 0668 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 1813 066a 8093 0000 		sts ep_in_pipe_data+2,r24
 1814 066e 9093 0000 		sts ep_in_pipe_data+2+1,r25
 1815 0672 8093 0000 		sts ep_in_pipe_data,r24
 1816 0676 9093 0000 		sts ep_in_pipe_data+1,r25
 1817               	.LVL99:
 1818 067a 00C0      		rjmp .L50
 1819               	.LVL100:
 1820               	.L81:
 1821               	.LBE847:
 1822               	.LBE846:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 1823               		.loc 2 88 0
 1824 067c 82E0      		ldi r24,lo8(2)
 1825 067e 8093 0000 		sts ep_in_data+1,r24
 1826               	.LBB848:
 1827               	.LBB849:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 1828               		.loc 4 62 0
 1829 0682 6091 0000 		lds r22,ep_in_pipe_data
 1830 0686 3091 0000 		lds r19,ep_in_pipe_data+1
 1831               	.LBE849:
 1832               	.LBE848:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 1833               		.loc 2 90 0
 1834 068a 4091 0000 		lds r20,ep_in_data+2
 1835 068e 5091 0000 		lds r21,ep_in_data+2+1
 1836               	.LVL101:
 1837               	.LBB850:
 1838               	.LBB851:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 1839               		.loc 2 68 0
 1840 0692 8091 0000 		lds r24,ep_in_data
 1841               	.LVL102:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 1842               		.loc 2 69 0
 1843 0696 91E0      		ldi r25,lo8(1)
 1844 0698 8130      		cpi r24,lo8(1)
 1845 069a 01F4      		brne .L57
 1846 069c 90E0      		ldi r25,lo8(0)
 1847               	.L57:
 1848 069e 9093 0000 		sts ep_in_data,r25
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 1849               		.loc 2 72 0
 1850 06a2 8823      		tst r24
 1851 06a4 01F4      		brne .L58
 1852               	.LVL103:
 1853               	.LBB852:
 1854               	.LBB853:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1855               		.loc 5 168 0
 1856 06a6 862F      		mov r24,r22
 1857 06a8 932F      		mov r25,r19
 1858 06aa 8093 0000 		sts endpoints+28,r24
 1859 06ae 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1860               		.loc 5 169 0
 1861 06b2 4093 0000 		sts endpoints+26,r20
 1862 06b6 5093 0000 		sts endpoints+26+1,r21
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1863               		.loc 5 174 0
 1864 06ba E0E0      		ldi r30,lo8(endpoints+24)
 1865 06bc F0E0      		ldi r31,hi8(endpoints+24)
 1866               	.LVL104:
 1867               	/* #APP */
 1868               	 ;  174 "usb/usb.h" 1
 1869 06be 02E2      		ldi r16, 34
 1870 06c0 0693      		.dc.w 0x9306
 1871               		
 1872               	 ;  0 "" 2
 1873               	/* #NOAPP */
 1874 06c2 00C0      		rjmp .L50
 1875               	.LVL105:
 1876               	.L58:
 1877               	.LBE853:
 1878               	.LBE852:
 1879               	.LBB854:
 1880               	.LBB855:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1881               		.loc 5 168 0
 1882 06c4 862F      		mov r24,r22
 1883 06c6 932F      		mov r25,r19
 1884 06c8 8093 0000 		sts endpoints+20,r24
 1885 06cc 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1886               		.loc 5 169 0
 1887 06d0 4093 0000 		sts endpoints+18,r20
 1888 06d4 5093 0000 		sts endpoints+18+1,r21
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 1889               		.loc 5 176 0
 1890 06d8 E0E0      		ldi r30,lo8(endpoints+24)
 1891 06da F0E0      		ldi r31,hi8(endpoints+24)
 1892               	/* #APP */
 1893               	 ;  176 "usb/usb.h" 1
 1894 06dc 04E1      		ldi r16, 20
 1895 06de 0693      		.dc.w 0x9306
 1896               		
 1897               	 ;  0 "" 2
 1898               	/* #NOAPP */
 1899 06e0 00C0      		rjmp .L50
 1900               	.LBE855:
 1901               	.LBE854:
 1902               	.LBE851:
 1903               	.LBE850:
 1904               	.LBE857:
 1905               	.LBE859:
 1906               	.LBE861:
 1907               	.LBE863:
 1908               	.LBE890:
 1909               	.LBE892:
 1910               	.LBE896:
 1911               		.cfi_endproc
 1912               	.LFE61:
 1914               	.global	concat
 1916               	concat:
 1917               	.LFB62:
  12:utils/utils.h **** 
  13:utils/utils.h **** char* concat(char *s1, char *s2)
  14:utils/utils.h **** {
 1918               		.loc 7 14 0
 1919               		.cfi_startproc
 1920               	.LVL106:
 1921 06e2 EF92      		push r14
 1922               	.LCFI39:
 1923               		.cfi_def_cfa_offset 3
 1924               		.cfi_offset 14, -2
 1925 06e4 FF92      		push r15
 1926               	.LCFI40:
 1927               		.cfi_def_cfa_offset 4
 1928               		.cfi_offset 15, -3
 1929 06e6 0F93      		push r16
 1930               	.LCFI41:
 1931               		.cfi_def_cfa_offset 5
 1932               		.cfi_offset 16, -4
 1933 06e8 1F93      		push r17
 1934               	.LCFI42:
 1935               		.cfi_def_cfa_offset 6
 1936               		.cfi_offset 17, -5
 1937 06ea CF93      		push r28
 1938               	.LCFI43:
 1939               		.cfi_def_cfa_offset 7
 1940               		.cfi_offset 28, -6
 1941 06ec DF93      		push r29
 1942               	.LCFI44:
 1943               		.cfi_def_cfa_offset 8
 1944               		.cfi_offset 29, -7
 1945               	/* prologue: function */
 1946               	/* frame size = 0 */
 1947               	/* stack size = 6 */
 1948               	.L__stack_usage = 6
 1949 06ee F82E      		mov r15,r24
 1950 06f0 E92E      		mov r14,r25
 1951 06f2 162F      		mov r17,r22
 1952 06f4 072F      		mov r16,r23
  15:utils/utils.h ****     //string concatenation -- not needed now, but might prove useful later
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 1953               		.loc 7 16 0
 1954 06f6 A82F      		mov r26,r24
 1955 06f8 B92F      		mov r27,r25
 1956 06fa ED01      		movw r28,r26
 1957 06fc 0990      		ld __tmp_reg__,Y+
 1958 06fe 0020      		tst __tmp_reg__
 1959 0700 01F4      		brne .-6
 1960 0702 9E01      		movw r18,r28
 1961 0704 E62F      		mov r30,r22
 1962 0706 F72F      		mov r31,r23
 1963 0708 EF01      		movw r28,r30
 1964 070a 0990      		ld __tmp_reg__,Y+
 1965 070c 0020      		tst __tmp_reg__
 1966 070e 01F4      		brne .-6
 1967 0710 CE01      		movw r24,r28
 1968               	.LVL107:
 1969 0712 0197      		sbiw r24,1
 1970 0714 8E1B      		sub r24,r30
 1971 0716 9F0B      		sbc r25,r31
 1972 0718 8A1B      		sub r24,r26
 1973 071a 9B0B      		sbc r25,r27
 1974 071c 820F      		add r24,r18
 1975 071e 931F      		adc r25,r19
 1976 0720 0E94 0000 		call malloc
 1977               	.LVL108:
 1978 0724 D82F      		mov r29,r24
 1979 0726 C92F      		mov r28,r25
 1980               	.LVL109:
  17:utils/utils.h ****     //should also check for memory allocation errors here
  18:utils/utils.h ****     strcpy(result, s1);
 1981               		.loc 7 18 0
 1982 0728 6F2D      		mov r22,r15
 1983 072a 7E2D      		mov r23,r14
 1984 072c 0E94 0000 		call strcpy
 1985               	.LVL110:
  19:utils/utils.h ****     strcat(result, s2);
 1986               		.loc 7 19 0
 1987 0730 8D2F      		mov r24,r29
 1988 0732 9C2F      		mov r25,r28
 1989 0734 612F      		mov r22,r17
 1990 0736 702F      		mov r23,r16
 1991 0738 0E94 0000 		call strcat
  20:utils/utils.h ****     return result;
  21:utils/utils.h **** }
 1992               		.loc 7 21 0
 1993 073c 8D2F      		mov r24,r29
 1994 073e 9C2F      		mov r25,r28
 1995               	/* epilogue start */
 1996 0740 DF91      		pop r29
 1997               	.LVL111:
 1998 0742 CF91      		pop r28
 1999               	.LVL112:
 2000 0744 1F91      		pop r17
 2001 0746 0F91      		pop r16
 2002 0748 FF90      		pop r15
 2003 074a EF90      		pop r14
 2004 074c 0895      		ret
 2005               		.cfi_endproc
 2006               	.LFE62:
 2008               	.global	distance
 2010               	distance:
 2011               	.LFB63:
 2012               		.file 8 "nmea/nmea.h"
   1:nmea/nmea.h   **** #include <avr/io.h>
   2:nmea/nmea.h   **** #include <stdlib.h>
   3:nmea/nmea.h   **** #include <string.h>
   4:nmea/nmea.h   **** 
   5:nmea/nmea.h   **** //sample nmea strings for testing parser
   6:nmea/nmea.h   **** // double lat = 42.292747;
   7:nmea/nmea.h   **** // double lng = -71.264622;
   8:nmea/nmea.h   **** double lat = 43.0;
   9:nmea/nmea.h   **** double lng = -73.0;
  10:nmea/nmea.h   **** double max_dist = .200;
  11:nmea/nmea.h   **** 
  12:nmea/nmea.h   **** typedef struct _latlng {
  13:nmea/nmea.h   ****   double lat;
  14:nmea/nmea.h   ****   double lng;
  15:nmea/nmea.h   ****   double dist;
  16:nmea/nmea.h   ****   uint8_t valid;
  17:nmea/nmea.h   ****   uint8_t roaming;
  18:nmea/nmea.h   ****   char* sms;
  19:nmea/nmea.h   **** } latlng;
  20:nmea/nmea.h   **** 
  21:nmea/nmea.h   **** void parse_nmea(char* buff, latlng* gps);
  22:nmea/nmea.h   **** extern void parse_nmea_string(char *s, latlng *gps);
  23:nmea/nmea.h   **** double distance(double gpslat, double gpslng);
  24:nmea/nmea.h   **** 
  25:nmea/nmea.h   **** #define d2r (M_PI / 180.0)
  26:nmea/nmea.h   **** 
  27:nmea/nmea.h   **** //calculate distance, assuming earth is spherical
  28:nmea/nmea.h   **** double distance(double gpslat, double gpslng) {
 2013               		.loc 8 28 0
 2014               		.cfi_startproc
 2015               	.LVL113:
 2016 074e 2F92      		push r2
 2017               	.LCFI45:
 2018               		.cfi_def_cfa_offset 3
 2019               		.cfi_offset 2, -2
 2020 0750 3F92      		push r3
 2021               	.LCFI46:
 2022               		.cfi_def_cfa_offset 4
 2023               		.cfi_offset 3, -3
 2024 0752 4F92      		push r4
 2025               	.LCFI47:
 2026               		.cfi_def_cfa_offset 5
 2027               		.cfi_offset 4, -4
 2028 0754 5F92      		push r5
 2029               	.LCFI48:
 2030               		.cfi_def_cfa_offset 6
 2031               		.cfi_offset 5, -5
 2032 0756 6F92      		push r6
 2033               	.LCFI49:
 2034               		.cfi_def_cfa_offset 7
 2035               		.cfi_offset 6, -6
 2036 0758 7F92      		push r7
 2037               	.LCFI50:
 2038               		.cfi_def_cfa_offset 8
 2039               		.cfi_offset 7, -7
 2040 075a 8F92      		push r8
 2041               	.LCFI51:
 2042               		.cfi_def_cfa_offset 9
 2043               		.cfi_offset 8, -8
 2044 075c 9F92      		push r9
 2045               	.LCFI52:
 2046               		.cfi_def_cfa_offset 10
 2047               		.cfi_offset 9, -9
 2048 075e AF92      		push r10
 2049               	.LCFI53:
 2050               		.cfi_def_cfa_offset 11
 2051               		.cfi_offset 10, -10
 2052 0760 BF92      		push r11
 2053               	.LCFI54:
 2054               		.cfi_def_cfa_offset 12
 2055               		.cfi_offset 11, -11
 2056 0762 CF92      		push r12
 2057               	.LCFI55:
 2058               		.cfi_def_cfa_offset 13
 2059               		.cfi_offset 12, -12
 2060 0764 DF92      		push r13
 2061               	.LCFI56:
 2062               		.cfi_def_cfa_offset 14
 2063               		.cfi_offset 13, -13
 2064 0766 EF92      		push r14
 2065               	.LCFI57:
 2066               		.cfi_def_cfa_offset 15
 2067               		.cfi_offset 14, -14
 2068 0768 FF92      		push r15
 2069               	.LCFI58:
 2070               		.cfi_def_cfa_offset 16
 2071               		.cfi_offset 15, -15
 2072 076a 0F93      		push r16
 2073               	.LCFI59:
 2074               		.cfi_def_cfa_offset 17
 2075               		.cfi_offset 16, -16
 2076 076c 1F93      		push r17
 2077               	.LCFI60:
 2078               		.cfi_def_cfa_offset 18
 2079               		.cfi_offset 17, -17
 2080 076e CF93      		push r28
 2081               	.LCFI61:
 2082               		.cfi_def_cfa_offset 19
 2083               		.cfi_offset 28, -18
 2084 0770 DF93      		push r29
 2085               	.LCFI62:
 2086               		.cfi_def_cfa_offset 20
 2087               		.cfi_offset 29, -19
 2088 0772 CDB7      		in r28,__SP_L__
 2089 0774 DEB7      		in r29,__SP_H__
 2090 0776 2697      		sbiw r28,6
 2091               	.LCFI63:
 2092               		.cfi_def_cfa 28, 26
 2093 0778 CDBF      		out __SP_L__,r28
 2094 077a DEBF      		out __SP_H__,r29
 2095               	/* prologue: function */
 2096               	/* frame size = 6 */
 2097               	/* stack size = 24 */
 2098               	.L__stack_usage = 24
 2099 077c 4B01      		movw r8,r22
 2100 077e 5C01      		movw r10,r24
 2101 0780 2983      		std Y+1,r18
 2102 0782 3A83      		std Y+2,r19
 2103 0784 4B83      		std Y+3,r20
 2104 0786 5C83      		std Y+4,r21
 2105               	.LVL114:
  29:nmea/nmea.h   ****     double dlong = (gpslng - lng) * d2r;
  30:nmea/nmea.h   ****     double dlat = (gpslat - lat) * d2r;
 2106               		.loc 8 30 0
 2107 0788 C090 0000 		lds r12,lat
 2108 078c D090 0000 		lds r13,lat+1
 2109 0790 E090 0000 		lds r14,lat+2
 2110 0794 F090 0000 		lds r15,lat+3
 2111               	.LVL115:
 2112 0798 A701      		movw r20,r14
 2113 079a 9601      		movw r18,r12
 2114               	.LVL116:
 2115 079c 0E94 0000 		call __subsf3
 2116               	.LVL117:
 2117 07a0 25E3      		ldi r18,lo8(0x3c8efa35)
 2118 07a2 3AEF      		ldi r19,hi8(0x3c8efa35)
 2119 07a4 4EE8      		ldi r20,hlo8(0x3c8efa35)
 2120 07a6 5CE3      		ldi r21,hhi8(0x3c8efa35)
 2121 07a8 0E94 0000 		call __mulsf3
  31:nmea/nmea.h   ****     double a = pow(sin(dlat/2.0), 2) + cos(lat*d2r) * cos(gpslat*d2r) * pow(sin(dlong/2.0), 2);
 2122               		.loc 8 31 0
 2123 07ac 20E0      		ldi r18,lo8(0x3f000000)
 2124 07ae 30E0      		ldi r19,hi8(0x3f000000)
 2125 07b0 40E0      		ldi r20,hlo8(0x3f000000)
 2126 07b2 5FE3      		ldi r21,hhi8(0x3f000000)
 2127 07b4 0E94 0000 		call __mulsf3
 2128 07b8 0E94 0000 		call sin
 2129 07bc 9B01      		movw r18,r22
 2130 07be AC01      		movw r20,r24
 2131 07c0 0E94 0000 		call __mulsf3
 2132 07c4 362E      		mov r3,r22
 2133 07c6 272E      		mov r2,r23
 2134 07c8 8D83      		std Y+5,r24
 2135 07ca 9E83      		std Y+6,r25
 2136 07cc C701      		movw r24,r14
 2137 07ce B601      		movw r22,r12
 2138 07d0 25E3      		ldi r18,lo8(0x3c8efa35)
 2139 07d2 3AEF      		ldi r19,hi8(0x3c8efa35)
 2140 07d4 4EE8      		ldi r20,hlo8(0x3c8efa35)
 2141 07d6 5CE3      		ldi r21,hhi8(0x3c8efa35)
 2142 07d8 0E94 0000 		call __mulsf3
 2143 07dc 0E94 0000 		call cos
 2144 07e0 7B01      		movw r14,r22
 2145 07e2 8C01      		movw r16,r24
 2146 07e4 C501      		movw r24,r10
 2147 07e6 B401      		movw r22,r8
 2148 07e8 25E3      		ldi r18,lo8(0x3c8efa35)
 2149 07ea 3AEF      		ldi r19,hi8(0x3c8efa35)
 2150 07ec 4EE8      		ldi r20,hlo8(0x3c8efa35)
 2151 07ee 5CE3      		ldi r21,hhi8(0x3c8efa35)
 2152 07f0 0E94 0000 		call __mulsf3
 2153 07f4 0E94 0000 		call cos
 2154 07f8 2B01      		movw r4,r22
 2155 07fa 3C01      		movw r6,r24
  29:nmea/nmea.h   ****     double dlong = (gpslng - lng) * d2r;
 2156               		.loc 8 29 0
 2157 07fc 6981      		ldd r22,Y+1
 2158 07fe 7A81      		ldd r23,Y+2
 2159 0800 8B81      		ldd r24,Y+3
 2160 0802 9C81      		ldd r25,Y+4
 2161 0804 2091 0000 		lds r18,lng
 2162 0808 3091 0000 		lds r19,lng+1
 2163 080c 4091 0000 		lds r20,lng+2
 2164 0810 5091 0000 		lds r21,lng+3
 2165               	.LVL118:
 2166 0814 0E94 0000 		call __subsf3
 2167               	.LVL119:
 2168 0818 25E3      		ldi r18,lo8(0x3c8efa35)
 2169 081a 3AEF      		ldi r19,hi8(0x3c8efa35)
 2170 081c 4EE8      		ldi r20,hlo8(0x3c8efa35)
 2171 081e 5CE3      		ldi r21,hhi8(0x3c8efa35)
 2172 0820 0E94 0000 		call __mulsf3
 2173               		.loc 8 31 0
 2174 0824 20E0      		ldi r18,lo8(0x3f000000)
 2175 0826 30E0      		ldi r19,hi8(0x3f000000)
 2176 0828 40E0      		ldi r20,hlo8(0x3f000000)
 2177 082a 5FE3      		ldi r21,hhi8(0x3f000000)
 2178 082c 0E94 0000 		call __mulsf3
 2179 0830 0E94 0000 		call sin
 2180 0834 9B01      		movw r18,r22
 2181 0836 AC01      		movw r20,r24
 2182 0838 0E94 0000 		call __mulsf3
 2183 083c B62E      		mov r11,r22
 2184 083e D72E      		mov r13,r23
 2185 0840 882E      		mov r8,r24
 2186               	.LVL120:
 2187 0842 C92E      		mov r12,r25
 2188 0844 C801      		movw r24,r16
 2189 0846 B701      		movw r22,r14
 2190 0848 A301      		movw r20,r6
 2191 084a 9201      		movw r18,r4
 2192 084c 0E94 0000 		call __mulsf3
 2193 0850 0B2D      		mov r16,r11
 2194 0852 1D2D      		mov r17,r13
 2195 0854 282D      		mov r18,r8
 2196 0856 3C2D      		mov r19,r12
 2197 0858 A901      		movw r20,r18
 2198 085a 9801      		movw r18,r16
 2199 085c 0E94 0000 		call __mulsf3
 2200 0860 9B01      		movw r18,r22
 2201 0862 AC01      		movw r20,r24
 2202 0864 F101      		movw r30,r2
 2203 0866 7D81      		ldd r23,Y+5
 2204 0868 6E81      		ldd r22,Y+6
 2205 086a 8F2F      		mov r24,r31
 2206 086c 9E2F      		mov r25,r30
 2207 086e A72F      		mov r26,r23
 2208 0870 B62F      		mov r27,r22
 2209 0872 BC01      		movw r22,r24
 2210 0874 CD01      		movw r24,r26
 2211 0876 0E94 0000 		call __addsf3
 2212 087a 862E      		mov r8,r22
 2213 087c 072F      		mov r16,r23
 2214 087e 382E      		mov r3,r24
 2215 0880 492E      		mov r4,r25
 2216               	.LVL121:
  32:nmea/nmea.h   ****     double c = 2 * atan2(sqrt(a), sqrt(1-a));
 2217               		.loc 8 32 0
 2218 0882 982F      		mov r25,r24
 2219               	.LVL122:
 2220 0884 482D      		mov r20,r8
 2221 0886 502F      		mov r21,r16
 2222 0888 692F      		mov r22,r25
 2223               	.LVL123:
 2224 088a 742D      		mov r23,r4
 2225               	.LVL124:
 2226 088c CB01      		movw r24,r22
 2227 088e BA01      		movw r22,r20
 2228 0890 0E94 0000 		call sqrt
 2229               	.LVL125:
 2230 0894 6B01      		movw r12,r22
 2231 0896 7C01      		movw r14,r24
 2232 0898 60E0      		ldi r22,lo8(0x3f800000)
 2233 089a 70E0      		ldi r23,hi8(0x3f800000)
 2234 089c 80E8      		ldi r24,hlo8(0x3f800000)
 2235 089e 9FE3      		ldi r25,hhi8(0x3f800000)
 2236 08a0 E02F      		mov r30,r16
 2237 08a2 082D      		mov r16,r8
 2238               	.LVL126:
 2239 08a4 1E2F      		mov r17,r30
 2240 08a6 232D      		mov r18,r3
 2241 08a8 342D      		mov r19,r4
 2242 08aa A901      		movw r20,r18
 2243 08ac 9801      		movw r18,r16
 2244 08ae 0E94 0000 		call __subsf3
 2245               	.LVL127:
 2246 08b2 0E94 0000 		call sqrt
 2247 08b6 9B01      		movw r18,r22
 2248 08b8 AC01      		movw r20,r24
 2249 08ba C701      		movw r24,r14
 2250 08bc B601      		movw r22,r12
 2251 08be 0E94 0000 		call atan2
 2252 08c2 9B01      		movw r18,r22
 2253 08c4 AC01      		movw r20,r24
 2254               	.LVL128:
 2255 08c6 0E94 0000 		call __addsf3
 2256               	.LVL129:
  33:nmea/nmea.h   ****     double d = 6367 * c;
 2257               		.loc 8 33 0
 2258 08ca 20E0      		ldi r18,lo8(0x45c6f800)
 2259 08cc 38EF      		ldi r19,hi8(0x45c6f800)
 2260 08ce 46EC      		ldi r20,hlo8(0x45c6f800)
 2261 08d0 55E4      		ldi r21,hhi8(0x45c6f800)
 2262 08d2 0E94 0000 		call __mulsf3
  34:nmea/nmea.h   **** 
  35:nmea/nmea.h   ****     return d;
  36:nmea/nmea.h   **** }
 2263               		.loc 8 36 0
 2264 08d6 462F      		mov r20,r22
 2265 08d8 572F      		mov r21,r23
 2266 08da 682F      		mov r22,r24
 2267 08dc 792F      		mov r23,r25
 2268 08de CB01      		movw r24,r22
 2269 08e0 BA01      		movw r22,r20
 2270               	/* epilogue start */
 2271 08e2 2696      		adiw r28,6
 2272 08e4 CDBF      		out __SP_L__,r28
 2273 08e6 DEBF      		out __SP_H__,r29
 2274 08e8 DF91      		pop r29
 2275 08ea CF91      		pop r28
 2276 08ec 1F91      		pop r17
 2277               	.LVL130:
 2278 08ee 0F91      		pop r16
 2279 08f0 FF90      		pop r15
 2280 08f2 EF90      		pop r14
 2281 08f4 DF90      		pop r13
 2282 08f6 CF90      		pop r12
 2283 08f8 BF90      		pop r11
 2284 08fa AF90      		pop r10
 2285 08fc 9F90      		pop r9
 2286 08fe 8F90      		pop r8
 2287 0900 7F90      		pop r7
 2288 0902 6F90      		pop r6
 2289 0904 5F90      		pop r5
 2290 0906 4F90      		pop r4
 2291 0908 3F90      		pop r3
 2292 090a 2F90      		pop r2
 2293 090c 0895      		ret
 2294               		.cfi_endproc
 2295               	.LFE63:
 2297               		.data
 2298               	.LC0:
 2299 0000 2C00      		.string	","
 2300               	.LC1:
 2301 0002 4E6F 2047 		.string	"No GPS Signal"
 2301      5053 2053 
 2301      6967 6E61 
 2301      6C00 
 2302               		.text
 2303               	.global	parse_nmea_string
 2305               	parse_nmea_string:
 2306               	.LFB64:
  37:nmea/nmea.h   **** 
  38:nmea/nmea.h   **** 
  39:nmea/nmea.h   **** 
  40:nmea/nmea.h   **** void parse_nmea_string(char *s, latlng *gps)
  41:nmea/nmea.h   **** {
 2307               		.loc 8 41 0
 2308               		.cfi_startproc
 2309               	.LVL131:
 2310 090e 7F92      		push r7
 2311               	.LCFI64:
 2312               		.cfi_def_cfa_offset 3
 2313               		.cfi_offset 7, -2
 2314 0910 8F92      		push r8
 2315               	.LCFI65:
 2316               		.cfi_def_cfa_offset 4
 2317               		.cfi_offset 8, -3
 2318 0912 9F92      		push r9
 2319               	.LCFI66:
 2320               		.cfi_def_cfa_offset 5
 2321               		.cfi_offset 9, -4
 2322 0914 AF92      		push r10
 2323               	.LCFI67:
 2324               		.cfi_def_cfa_offset 6
 2325               		.cfi_offset 10, -5
 2326 0916 BF92      		push r11
 2327               	.LCFI68:
 2328               		.cfi_def_cfa_offset 7
 2329               		.cfi_offset 11, -6
 2330 0918 CF92      		push r12
 2331               	.LCFI69:
 2332               		.cfi_def_cfa_offset 8
 2333               		.cfi_offset 12, -7
 2334 091a DF92      		push r13
 2335               	.LCFI70:
 2336               		.cfi_def_cfa_offset 9
 2337               		.cfi_offset 13, -8
 2338 091c EF92      		push r14
 2339               	.LCFI71:
 2340               		.cfi_def_cfa_offset 10
 2341               		.cfi_offset 14, -9
 2342 091e FF92      		push r15
 2343               	.LCFI72:
 2344               		.cfi_def_cfa_offset 11
 2345               		.cfi_offset 15, -10
 2346 0920 0F93      		push r16
 2347               	.LCFI73:
 2348               		.cfi_def_cfa_offset 12
 2349               		.cfi_offset 16, -11
 2350 0922 1F93      		push r17
 2351               	.LCFI74:
 2352               		.cfi_def_cfa_offset 13
 2353               		.cfi_offset 17, -12
 2354 0924 CF93      		push r28
 2355               	.LCFI75:
 2356               		.cfi_def_cfa_offset 14
 2357               		.cfi_offset 28, -13
 2358 0926 DF93      		push r29
 2359               	.LCFI76:
 2360               		.cfi_def_cfa_offset 15
 2361               		.cfi_offset 29, -14
 2362 0928 CDB7      		in r28,__SP_L__
 2363 092a DEB7      		in r29,__SP_H__
 2364 092c A897      		sbiw r28,40
 2365               	.LCFI77:
 2366               		.cfi_def_cfa 28, 55
 2367 092e CDBF      		out __SP_L__,r28
 2368 0930 DEBF      		out __SP_H__,r29
 2369               	/* prologue: function */
 2370               	/* frame size = 40 */
 2371               	/* stack size = 53 */
 2372               	.L__stack_usage = 53
 2373 0932 7B01      		movw r14,r22
 2374               	.LVL132:
  42:nmea/nmea.h   ****   uint8_t i=0; // used to iterate through array
  43:nmea/nmea.h   ****   char *token[20]; //stores the chunks of string after splitting the string on commas
  44:nmea/nmea.h   **** 
  45:nmea/nmea.h   ****   token[0] = strtok(s, ","); //get pointer to first token found and store in
 2375               		.loc 8 45 0
 2376 0934 60E0      		ldi r22,lo8(.LC0)
 2377 0936 70E0      		ldi r23,hi8(.LC0)
 2378               	.LVL133:
 2379 0938 0E94 0000 		call strtok
 2380               	.LVL134:
  46:nmea/nmea.h   ****                              //first element of array
  47:nmea/nmea.h   ****   while(token[i] != NULL) {  //while commas continue to be found
 2381               		.loc 8 47 0
 2382 093c 0097      		sbiw r24,0
 2383 093e 01F0      		breq .L85
 2384 0940 10E0      		ldi r17,lo8(0)
 2385               	.LVL135:
 2386               	.L86:
  48:nmea/nmea.h   ****       i++;  
 2387               		.loc 8 48 0
 2388 0942 1F5F      		subi r17,lo8(-(1))
 2389               	.LVL136:
  49:nmea/nmea.h   ****       token[i] = strtok(NULL, ","); //continue to split the string
 2390               		.loc 8 49 0
 2391 0944 80E0      		ldi r24,lo8(0)
 2392 0946 90E0      		ldi r25,hi8(0)
 2393 0948 60E0      		ldi r22,lo8(.LC0)
 2394 094a 70E0      		ldi r23,hi8(.LC0)
 2395 094c 0E94 0000 		call strtok
 2396 0950 E12F      		mov r30,r17
 2397 0952 F0E0      		ldi r31,lo8(0)
 2398 0954 EE0F      		lsl r30
 2399 0956 FF1F      		rol r31
 2400 0958 21E0      		ldi r18,lo8(1)
 2401 095a 30E0      		ldi r19,hi8(1)
 2402 095c 2C0F      		add r18,r28
 2403 095e 3D1F      		adc r19,r29
 2404 0960 E20F      		add r30,r18
 2405 0962 F31F      		adc r31,r19
 2406 0964 8083      		st Z,r24
 2407 0966 9183      		std Z+1,r25
  47:nmea/nmea.h   ****   while(token[i] != NULL) {  //while commas continue to be found
 2408               		.loc 8 47 0
 2409 0968 0097      		sbiw r24,0
 2410 096a 01F4      		brne .L86
 2411               	.LVL137:
 2412               	.L85:
  50:nmea/nmea.h   ****   }
  51:nmea/nmea.h   **** 
  52:nmea/nmea.h   ****   //Example: token = [], s = "a,b,c"
  53:nmea/nmea.h   ****   //Iteration 1
  54:nmea/nmea.h   ****   //token --> ["a"], s-->"b,c"
  55:nmea/nmea.h   ****   //token --> ["a", "b"], s-->"c"
  56:nmea/nmea.h   ****   //token --> ["a", "b", "c"], s-->""
  57:nmea/nmea.h   ****   //end
  58:nmea/nmea.h   **** 
  59:nmea/nmea.h   ****   //when parsing GPRMC data
  60:nmea/nmea.h   ****   //error char at index 1
  61:nmea/nmea.h   ****   //longitude should be stored at index 2
  62:nmea/nmea.h   ****   //latitude should be stord at index 4
  63:nmea/nmea.h   **** 
  64:nmea/nmea.h   ****   //indices will have to be changed if our gps module
  65:nmea/nmea.h   ****   //speaks a different dialog of NMEA
  66:nmea/nmea.h   **** 
  67:nmea/nmea.h   ****   char* valid = token[1]; //A --> Valid, V --> Invalid
 2413               		.loc 8 67 0
 2414 096c EB81      		ldd r30,Y+3
 2415 096e FC81      		ldd r31,Y+4
 2416               	.LVL138:
  68:nmea/nmea.h   ****   char* lat_str = token[2]; //longitude
 2417               		.loc 8 68 0
 2418 0970 1D81      		ldd r17,Y+5
 2419 0972 0E81      		ldd r16,Y+6
 2420               	.LVL139:
  69:nmea/nmea.h   ****   char* lng_str = token[4]; //latitude
 2421               		.loc 8 69 0
 2422 0974 D984      		ldd r13,Y+9
 2423 0976 CA84      		ldd r12,Y+10
 2424               	.LVL140:
  70:nmea/nmea.h   **** 
  71:nmea/nmea.h   ****   gps->valid = *valid;
 2425               		.loc 8 71 0
 2426 0978 8081      		ld r24,Z
 2427 097a D701      		movw r26,r14
 2428 097c 1C96      		adiw r26,12
 2429 097e 8C93      		st X,r24
 2430 0980 1C97      		sbiw r26,12
  72:nmea/nmea.h   **** 
  73:nmea/nmea.h   ****   if (*valid == 'A') {
 2431               		.loc 8 73 0
 2432 0982 8081      		ld r24,Z
 2433 0984 8134      		cpi r24,lo8(65)
 2434 0986 01F0      		breq .L94
  74:nmea/nmea.h   ****     gps->valid = 1;
  75:nmea/nmea.h   ****     char* string_rep = concat(lat_str, concat(" ", lng_str));
  76:nmea/nmea.h   ****     send_string(string_rep);
  77:nmea/nmea.h   ****     //converts string stored in gps->lat_str to double and stores in lat
  78:nmea/nmea.h   ****     gps->lat = atof(lat_str)/100.;
  79:nmea/nmea.h   **** 
  80:nmea/nmea.h   ****     //converts string stored in gps->lng_str to double and stores in lng
  81:nmea/nmea.h   ****     gps->lng = atof(lng_str)/100.;
  82:nmea/nmea.h   ****     gps->dist = distance(gps->lat, gps->lng);
  83:nmea/nmea.h   ****     if (gps->dist > max_dist) {
  84:nmea/nmea.h   ****       gps->roaming = 1;
  85:nmea/nmea.h   ****     } else {
  86:nmea/nmea.h   ****       gps->roaming = 0;
  87:nmea/nmea.h   ****     }
  88:nmea/nmea.h   ****   } else {
  89:nmea/nmea.h   ****     gps->valid = 0;
 2435               		.loc 8 89 0
 2436 0988 F701      		movw r30,r14
 2437 098a 1486      		std Z+12,__zero_reg__
  90:nmea/nmea.h   ****     send_string("No GPS Signal");
 2438               		.loc 8 90 0
 2439 098c 80E0      		ldi r24,lo8(.LC1)
 2440 098e 90E0      		ldi r25,hi8(.LC1)
 2441 0990 0E94 0000 		call send_string
 2442               	.L84:
 2443               	/* epilogue start */
  91:nmea/nmea.h   ****   }
  92:nmea/nmea.h   **** 
  93:nmea/nmea.h   **** 
  94:nmea/nmea.h   **** }
 2444               		.loc 8 94 0
 2445 0994 A896      		adiw r28,40
 2446 0996 CDBF      		out __SP_L__,r28
 2447 0998 DEBF      		out __SP_H__,r29
 2448 099a DF91      		pop r29
 2449 099c CF91      		pop r28
 2450 099e 1F91      		pop r17
 2451 09a0 0F91      		pop r16
 2452 09a2 FF90      		pop r15
 2453 09a4 EF90      		pop r14
 2454               	.LVL141:
 2455 09a6 DF90      		pop r13
 2456 09a8 CF90      		pop r12
 2457 09aa BF90      		pop r11
 2458 09ac AF90      		pop r10
 2459 09ae 9F90      		pop r9
 2460 09b0 8F90      		pop r8
 2461 09b2 7F90      		pop r7
 2462 09b4 0895      		ret
 2463               	.LVL142:
 2464               	.L94:
 2465               	.LBB902:
  74:nmea/nmea.h   ****     gps->valid = 1;
 2466               		.loc 8 74 0
 2467 09b6 7724      		clr r7
 2468 09b8 7394      		inc r7
 2469 09ba 1C96      		adiw r26,12
 2470 09bc 7C92      		st X,r7
 2471               	.LVL143:
 2472               	.LBB903:
 2473               	.LBB904:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 2474               		.loc 7 16 0
 2475 09be ED2D      		mov r30,r13
 2476 09c0 FC2D      		mov r31,r12
 2477 09c2 DF01      		movw r26,r30
 2478 09c4 0D90      		ld __tmp_reg__,X+
 2479 09c6 0020      		tst __tmp_reg__
 2480 09c8 01F4      		brne .-6
 2481 09ca CD01      		movw r24,r26
 2482 09cc 8E1B      		sub r24,r30
 2483 09ce 9F0B      		sbc r25,r31
 2484 09d0 0196      		adiw r24,1
 2485 09d2 0E94 0000 		call malloc
 2486 09d6 B92E      		mov r11,r25
 2487 09d8 882E      		mov r8,r24
 2488 09da 992E      		mov r9,r25
 2489               	.LVL144:
  18:utils/utils.h ****     strcpy(result, s1);
 2490               		.loc 7 18 0
 2491 09dc 80E2      		ldi r24,lo8(32)
 2492 09de 90E0      		ldi r25,hi8(32)
 2493 09e0 F401      		movw r30,r8
 2494 09e2 8083      		st Z,r24
 2495 09e4 9183      		std Z+1,r25
  19:utils/utils.h ****     strcat(result, s2);
 2496               		.loc 7 19 0
 2497 09e6 C401      		movw r24,r8
 2498 09e8 6D2D      		mov r22,r13
 2499 09ea 7C2D      		mov r23,r12
 2500 09ec 0E94 0000 		call strcat
 2501               	.LVL145:
 2502               	.LBE904:
 2503               	.LBE903:
 2504               	.LBB905:
 2505               	.LBB906:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 2506               		.loc 7 16 0
 2507 09f0 A12F      		mov r26,r17
 2508 09f2 B02F      		mov r27,r16
 2509 09f4 FD01      		movw r30,r26
 2510 09f6 0190      		ld __tmp_reg__,Z+
 2511 09f8 0020      		tst __tmp_reg__
 2512 09fa 01F4      		brne .-6
 2513 09fc 9F01      		movw r18,r30
 2514 09fe 482D      		mov r20,r8
 2515 0a00 5B2D      		mov r21,r11
 2516 0a02 FA01      		movw r30,r20
 2517 0a04 0190      		ld __tmp_reg__,Z+
 2518 0a06 0020      		tst __tmp_reg__
 2519 0a08 01F4      		brne .-6
 2520 0a0a CF01      		movw r24,r30
 2521 0a0c 0197      		sbiw r24,1
 2522 0a0e 841B      		sub r24,r20
 2523 0a10 950B      		sbc r25,r21
 2524 0a12 8A1B      		sub r24,r26
 2525 0a14 9B0B      		sbc r25,r27
 2526 0a16 820F      		add r24,r18
 2527 0a18 931F      		adc r25,r19
 2528 0a1a 0E94 0000 		call malloc
 2529 0a1e 5C01      		movw r10,r24
 2530               	.LVL146:
  18:utils/utils.h ****     strcpy(result, s1);
 2531               		.loc 7 18 0
 2532 0a20 612F      		mov r22,r17
 2533 0a22 702F      		mov r23,r16
 2534 0a24 0E94 0000 		call strcpy
 2535               	.LVL147:
  19:utils/utils.h ****     strcat(result, s2);
 2536               		.loc 7 19 0
 2537 0a28 C501      		movw r24,r10
 2538 0a2a B401      		movw r22,r8
 2539 0a2c 0E94 0000 		call strcat
 2540               	.LBE906:
 2541               	.LBE905:
  76:nmea/nmea.h   ****     send_string(string_rep);
 2542               		.loc 8 76 0
 2543 0a30 C501      		movw r24,r10
 2544 0a32 0E94 0000 		call send_string
  78:nmea/nmea.h   ****     gps->lat = atof(lat_str)/100.;
 2545               		.loc 8 78 0
 2546 0a36 812F      		mov r24,r17
 2547 0a38 902F      		mov r25,r16
 2548 0a3a 0E94 0000 		call atof
 2549 0a3e 20E0      		ldi r18,lo8(0x42c80000)
 2550 0a40 30E0      		ldi r19,hi8(0x42c80000)
 2551 0a42 48EC      		ldi r20,hlo8(0x42c80000)
 2552 0a44 52E4      		ldi r21,hhi8(0x42c80000)
 2553 0a46 0E94 0000 		call __divsf3
 2554 0a4a DC01      		movw r26,r24
 2555 0a4c CB01      		movw r24,r22
 2556 0a4e F701      		movw r30,r14
 2557 0a50 8083      		st Z,r24
 2558 0a52 9183      		std Z+1,r25
 2559 0a54 A283      		std Z+2,r26
 2560 0a56 B383      		std Z+3,r27
  81:nmea/nmea.h   ****     gps->lng = atof(lng_str)/100.;
 2561               		.loc 8 81 0
 2562 0a58 8D2D      		mov r24,r13
 2563 0a5a 9C2D      		mov r25,r12
 2564 0a5c 0E94 0000 		call atof
 2565 0a60 20E0      		ldi r18,lo8(0x42c80000)
 2566 0a62 30E0      		ldi r19,hi8(0x42c80000)
 2567 0a64 48EC      		ldi r20,hlo8(0x42c80000)
 2568 0a66 52E4      		ldi r21,hhi8(0x42c80000)
 2569 0a68 0E94 0000 		call __divsf3
 2570 0a6c A62F      		mov r26,r22
 2571 0a6e 172F      		mov r17,r23
 2572 0a70 382F      		mov r19,r24
 2573 0a72 292F      		mov r18,r25
 2574 0a74 C901      		movw r24,r18
 2575 0a76 4A2F      		mov r20,r26
 2576 0a78 512F      		mov r21,r17
 2577 0a7a 692F      		mov r22,r25
 2578 0a7c 782F      		mov r23,r24
 2579 0a7e F701      		movw r30,r14
 2580 0a80 4483      		std Z+4,r20
 2581 0a82 5583      		std Z+5,r21
 2582 0a84 6683      		std Z+6,r22
 2583 0a86 7783      		std Z+7,r23
  82:nmea/nmea.h   ****     gps->dist = distance(gps->lat, gps->lng);
 2584               		.loc 8 82 0
 2585 0a88 4081      		ld r20,Z
 2586 0a8a 5181      		ldd r21,Z+1
 2587 0a8c 6281      		ldd r22,Z+2
 2588 0a8e 7381      		ldd r23,Z+3
 2589 0a90 CB01      		movw r24,r22
 2590 0a92 BA01      		movw r22,r20
 2591 0a94 A901      		movw r20,r18
 2592 0a96 0A2F      		mov r16,r26
 2593 0a98 252F      		mov r18,r21
 2594 0a9a 342F      		mov r19,r20
 2595 0a9c A901      		movw r20,r18
 2596 0a9e 9801      		movw r18,r16
 2597 0aa0 0E94 0000 		call distance
 2598 0aa4 D701      		movw r26,r14
 2599 0aa6 1896      		adiw r26,8
 2600 0aa8 6D93      		st X+,r22
 2601 0aaa 7D93      		st X+,r23
 2602 0aac 8D93      		st X+,r24
 2603 0aae 9C93      		st X,r25
 2604 0ab0 1B97      		sbiw r26,8+3
  83:nmea/nmea.h   ****     if (gps->dist > max_dist) {
 2605               		.loc 8 83 0
 2606 0ab2 2091 0000 		lds r18,max_dist
 2607 0ab6 3091 0000 		lds r19,max_dist+1
 2608 0aba 4091 0000 		lds r20,max_dist+2
 2609 0abe 5091 0000 		lds r21,max_dist+3
 2610 0ac2 0E94 0000 		call __gtsf2
 2611 0ac6 1816      		cp __zero_reg__,r24
 2612 0ac8 04F4      		brge .L93
  84:nmea/nmea.h   ****       gps->roaming = 1;
 2613               		.loc 8 84 0
 2614 0aca F701      		movw r30,r14
 2615 0acc 7586      		std Z+13,r7
 2616 0ace 00C0      		rjmp .L84
 2617               	.L93:
  86:nmea/nmea.h   ****       gps->roaming = 0;
 2618               		.loc 8 86 0
 2619 0ad0 D701      		movw r26,r14
 2620 0ad2 1D96      		adiw r26,13
 2621 0ad4 1C92      		st X,__zero_reg__
 2622 0ad6 1D97      		sbiw r26,13
 2623 0ad8 00C0      		rjmp .L84
 2624               	.LBE902:
 2625               		.cfi_endproc
 2626               	.LFE64:
 2628               		.data
 2629               	.LC2:
 2630 0010 2566 00   		.string	"%f"
 2631               		.text
 2632               	.global	parse_nmea
 2634               	parse_nmea:
 2635               	.LFB65:
  95:nmea/nmea.h   **** 
  96:nmea/nmea.h   **** 
  97:nmea/nmea.h   **** void parse_nmea(char* buff, latlng* gps) {
 2636               		.loc 8 97 0
 2637               		.cfi_startproc
 2638               	.LVL148:
 2639 0ada 8F92      		push r8
 2640               	.LCFI78:
 2641               		.cfi_def_cfa_offset 3
 2642               		.cfi_offset 8, -2
 2643 0adc 9F92      		push r9
 2644               	.LCFI79:
 2645               		.cfi_def_cfa_offset 4
 2646               		.cfi_offset 9, -3
 2647 0ade AF92      		push r10
 2648               	.LCFI80:
 2649               		.cfi_def_cfa_offset 5
 2650               		.cfi_offset 10, -4
 2651 0ae0 BF92      		push r11
 2652               	.LCFI81:
 2653               		.cfi_def_cfa_offset 6
 2654               		.cfi_offset 11, -5
 2655 0ae2 CF92      		push r12
 2656               	.LCFI82:
 2657               		.cfi_def_cfa_offset 7
 2658               		.cfi_offset 12, -6
 2659 0ae4 DF92      		push r13
 2660               	.LCFI83:
 2661               		.cfi_def_cfa_offset 8
 2662               		.cfi_offset 13, -7
 2663 0ae6 EF92      		push r14
 2664               	.LCFI84:
 2665               		.cfi_def_cfa_offset 9
 2666               		.cfi_offset 14, -8
 2667 0ae8 FF92      		push r15
 2668               	.LCFI85:
 2669               		.cfi_def_cfa_offset 10
 2670               		.cfi_offset 15, -9
 2671 0aea 0F93      		push r16
 2672               	.LCFI86:
 2673               		.cfi_def_cfa_offset 11
 2674               		.cfi_offset 16, -10
 2675 0aec 1F93      		push r17
 2676               	.LCFI87:
 2677               		.cfi_def_cfa_offset 12
 2678               		.cfi_offset 17, -11
 2679 0aee CF93      		push r28
 2680               	.LCFI88:
 2681               		.cfi_def_cfa_offset 13
 2682               		.cfi_offset 28, -12
 2683 0af0 DF93      		push r29
 2684               	.LCFI89:
 2685               		.cfi_def_cfa_offset 14
 2686               		.cfi_offset 29, -13
 2687 0af2 CDB7      		in r28,__SP_L__
 2688 0af4 DEB7      		in r29,__SP_H__
 2689 0af6 C659      		subi r28,lo8(-(-150))
 2690 0af8 D040      		sbci r29,hi8(-(-150))
 2691               	.LCFI90:
 2692               		.cfi_def_cfa 28, 164
 2693 0afa CDBF      		out __SP_L__,r28
 2694 0afc DEBF      		out __SP_H__,r29
 2695               	/* prologue: function */
 2696               	/* frame size = 150 */
 2697               	/* stack size = 162 */
 2698               	.L__stack_usage = 162
 2699 0afe 7B01      		movw r14,r22
  98:nmea/nmea.h   **** 
  99:nmea/nmea.h   ****     //parse lat and lng out of raw nmea string
 100:nmea/nmea.h   ****     parse_nmea_string(buff, gps);
 2700               		.loc 8 100 0
 2701 0b00 0E94 0000 		call parse_nmea_string
 2702               	.LVL149:
 101:nmea/nmea.h   ****     // send_string("Parsed");
 102:nmea/nmea.h   **** 
 103:nmea/nmea.h   ****     if (gps->dist > max_dist) {
 2703               		.loc 8 103 0
 2704 0b04 D701      		movw r26,r14
 2705 0b06 1896      		adiw r26,8
 2706 0b08 6D91      		ld r22,X+
 2707 0b0a 7D91      		ld r23,X+
 2708 0b0c 8D91      		ld r24,X+
 2709 0b0e 9C91      		ld r25,X
 2710 0b10 1B97      		sbiw r26,8+3
 2711 0b12 2091 0000 		lds r18,max_dist
 2712 0b16 3091 0000 		lds r19,max_dist+1
 2713 0b1a 4091 0000 		lds r20,max_dist+2
 2714 0b1e 5091 0000 		lds r21,max_dist+3
 2715 0b22 0E94 0000 		call __gtsf2
 2716 0b26 1816      		cp __zero_reg__,r24
 2717 0b28 04F0      		brlt .+2
 2718 0b2a 00C0      		rjmp .L95
 2719               	.LBB913:
 104:nmea/nmea.h   **** 
 105:nmea/nmea.h   ****       char lat_buff[50];
 106:nmea/nmea.h   ****       char lng_buff[50];
 107:nmea/nmea.h   ****       char dist_buff[50];
 108:nmea/nmea.h   **** 
 109:nmea/nmea.h   ****       sprintf(lat_buff, "%f", gps->lat);
 2720               		.loc 8 109 0
 2721 0b2c EDB7      		in r30,__SP_L__
 2722 0b2e FEB7      		in r31,__SP_H__
 2723 0b30 3897      		sbiw r30,8
 2724 0b32 EDBF      		out __SP_L__,r30
 2725 0b34 FEBF      		out __SP_H__,r31
 2726 0b36 2DB7      		in r18,__SP_L__
 2727 0b38 3EB7      		in r19,__SP_H__
 2728 0b3a 2F5F      		subi r18,lo8(-(1))
 2729 0b3c 3F4F      		sbci r19,hi8(-(1))
 2730 0b3e B5E6      		ldi r27,lo8(101)
 2731 0b40 AB2E      		mov r10,r27
 2732 0b42 B12C      		mov r11,__zero_reg__
 2733 0b44 AC0E      		add r10,r28
 2734 0b46 BD1E      		adc r11,r29
 2735 0b48 A182      		std Z+1,r10
 2736 0b4a B282      		std Z+2,r11
 2737 0b4c 00E0      		ldi r16,lo8(.LC2)
 2738 0b4e 10E0      		ldi r17,hi8(.LC2)
 2739 0b50 D901      		movw r26,r18
 2740 0b52 1296      		adiw r26,2
 2741 0b54 0D93      		st X+,r16
 2742 0b56 1C93      		st X,r17
 2743 0b58 1397      		sbiw r26,2+1
 2744 0b5a F701      		movw r30,r14
 2745 0b5c 8081      		ld r24,Z
 2746 0b5e 9181      		ldd r25,Z+1
 2747 0b60 A281      		ldd r26,Z+2
 2748 0b62 B381      		ldd r27,Z+3
 2749 0b64 F901      		movw r30,r18
 2750 0b66 8483      		std Z+4,r24
 2751 0b68 9583      		std Z+5,r25
 2752 0b6a A683      		std Z+6,r26
 2753 0b6c B783      		std Z+7,r27
 2754               		.cfi_escape 0x2e,0x8
 2755 0b6e 0E94 0000 		call sprintf
 110:nmea/nmea.h   ****       sprintf(lng_buff, "%f", gps->lng);
 2756               		.loc 8 110 0
 2757 0b72 2DB7      		in r18,__SP_L__
 2758 0b74 3EB7      		in r19,__SP_H__
 2759 0b76 2F5F      		subi r18,lo8(-(1))
 2760 0b78 3F4F      		sbci r19,hi8(-(1))
 2761 0b7a 83E3      		ldi r24,lo8(51)
 2762 0b7c 882E      		mov r8,r24
 2763 0b7e 912C      		mov r9,__zero_reg__
 2764 0b80 8C0E      		add r8,r28
 2765 0b82 9D1E      		adc r9,r29
 2766 0b84 ADB7      		in r26,__SP_L__
 2767 0b86 BEB7      		in r27,__SP_H__
 2768 0b88 1196      		adiw r26,1
 2769 0b8a 8D92      		st X+,r8
 2770 0b8c 9C92      		st X,r9
 2771 0b8e 1297      		sbiw r26,1+1
 2772 0b90 F901      		movw r30,r18
 2773 0b92 0283      		std Z+2,r16
 2774 0b94 1383      		std Z+3,r17
 2775 0b96 F701      		movw r30,r14
 2776 0b98 8481      		ldd r24,Z+4
 2777 0b9a 9581      		ldd r25,Z+5
 2778 0b9c A681      		ldd r26,Z+6
 2779 0b9e B781      		ldd r27,Z+7
 2780 0ba0 F901      		movw r30,r18
 2781 0ba2 8483      		std Z+4,r24
 2782 0ba4 9583      		std Z+5,r25
 2783 0ba6 A683      		std Z+6,r26
 2784 0ba8 B783      		std Z+7,r27
 2785 0baa 0E94 0000 		call sprintf
 111:nmea/nmea.h   ****       sprintf(dist_buff, "%f", gps->dist);
 2786               		.loc 8 111 0
 2787 0bae 2DB7      		in r18,__SP_L__
 2788 0bb0 3EB7      		in r19,__SP_H__
 2789 0bb2 2F5F      		subi r18,lo8(-(1))
 2790 0bb4 3F4F      		sbci r19,hi8(-(1))
 2791 0bb6 CE01      		movw r24,r28
 2792 0bb8 0196      		adiw r24,1
 2793 0bba ADB7      		in r26,__SP_L__
 2794 0bbc BEB7      		in r27,__SP_H__
 2795 0bbe 1196      		adiw r26,1
 2796 0bc0 8D93      		st X+,r24
 2797 0bc2 9C93      		st X,r25
 2798 0bc4 1297      		sbiw r26,1+1
 2799 0bc6 F901      		movw r30,r18
 2800 0bc8 0283      		std Z+2,r16
 2801 0bca 1383      		std Z+3,r17
 2802 0bcc F701      		movw r30,r14
 2803 0bce 8085      		ldd r24,Z+8
 2804 0bd0 9185      		ldd r25,Z+9
 2805 0bd2 A285      		ldd r26,Z+10
 2806 0bd4 B385      		ldd r27,Z+11
 2807 0bd6 F901      		movw r30,r18
 2808 0bd8 8483      		std Z+4,r24
 2809 0bda 9583      		std Z+5,r25
 2810 0bdc A683      		std Z+6,r26
 2811 0bde B783      		std Z+7,r27
 2812 0be0 0E94 0000 		call sprintf
 2813               	.LVL150:
 2814               	.LBB914:
 2815               	.LBB915:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 2816               		.loc 7 16 0
 2817 0be4 D501      		movw r26,r10
 2818 0be6 0D90      		ld __tmp_reg__,X+
 2819 0be8 0020      		tst __tmp_reg__
 2820 0bea 01F4      		brne .-6
 2821 0bec CD01      		movw r24,r26
 2822 0bee 8A19      		sub r24,r10
 2823 0bf0 9B09      		sbc r25,r11
 2824 0bf2 EDB7      		in r30,__SP_L__
 2825 0bf4 FEB7      		in r31,__SP_H__
 2826 0bf6 3896      		adiw r30,8
 2827 0bf8 EDBF      		out __SP_L__,r30
 2828 0bfa FEBF      		out __SP_H__,r31
 2829               	.LVL151:
 2830 0bfc 0196      		adiw r24,1
 2831               		.cfi_escape 0x2e,0
 2832 0bfe 0E94 0000 		call malloc
 2833               	.LVL152:
 2834 0c02 192F      		mov r17,r25
 2835 0c04 C82E      		mov r12,r24
 2836 0c06 D92E      		mov r13,r25
 2837               	.LVL153:
  18:utils/utils.h ****     strcpy(result, s1);
 2838               		.loc 7 18 0
 2839 0c08 C601      		movw r24,r12
 2840 0c0a B501      		movw r22,r10
 2841 0c0c 0E94 0000 		call strcpy
  19:utils/utils.h ****     strcat(result, s2);
 2842               		.loc 7 19 0
 2843 0c10 EC2D      		mov r30,r12
 2844 0c12 F12F      		mov r31,r17
 2845 0c14 DF01      		movw r26,r30
 2846 0c16 0D90      		ld __tmp_reg__,X+
 2847 0c18 0020      		tst __tmp_reg__
 2848 0c1a 01F4      		brne .-6
 2849 0c1c 1197      		sbiw r26,1
 2850 0c1e AE1B      		sub r26,r30
 2851 0c20 BF0B      		sbc r27,r31
 2852 0c22 AC0D      		add r26,r12
 2853 0c24 BD1D      		adc r27,r13
 2854 0c26 8CE2      		ldi r24,lo8(44)
 2855 0c28 90E0      		ldi r25,hi8(44)
 2856 0c2a 8D93      		st X+,r24
 2857 0c2c 9C93      		st X,r25
 2858               	.LVL154:
 2859               	.LBE915:
 2860               	.LBE914:
 2861               	.LBB916:
 2862               	.LBB917:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 2863               		.loc 7 16 0
 2864 0c2e AC2D      		mov r26,r12
 2865 0c30 B12F      		mov r27,r17
 2866 0c32 FD01      		movw r30,r26
 2867 0c34 0190      		ld __tmp_reg__,Z+
 2868 0c36 0020      		tst __tmp_reg__
 2869 0c38 01F4      		brne .-6
 2870 0c3a 9F01      		movw r18,r30
 2871 0c3c F401      		movw r30,r8
 2872 0c3e 0190      		ld __tmp_reg__,Z+
 2873 0c40 0020      		tst __tmp_reg__
 2874 0c42 01F4      		brne .-6
 2875 0c44 CF01      		movw r24,r30
 2876 0c46 0197      		sbiw r24,1
 2877 0c48 8819      		sub r24,r8
 2878 0c4a 9909      		sbc r25,r9
 2879 0c4c 8A1B      		sub r24,r26
 2880 0c4e 9B0B      		sbc r25,r27
 2881 0c50 820F      		add r24,r18
 2882 0c52 931F      		adc r25,r19
 2883 0c54 0E94 0000 		call malloc
 2884 0c58 8C01      		movw r16,r24
 2885               	.LVL155:
  18:utils/utils.h ****     strcpy(result, s1);
 2886               		.loc 7 18 0
 2887 0c5a B601      		movw r22,r12
 2888 0c5c 0E94 0000 		call strcpy
 2889               	.LVL156:
  19:utils/utils.h ****     strcat(result, s2);
 2890               		.loc 7 19 0
 2891 0c60 C801      		movw r24,r16
 2892 0c62 B401      		movw r22,r8
 2893 0c64 0E94 0000 		call strcat
 2894               	.LBE917:
 2895               	.LBE916:
 112:nmea/nmea.h   **** 
 113:nmea/nmea.h   ****       /* Debugging code */
 114:nmea/nmea.h   ****       //determine how many characters are in the gps latitude and longitude strings
 115:nmea/nmea.h   ****       // int len_lat = strlen(lat_buff);
 116:nmea/nmea.h   ****       // int len_lng = strlen(lng_buff);
 117:nmea/nmea.h   ****       // int len_dist = strlen(dist_buff);
 118:nmea/nmea.h   **** 
 119:nmea/nmea.h   ****       // //iterate over lat and lng strings, sending them char by char over usb
 120:nmea/nmea.h   ****       // for (int i=0; i<len_lat; i++) {
 121:nmea/nmea.h   ****       //   send_byte(lat_buff[i]);  
 122:nmea/nmea.h   ****       // }
 123:nmea/nmea.h   **** 
 124:nmea/nmea.h   ****       // //lat/lng seperator 
 125:nmea/nmea.h   ****       // send_byte(' ');  
 126:nmea/nmea.h   ****       // for (int j=0; j<len_lng; j++) {
 127:nmea/nmea.h   ****       //   send_byte(lng_buff[j]);  
 128:nmea/nmea.h   ****       // }
 129:nmea/nmea.h   **** 
 130:nmea/nmea.h   ****       //       //lat/lng seperator 
 131:nmea/nmea.h   ****       // send_byte(' ');  
 132:nmea/nmea.h   ****       // for (int k=0; k<len_dist; k++) {
 133:nmea/nmea.h   ****       //   send_byte(dist_buff[k]);  
 134:nmea/nmea.h   ****       // }
 135:nmea/nmea.h   **** 
 136:nmea/nmea.h   ****       char* lat_str = &lat_buff[0];
 137:nmea/nmea.h   ****       char* lng_str = &lng_buff[0];
 138:nmea/nmea.h   ****       gps->sms = concat(concat(lat_str, ","), lng_str);
 2896               		.loc 8 138 0
 2897 0c68 D701      		movw r26,r14
 2898 0c6a 1E96      		adiw r26,14
 2899 0c6c 0C93      		st X,r16
 2900 0c6e 1E97      		sbiw r26,14
 2901 0c70 1F96      		adiw r26,15
 2902 0c72 1C93      		st X,r17
 2903 0c74 1F97      		sbiw r26,15
 2904               	.LVL157:
 2905               	.L95:
 2906               	/* epilogue start */
 2907               	.LBE913:
 139:nmea/nmea.h   ****       // send_string(gps->sms);
 140:nmea/nmea.h   ****     }
 141:nmea/nmea.h   **** 
 142:nmea/nmea.h   ****     //presumably has to do with memory management
 143:nmea/nmea.h   ****     //for now, just make sure to call it after you're done sending bytes over usb
 144:nmea/nmea.h   ****     // break_and_flush();
 145:nmea/nmea.h   **** }
 2908               		.loc 8 145 0
 2909 0c76 CA56      		subi r28,lo8(-(150))
 2910 0c78 DF4F      		sbci r29,hi8(-(150))
 2911 0c7a CDBF      		out __SP_L__,r28
 2912 0c7c DEBF      		out __SP_H__,r29
 2913 0c7e DF91      		pop r29
 2914 0c80 CF91      		pop r28
 2915 0c82 1F91      		pop r17
 2916 0c84 0F91      		pop r16
 2917 0c86 FF90      		pop r15
 2918 0c88 EF90      		pop r14
 2919               	.LVL158:
 2920 0c8a DF90      		pop r13
 2921 0c8c CF90      		pop r12
 2922 0c8e BF90      		pop r11
 2923 0c90 AF90      		pop r10
 2924 0c92 9F90      		pop r9
 2925 0c94 8F90      		pop r8
 2926 0c96 0895      		ret
 2927               		.cfi_endproc
 2928               	.LFE65:
 2930               	.global	uart_putchar
 2932               	uart_putchar:
 2933               	.LFB66:
 2934               		.file 9 "uart/uart.h"
   1:uart/uart.h   **** #include "Framework.h"
   2:uart/uart.h   **** #include <stdio.h>
   3:uart/uart.h   **** #include <stdlib.h>
   4:uart/uart.h   **** #include <string.h>
   5:uart/uart.h   **** 
   6:uart/uart.h   **** uint8_t debug = 0;
   7:uart/uart.h   **** 
   8:uart/uart.h   **** int uart_putchar(char c, USART_t* USART); 
   9:uart/uart.h   **** char uart_getchar(USART_t* USART);
  10:uart/uart.h   **** void send_uart(char*, USART_t* USART);
  11:uart/uart.h   **** 
  12:uart/uart.h   **** // code for communicating with the gprs module via uart
  13:uart/uart.h   **** int uart_putchar (char c, USART_t* USART) { 
 2935               		.loc 9 13 0
 2936               		.cfi_startproc
 2937               	.LVL159:
 2938               	/* prologue: function */
 2939               	/* frame size = 0 */
 2940               	/* stack size = 0 */
 2941               	.L__stack_usage = 0
 2942 0c98 FB01      		movw r30,r22
  14:uart/uart.h   ****     if (c == '\n') 
 2943               		.loc 9 14 0
 2944 0c9a 8A30      		cpi r24,lo8(10)
 2945 0c9c 01F0      		breq .L104
 2946               	.L103:
  15:uart/uart.h   ****         uart_putchar('\r', USART); 
  16:uart/uart.h   **** 
  17:uart/uart.h   ****     // Wait for the transmit buffer to be empty 
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 2947               		.loc 9 18 0 discriminator 1
 2948 0c9e 9181      		ldd r25,Z+1
 2949 0ca0 95FF      		sbrs r25,5
 2950 0ca2 00C0      		rjmp .L103
  19:uart/uart.h   **** 
  20:uart/uart.h   ****     // Put our character into the transmit buffer 
  21:uart/uart.h   ****     USART->DATA = c; 
 2951               		.loc 9 21 0
 2952 0ca4 8083      		st Z,r24
  22:uart/uart.h   **** 
  23:uart/uart.h   ****     return 0; 
  24:uart/uart.h   **** } 
 2953               		.loc 9 24 0
 2954 0ca6 80E0      		ldi r24,lo8(0)
 2955 0ca8 90E0      		ldi r25,hi8(0)
 2956               	.LVL160:
 2957               	/* epilogue start */
 2958 0caa 0895      		ret
 2959               	.LVL161:
 2960               	.L104:
 2961               	.LBB934:
 2962               	.LBB935:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 2963               		.loc 9 18 0
 2964 0cac 9181      		ldd r25,Z+1
 2965 0cae 95FF      		sbrs r25,5
 2966 0cb0 00C0      		rjmp .L104
  21:uart/uart.h   ****     USART->DATA = c; 
 2967               		.loc 9 21 0
 2968 0cb2 9DE0      		ldi r25,lo8(13)
 2969 0cb4 9083      		st Z,r25
 2970 0cb6 00C0      		rjmp .L103
 2971               	.LBE935:
 2972               	.LBE934:
 2973               		.cfi_endproc
 2974               	.LFE66:
 2976               	.global	uart_getchar
 2978               	uart_getchar:
 2979               	.LFB67:
  25:uart/uart.h   **** 
  26:uart/uart.h   **** // code for communicating with the gprs module via uart
  27:uart/uart.h   **** char uart_getchar (USART_t* USART) { 
 2980               		.loc 9 27 0
 2981               		.cfi_startproc
 2982               	.LVL162:
 2983               	/* prologue: function */
 2984               	/* frame size = 0 */
 2985               	/* stack size = 0 */
 2986               	.L__stack_usage = 0
 2987 0cb8 FC01      		movw r30,r24
 2988               	.LVL163:
 2989               	.L108:
  28:uart/uart.h   **** 
  29:uart/uart.h   ****     // Wait for the receive buffer to be empty 
  30:uart/uart.h   ****     while ( !( USART->STATUS & USART_RXCIF_bm) ); 
 2990               		.loc 9 30 0 discriminator 1
 2991 0cba 8181      		ldd r24,Z+1
 2992 0cbc 87FF      		sbrs r24,7
 2993 0cbe 00C0      		rjmp .L108
  31:uart/uart.h   **** 
  32:uart/uart.h   ****     // Receive char from receive buffer 
  33:uart/uart.h   ****     return USART->DATA; 
 2994               		.loc 9 33 0
 2995 0cc0 8081      		ld r24,Z
 2996               	/* epilogue start */
  34:uart/uart.h   **** } 
 2997               		.loc 9 34 0
 2998 0cc2 0895      		ret
 2999               		.cfi_endproc
 3000               	.LFE67:
 3002               	.global	send_uart
 3004               	send_uart:
 3005               	.LFB68:
  35:uart/uart.h   **** 
  36:uart/uart.h   **** void send_uart(char* text, USART_t* USART) {
 3006               		.loc 9 36 0
 3007               		.cfi_startproc
 3008               	.LVL164:
 3009 0cc4 4F92      		push r4
 3010               	.LCFI91:
 3011               		.cfi_def_cfa_offset 3
 3012               		.cfi_offset 4, -2
 3013 0cc6 5F92      		push r5
 3014               	.LCFI92:
 3015               		.cfi_def_cfa_offset 4
 3016               		.cfi_offset 5, -3
 3017 0cc8 6F92      		push r6
 3018               	.LCFI93:
 3019               		.cfi_def_cfa_offset 5
 3020               		.cfi_offset 6, -4
 3021 0cca 7F92      		push r7
 3022               	.LCFI94:
 3023               		.cfi_def_cfa_offset 6
 3024               		.cfi_offset 7, -5
 3025 0ccc 8F92      		push r8
 3026               	.LCFI95:
 3027               		.cfi_def_cfa_offset 7
 3028               		.cfi_offset 8, -6
 3029 0cce 9F92      		push r9
 3030               	.LCFI96:
 3031               		.cfi_def_cfa_offset 8
 3032               		.cfi_offset 9, -7
 3033 0cd0 AF92      		push r10
 3034               	.LCFI97:
 3035               		.cfi_def_cfa_offset 9
 3036               		.cfi_offset 10, -8
 3037 0cd2 BF92      		push r11
 3038               	.LCFI98:
 3039               		.cfi_def_cfa_offset 10
 3040               		.cfi_offset 11, -9
 3041 0cd4 CF92      		push r12
 3042               	.LCFI99:
 3043               		.cfi_def_cfa_offset 11
 3044               		.cfi_offset 12, -10
 3045 0cd6 DF92      		push r13
 3046               	.LCFI100:
 3047               		.cfi_def_cfa_offset 12
 3048               		.cfi_offset 13, -11
 3049 0cd8 EF92      		push r14
 3050               	.LCFI101:
 3051               		.cfi_def_cfa_offset 13
 3052               		.cfi_offset 14, -12
 3053 0cda FF92      		push r15
 3054               	.LCFI102:
 3055               		.cfi_def_cfa_offset 14
 3056               		.cfi_offset 15, -13
 3057 0cdc 0F93      		push r16
 3058               	.LCFI103:
 3059               		.cfi_def_cfa_offset 15
 3060               		.cfi_offset 16, -14
 3061 0cde 1F93      		push r17
 3062               	.LCFI104:
 3063               		.cfi_def_cfa_offset 16
 3064               		.cfi_offset 17, -15
 3065 0ce0 CF93      		push r28
 3066               	.LCFI105:
 3067               		.cfi_def_cfa_offset 17
 3068               		.cfi_offset 28, -16
 3069 0ce2 DF93      		push r29
 3070               	.LCFI106:
 3071               		.cfi_def_cfa_offset 18
 3072               		.cfi_offset 29, -17
 3073               	/* prologue: function */
 3074               	/* frame size = 0 */
 3075               	/* stack size = 16 */
 3076               	.L__stack_usage = 16
 3077 0ce4 EC01      		movw r28,r24
 3078 0ce6 7B01      		movw r14,r22
 3079               	.LVL165:
 3080               	.LBB1107:
 3081               	.LBB1108:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 3082               		.loc 7 16 0
 3083 0ce8 DC01      		movw r26,r24
 3084 0cea 0D90      		ld __tmp_reg__,X+
 3085 0cec 0020      		tst __tmp_reg__
 3086 0cee 01F4      		brne .-6
 3087 0cf0 CD01      		movw r24,r26
 3088               	.LVL166:
 3089 0cf2 8C1B      		sub r24,r28
 3090 0cf4 9D0B      		sbc r25,r29
 3091 0cf6 0196      		adiw r24,1
 3092 0cf8 0E94 0000 		call malloc
 3093               	.LVL167:
 3094 0cfc A92E      		mov r10,r25
 3095 0cfe C82E      		mov r12,r24
 3096 0d00 D92E      		mov r13,r25
 3097               	.LVL168:
  18:utils/utils.h ****     strcpy(result, s1);
 3098               		.loc 7 18 0
 3099 0d02 C601      		movw r24,r12
 3100 0d04 BE01      		movw r22,r28
 3101 0d06 0E94 0000 		call strcpy
  19:utils/utils.h ****     strcat(result, s2);
 3102               		.loc 7 19 0
 3103 0d0a AC2D      		mov r26,r12
 3104 0d0c BA2D      		mov r27,r10
 3105 0d0e FD01      		movw r30,r26
 3106 0d10 0190      		ld __tmp_reg__,Z+
 3107 0d12 0020      		tst __tmp_reg__
 3108 0d14 01F4      		brne .-6
 3109 0d16 3197      		sbiw r30,1
 3110 0d18 EA1B      		sub r30,r26
 3111 0d1a FB0B      		sbc r31,r27
 3112 0d1c EC0D      		add r30,r12
 3113 0d1e FD1D      		adc r31,r13
 3114 0d20 8DE0      		ldi r24,lo8(13)
 3115 0d22 90E0      		ldi r25,hi8(13)
 3116 0d24 8083      		st Z,r24
 3117 0d26 9183      		std Z+1,r25
 3118               	.LBE1108:
 3119               	.LBE1107:
 3120               	.LBB1109:
 3121               	.LBB1110:
 3122               	.LBB1111:
 3123               	.LBB1112:
 3124               	.LBB1113:
 3125               	.LBB1114:
 3126               	.LBB1115:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 3127               		.loc 4 57 0
 3128 0d28 D6E0      		ldi r29,lo8(6)
 3129               	.LBE1115:
 3130               	.LBE1114:
 3131               	.LBE1113:
 3132               	.LBE1112:
 3133               	.LBE1111:
 3134               	.LBB1126:
 3135               	.LBB1127:
 3136               	.LBB1128:
 3137               	.LBB1129:
 3138               	.LBB1130:
 3139               	.LBB1131:
 3140               	.LBB1132:
 3141               	.LBB1133:
 3142               	.LBB1134:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 3143               		.loc 5 220 0
 3144 0d2a 20E0      		ldi r18,lo8(endpoints+24)
 3145 0d2c 622E      		mov r6,r18
 3146 0d2e 20E0      		ldi r18,hi8(endpoints+24)
 3147 0d30 722E      		mov r7,r18
 3148               	.LBE1134:
 3149               	.LBE1133:
 3150               	.LBB1136:
 3151               	.LBB1137:
 3152               		.loc 4 91 0
 3153 0d32 30E0      		ldi r19,lo8(ep_in_pipe_buffer)
 3154 0d34 432E      		mov r4,r19
 3155 0d36 30E0      		ldi r19,hi8(ep_in_pipe_buffer)
 3156 0d38 532E      		mov r5,r19
 3157               	.LBE1137:
 3158               	.LBE1136:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 3159               		.loc 2 88 0
 3160 0d3a 12E0      		ldi r17,lo8(2)
 3161               	.LBB1140:
 3162               	.LBB1141:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 3163               		.loc 2 69 0
 3164 0d3c 41E0      		ldi r20,lo8(1)
 3165 0d3e A42E      		mov r10,r20
 3166 0d40 B12C      		mov r11,__zero_reg__
 3167               	.LBE1141:
 3168               	.LBE1140:
 3169               	.LBB1151:
 3170               	.LBB1152:
 3171               	.LBB1153:
 3172               	.LBB1154:
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3173               		.loc 5 169 0
 3174 0d42 50E4      		ldi r21,lo8(64)
 3175 0d44 852E      		mov r8,r21
 3176 0d46 912C      		mov r9,__zero_reg__
 3177               	.LVL169:
 3178               	.L154:
 3179               	.LBE1154:
 3180               	.LBE1153:
 3181               	.LBE1152:
 3182               	.LBE1151:
 3183               	.LBE1132:
 3184               	.LBE1131:
 3185               	.LBE1130:
 3186               	.LBE1129:
 3187               	.LBE1128:
 3188               	.LBE1127:
 3189               	.LBE1126:
 3190               	.LBE1110:
 3191               	.LBE1109:
  37:uart/uart.h   ****   char c;
  38:uart/uart.h   ****   char* new_text = concat(text, "\r");
  39:uart/uart.h   ****   while (*new_text != '\0') {  
 3192               		.loc 9 39 0 discriminator 1
 3193 0d48 D601      		movw r26,r12
 3194 0d4a CD91      		ld r28,X+
 3195 0d4c 6D01      		movw r12,r26
 3196 0d4e CC23      		tst r28
 3197 0d50 01F4      		brne .+2
 3198 0d52 00C0      		rjmp .L156
 3199               	.L129:
 3200               	.LVL170:
 3201               	.LBB1216:
 3202               	.LBB1217:
  14:uart/uart.h   ****     if (c == '\n') 
 3203               		.loc 9 14 0
 3204 0d54 CA30      		cpi r28,lo8(10)
 3205 0d56 01F4      		brne .+2
 3206 0d58 00C0      		rjmp .L157
 3207               	.L148:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 3208               		.loc 9 18 0
 3209 0d5a F701      		movw r30,r14
 3210 0d5c 8181      		ldd r24,Z+1
 3211 0d5e 85FF      		sbrs r24,5
 3212 0d60 00C0      		rjmp .L148
  21:uart/uart.h   ****     USART->DATA = c; 
 3213               		.loc 9 21 0
 3214 0d62 C083      		st Z,r28
 3215               	.LBE1217:
 3216               	.LBE1216:
  40:uart/uart.h   ****     uart_putchar(*new_text, USART);
  41:uart/uart.h   ****     new_text++;
  42:uart/uart.h   **** 
  43:uart/uart.h   ****     if (debug == 1) {
 3217               		.loc 9 43 0
 3218 0d64 8091 0000 		lds r24,debug
 3219 0d68 8130      		cpi r24,lo8(1)
 3220 0d6a 01F4      		brne .L154
 3221               	.L147:
 3222               	.LBB1219:
 3223               	.LBB1220:
  30:uart/uart.h   ****     while ( !( USART->STATUS & USART_RXCIF_bm) ); 
 3224               		.loc 9 30 0
 3225 0d6c D701      		movw r26,r14
 3226 0d6e 1196      		adiw r26,1
 3227 0d70 8C91      		ld r24,X
 3228 0d72 1197      		sbiw r26,1
 3229 0d74 87FF      		sbrs r24,7
 3230 0d76 00C0      		rjmp .L147
  33:uart/uart.h   ****     return USART->DATA; 
 3231               		.loc 9 33 0
 3232 0d78 2C91      		ld r18,X
 3233               	.LVL171:
 3234               	.L118:
 3235               	.LBE1220:
 3236               	.LBE1219:
 3237               	.LBB1221:
 3238               	.LBB1213:
 3239               	.LBB1206:
 3240               	.LBB1124:
 3241               	.LBB1122:
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 3242               		.loc 2 123 0
 3243 0d7a 9FB7      		in r25,__SREG__
 3244               	.LVL172:
 3245               	.LBB1117:
 3246               	.LBB1118:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 3247               		.loc 3 50 0
 3248               	/* #APP */
 3249               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 3250 0d7c F894      		cli
 3251               	 ;  0 "" 2
 3252               	.LVL173:
 3253               	/* #NOAPP */
 3254               	.LBE1118:
 3255               	.LBE1117:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 3256               		.loc 2 124 0
 3257 0d7e 8091 0000 		lds r24,ep_in_data+1
 3258 0d82 8823      		tst r24
 3259 0d84 01F4      		brne .+2
 3260 0d86 00C0      		rjmp .L158
 3261               	.L144:
 125:usb/usb_pipe.h **** 			r = false;
 3262               		.loc 2 125 0
 3263 0d88 80E0      		ldi r24,lo8(0)
 3264               	.L116:
 3265               	.LBB1119:
 3266               	.LBB1120:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 3267               		.loc 3 70 0
 3268 0d8a 9FBF      		out __SREG__,r25
 3269               		.loc 3 71 0
 3270               	.LBE1120:
 3271               	.LBE1119:
 3272               	.LBE1122:
 3273               	.LBE1124:
 3274               	.LBE1206:
  20:Framework.h   ****     while (!usb_pipe_can_write(&ep_in));
 3275               		.loc 1 20 0
 3276 0d8c 8823      		tst r24
 3277 0d8e 01F0      		breq .L118
 3278               	.LVL174:
 3279               	.LBB1207:
 3280               	.LBB1208:
 175:usb/usb_pipe.h **** 	p->pipe->data->write_ptr[p->data->packet_offset++] = v;
 3281               		.loc 2 175 0
 3282 0d90 8091 0000 		lds r24,ep_in_data+2
 3283 0d94 9091 0000 		lds r25,ep_in_data+2+1
 3284 0d98 E091 0000 		lds r30,ep_in_pipe_data+2
 3285 0d9c F091 0000 		lds r31,ep_in_pipe_data+2+1
 3286 0da0 E80F      		add r30,r24
 3287 0da2 F91F      		adc r31,r25
 3288 0da4 2083      		st Z,r18
 3289 0da6 0196      		adiw r24,1
 3290 0da8 8093 0000 		sts ep_in_data+2,r24
 3291 0dac 9093 0000 		sts ep_in_data+2+1,r25
 176:usb/usb_pipe.h **** 	if (p->data->packet_offset == p->pipe->size){
 3292               		.loc 2 176 0
 3293 0db0 8034      		cpi r24,64
 3294 0db2 9105      		cpc r25,__zero_reg__
 3295 0db4 01F4      		brne .L154
 3296               	.LBE1208:
 3297               	.LBE1207:
 3298               	.LBB1209:
 3299               	.LBB1203:
 3300               	.LBB1200:
 3301               	.LBB1197:
 177:usb/usb_pipe.h **** 		ATOMIC_BLOCK(PIPE_ATOMIC){
 3302               		.loc 2 177 0
 3303 0db6 AFB7      		in r26,__SREG__
 3304               	.LVL175:
 3305               	.LBB1188:
 3306               	.LBB1189:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 3307               		.loc 3 50 0
 3308               	/* #APP */
 3309               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 3310 0db8 F894      		cli
 3311               	 ;  0 "" 2
 3312               	.LVL176:
 3313               	/* #NOAPP */
 3314               	.LBE1189:
 3315               	.LBE1188:
 3316               		.loc 2 178 0
 3317 0dba 1092 0000 		sts ep_in_data+2,__zero_reg__
 3318 0dbe 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 3319               	.LVL177:
 3320               	.LBB1190:
 3321               	.LBB1191:
  81:usb/pipe.h    **** 	pipe->data->count += 1;
 3322               		.loc 4 81 0
 3323 0dc2 8091 0000 		lds r24,ep_in_pipe_data+4
 3324 0dc6 8F5F      		subi r24,lo8(-(1))
 3325 0dc8 8093 0000 		sts ep_in_pipe_data+4,r24
  82:usb/pipe.h    **** 	pipe->data->write_ptr += pipe->size;
 3326               		.loc 4 82 0
 3327 0dcc 8091 0000 		lds r24,ep_in_pipe_data+2
 3328 0dd0 9091 0000 		lds r25,ep_in_pipe_data+2+1
 3329 0dd4 805C      		subi r24,lo8(-(64))
 3330 0dd6 9F4F      		sbci r25,hi8(-(64))
 3331 0dd8 8093 0000 		sts ep_in_pipe_data+2,r24
 3332 0ddc 9093 0000 		sts ep_in_pipe_data+2+1,r25
  84:usb/pipe.h    **** 	if (pipe->data->write_ptr == &pipe->buffer[pipe->slots*pipe->size])
 3333               		.loc 4 84 0
 3334 0de0 B0E0      		ldi r27,hi8(ep_in_pipe_buffer+512)
 3335 0de2 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 3336 0de4 9B07      		cpc r25,r27
 3337 0de6 01F4      		brne .L119
  85:usb/pipe.h    **** 		pipe->data->write_ptr = &pipe->buffer[0];
 3338               		.loc 4 85 0
 3339 0de8 4092 0000 		sts ep_in_pipe_data+2,r4
 3340 0dec 5092 0000 		sts ep_in_pipe_data+2+1,r5
 3341               	.L119:
 3342               	.LVL178:
 3343               	.LBE1191:
 3344               	.LBE1190:
 3345               	.LBB1192:
 3346               	.LBB1185:
 3347               	.LBB1182:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 3348               		.loc 2 80 0
 3349 0df0 5FB7      		in r21,__SREG__
 3350               	.LVL179:
 3351               	.LBB1161:
 3352               	.LBB1162:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 3353               		.loc 3 50 0
 3354               	/* #APP */
 3355               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 3356 0df2 F894      		cli
 3357               	 ;  0 "" 2
 3358               	.LVL180:
 3359               	/* #NOAPP */
 3360               	.LBE1162:
 3361               	.LBE1161:
 3362               	.LBB1163:
 3363               	.LBB1135:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 3364               		.loc 5 220 0
 3365 0df4 8091 0000 		lds r24,endpoints+24
 3366 0df8 8670      		andi r24,lo8(6)
 3367               	.LBE1135:
 3368               	.LBE1163:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 3369               		.loc 2 82 0
 3370 0dfa 01F4      		brne .L159
 3371               	.LVL181:
 3372               	.L120:
 3373               	.LBB1164:
 3374               	.LBB1165:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 3375               		.loc 3 70 0
 3376 0dfc 5FBF      		out __SREG__,r21
 3377               		.loc 3 71 0
 3378               	.LVL182:
 3379               	.LBE1165:
 3380               	.LBE1164:
 3381               	.LBE1182:
 3382               	.LBE1185:
 3383               	.LBE1192:
 3384               	.LBB1193:
 3385               	.LBB1194:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 3386               		.loc 3 70 0
 3387 0dfe AFBF      		out __SREG__,r26
 3388               		.loc 3 71 0
 3389               	.LBE1194:
 3390               	.LBE1193:
 3391               	.LBE1197:
 3392               	.LBE1200:
 3393               	.LBE1203:
 3394               	.LBE1209:
 3395               	.LBE1213:
 3396               	.LBE1221:
  39:uart/uart.h   ****   while (*new_text != '\0') {  
 3397               		.loc 9 39 0
 3398 0e00 D601      		movw r26,r12
 3399               	.LVL183:
 3400 0e02 CD91      		ld r28,X+
 3401               	.LVL184:
 3402 0e04 6D01      		movw r12,r26
 3403 0e06 CC23      		tst r28
 3404 0e08 01F0      		breq .+2
 3405 0e0a 00C0      		rjmp .L129
 3406               	.LVL185:
 3407               	.L156:
  44:uart/uart.h   ****       c = uart_getchar(USART);
  45:uart/uart.h   ****       send_byte(c);
  46:uart/uart.h   ****     }
  47:uart/uart.h   ****   }
  48:uart/uart.h   ****   if (debug == 1) {
 3408               		.loc 9 48 0
 3409 0e0c 8091 0000 		lds r24,debug
 3410 0e10 8130      		cpi r24,lo8(1)
 3411 0e12 01F4      		brne .+2
 3412 0e14 00C0      		rjmp .L160
 3413               	.L110:
 3414               	/* epilogue start */
  49:uart/uart.h   ****     break_and_flush();
  50:uart/uart.h   ****   }
  51:uart/uart.h   **** }
 3415               		.loc 9 51 0
 3416 0e16 DF91      		pop r29
 3417 0e18 CF91      		pop r28
 3418 0e1a 1F91      		pop r17
 3419 0e1c 0F91      		pop r16
 3420 0e1e FF90      		pop r15
 3421 0e20 EF90      		pop r14
 3422               	.LVL186:
 3423 0e22 DF90      		pop r13
 3424 0e24 CF90      		pop r12
 3425 0e26 BF90      		pop r11
 3426 0e28 AF90      		pop r10
 3427 0e2a 9F90      		pop r9
 3428 0e2c 8F90      		pop r8
 3429 0e2e 7F90      		pop r7
 3430 0e30 6F90      		pop r6
 3431 0e32 5F90      		pop r5
 3432 0e34 4F90      		pop r4
 3433 0e36 0895      		ret
 3434               	.LVL187:
 3435               	.L158:
 3436               	.LBB1222:
 3437               	.LBB1214:
 3438               	.LBB1210:
 3439               	.LBB1125:
 3440               	.LBB1123:
 3441               	.LBB1121:
 3442               	.LBB1116:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 3443               		.loc 4 57 0
 3444 0e38 8091 0000 		lds r24,ep_in_pipe_data+4
 3445 0e3c 3D2F      		mov r19,r29
 3446 0e3e 381B      		sub r19,r24
 3447               	.LBE1116:
 3448               	.LBE1121:
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 3449               		.loc 2 127 0
 3450 0e40 81E0      		ldi r24,lo8(1)
 3451 0e42 1316      		cp __zero_reg__,r19
 3452 0e44 04F4      		brge .+2
 3453 0e46 00C0      		rjmp .L116
 3454 0e48 00C0      		rjmp .L144
 3455               	.LVL188:
 3456               	.L159:
 3457               	.LBE1123:
 3458               	.LBE1125:
 3459               	.LBE1210:
 3460               	.LBB1211:
 3461               	.LBB1204:
 3462               	.LBB1201:
 3463               	.LBB1198:
 3464               	.LBB1195:
 3465               	.LBB1186:
 3466               	.LBB1183:
 3467               	.LBB1166:
 3468               	.LBB1167:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 3469               		.loc 4 51 0
 3470 0e4a 4091 0000 		lds r20,ep_in_pipe_data+4
 3471               	.LBE1167:
 3472               	.LBE1166:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 3473               		.loc 2 83 0
 3474 0e4e 1416      		cp __zero_reg__,r20
 3475 0e50 04F0      		brlt .+2
 3476 0e52 00C0      		rjmp .L121
 3477               	.LBB1168:
 3478               	.LBB1169:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 3479               		.loc 4 62 0
 3480 0e54 2091 0000 		lds r18,ep_in_pipe_data
 3481 0e58 3091 0000 		lds r19,ep_in_pipe_data+1
 3482               	.LVL189:
 3483               	.LBE1169:
 3484               	.LBE1168:
 3485               	.LBB1170:
 3486               	.LBB1159:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 3487               		.loc 2 68 0
 3488 0e5c 6091 0000 		lds r22,ep_in_data
 3489               	.LVL190:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 3490               		.loc 2 69 0
 3491 0e60 862F      		mov r24,r22
 3492 0e62 90E0      		ldi r25,lo8(0)
 3493               	.LVL191:
 3494 0e64 71E0      		ldi r23,lo8(1)
 3495 0e66 8A15      		cp r24,r10
 3496 0e68 9B05      		cpc r25,r11
 3497 0e6a 01F4      		brne .L122
 3498 0e6c 70E0      		ldi r23,lo8(0)
 3499               	.L122:
 3500 0e6e 7093 0000 		sts ep_in_data,r23
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 3501               		.loc 2 72 0
 3502 0e72 6623      		tst r22
 3503 0e74 01F4      		brne .L123
 3504               	.LVL192:
 3505               	.LBB1156:
 3506               	.LBB1157:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3507               		.loc 5 168 0
 3508 0e76 2093 0000 		sts endpoints+28,r18
 3509 0e7a 3093 0000 		sts endpoints+28+1,r19
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3510               		.loc 5 169 0
 3511 0e7e 8092 0000 		sts endpoints+26,r8
 3512 0e82 9092 0000 		sts endpoints+26+1,r9
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 3513               		.loc 5 174 0
 3514 0e86 F301      		movw r30,r6
 3515               	.LVL193:
 3516               	/* #APP */
 3517               	 ;  174 "usb/usb.h" 1
 3518 0e88 02E2      		ldi r16, 34
 3519 0e8a 0693      		.dc.w 0x9306
 3520               		
 3521               	 ;  0 "" 2
 3522               	.LVL194:
 3523               	/* #NOAPP */
 3524               	.L124:
 3525               	.LBE1157:
 3526               	.LBE1156:
 3527               	.LBE1159:
 3528               	.LBE1170:
 3529               	.LBB1171:
 3530               	.LBB1172:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 3531               		.loc 4 72 0
 3532 0e8c 4150      		subi r20,lo8(-(-1))
 3533 0e8e 4093 0000 		sts ep_in_pipe_data+4,r20
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 3534               		.loc 4 73 0
 3535 0e92 C901      		movw r24,r18
 3536 0e94 805C      		subi r24,lo8(-(64))
 3537 0e96 9F4F      		sbci r25,hi8(-(64))
 3538 0e98 8093 0000 		sts ep_in_pipe_data,r24
 3539 0e9c 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 3540               		.loc 4 75 0
 3541 0ea0 F0E0      		ldi r31,hi8(ep_in_pipe_buffer+512)
 3542 0ea2 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 3543 0ea4 9F07      		cpc r25,r31
 3544 0ea6 01F0      		breq .+2
 3545 0ea8 00C0      		rjmp .L120
 3546               	.LBE1172:
 3547               	.LBE1171:
 3548               	.LBB1173:
 3549               	.LBB1138:
 3550               		.loc 4 91 0
 3551 0eaa 4092 0000 		sts ep_in_pipe_data,r4
 3552 0eae 5092 0000 		sts ep_in_pipe_data+1,r5
 3553               	.LVL195:
 3554 0eb2 00C0      		rjmp .L120
 3555               	.LVL196:
 3556               	.L123:
 3557               	.LBE1138:
 3558               	.LBE1173:
 3559               	.LBB1174:
 3560               	.LBB1160:
 3561               	.LBB1158:
 3562               	.LBB1155:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3563               		.loc 5 168 0
 3564 0eb4 2093 0000 		sts endpoints+20,r18
 3565 0eb8 3093 0000 		sts endpoints+20+1,r19
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3566               		.loc 5 169 0
 3567 0ebc 8092 0000 		sts endpoints+18,r8
 3568 0ec0 9092 0000 		sts endpoints+18+1,r9
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 3569               		.loc 5 176 0
 3570 0ec4 F301      		movw r30,r6
 3571               	.LVL197:
 3572               	/* #APP */
 3573               	 ;  176 "usb/usb.h" 1
 3574 0ec6 04E1      		ldi r16, 20
 3575 0ec8 0693      		.dc.w 0x9306
 3576               		
 3577               	 ;  0 "" 2
 3578               	/* #NOAPP */
 3579 0eca 00C0      		rjmp .L124
 3580               	.LVL198:
 3581               	.L121:
 3582               	.LBE1155:
 3583               	.LBE1158:
 3584               	.LBE1160:
 3585               	.LBE1174:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 3586               		.loc 2 87 0
 3587 0ecc 8091 0000 		lds r24,ep_in_data+1
 3588 0ed0 8130      		cpi r24,lo8(1)
 3589 0ed2 01F0      		breq .L161
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 3590               		.loc 2 91 0
 3591 0ed4 8230      		cpi r24,lo8(2)
 3592 0ed6 01F0      		breq .+2
 3593 0ed8 00C0      		rjmp .L120
 3594               	.LVL199:
 3595               	.LBB1175:
 3596               	.LBB1176:
 3597               	.LBB1177:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 3598               		.loc 5 228 0
 3599 0eda 8091 0000 		lds r24,endpoints+24
 3600 0ede 8670      		andi r24,lo8(6)
 3601               	.LBE1177:
 3602               	.LBE1176:
 3603               	.LBE1175:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 3604               		.loc 2 91 0
 3605 0ee0 8630      		cpi r24,lo8(6)
 3606 0ee2 01F0      		breq .+2
 3607 0ee4 00C0      		rjmp .L120
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 3608               		.loc 2 92 0
 3609 0ee6 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 3610               		.loc 2 93 0
 3611 0eea 1092 0000 		sts ep_in_data+2,__zero_reg__
 3612 0eee 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 3613               	.LBB1178:
 3614               	.LBB1139:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 3615               		.loc 4 90 0
 3616 0ef2 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 3617               		.loc 4 91 0
 3618 0ef6 4092 0000 		sts ep_in_pipe_data+2,r4
 3619 0efa 5092 0000 		sts ep_in_pipe_data+2+1,r5
 3620 0efe 4092 0000 		sts ep_in_pipe_data,r4
 3621 0f02 5092 0000 		sts ep_in_pipe_data+1,r5
 3622               	.LVL200:
 3623 0f06 00C0      		rjmp .L120
 3624               	.LVL201:
 3625               	.L157:
 3626               	.LBE1139:
 3627               	.LBE1178:
 3628               	.LBE1183:
 3629               	.LBE1186:
 3630               	.LBE1195:
 3631               	.LBE1198:
 3632               	.LBE1201:
 3633               	.LBE1204:
 3634               	.LBE1211:
 3635               	.LBE1214:
 3636               	.LBE1222:
 3637               	.LBB1223:
 3638               	.LBB1218:
  15:uart/uart.h   ****         uart_putchar('\r', USART); 
 3639               		.loc 9 15 0
 3640 0f08 8DE0      		ldi r24,lo8(13)
 3641 0f0a B701      		movw r22,r14
 3642 0f0c 0E94 0000 		call uart_putchar
 3643 0f10 00C0      		rjmp .L148
 3644               	.LVL202:
 3645               	.L161:
 3646               	.LBE1218:
 3647               	.LBE1223:
 3648               	.LBB1224:
 3649               	.LBB1215:
 3650               	.LBB1212:
 3651               	.LBB1205:
 3652               	.LBB1202:
 3653               	.LBB1199:
 3654               	.LBB1196:
 3655               	.LBB1187:
 3656               	.LBB1184:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 3657               		.loc 2 88 0
 3658 0f12 1093 0000 		sts ep_in_data+1,r17
 3659               	.LBB1179:
 3660               	.LBB1180:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 3661               		.loc 4 62 0
 3662 0f16 7091 0000 		lds r23,ep_in_pipe_data
 3663 0f1a E091 0000 		lds r30,ep_in_pipe_data+1
 3664               	.LBE1180:
 3665               	.LBE1179:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 3666               		.loc 2 90 0
 3667 0f1e 2091 0000 		lds r18,ep_in_data+2
 3668 0f22 3091 0000 		lds r19,ep_in_data+2+1
 3669               	.LVL203:
 3670               	.LBB1181:
 3671               	.LBB1150:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 3672               		.loc 2 68 0
 3673 0f26 6091 0000 		lds r22,ep_in_data
 3674               	.LVL204:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 3675               		.loc 2 69 0
 3676 0f2a 862F      		mov r24,r22
 3677 0f2c 90E0      		ldi r25,lo8(0)
 3678               	.LVL205:
 3679 0f2e 41E0      		ldi r20,lo8(1)
 3680 0f30 8A15      		cp r24,r10
 3681 0f32 9B05      		cpc r25,r11
 3682 0f34 01F0      		breq .L162
 3683 0f36 4093 0000 		sts ep_in_data,r20
 3684               	.LBB1142:
 3685               	.LBB1143:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3686               		.loc 5 168 0
 3687 0f3a 872F      		mov r24,r23
 3688 0f3c 9E2F      		mov r25,r30
 3689               	.LBE1143:
 3690               	.LBE1142:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 3691               		.loc 2 72 0
 3692 0f3e 6623      		tst r22
 3693 0f40 01F4      		brne .L128
 3694               	.L163:
 3695               	.LVL206:
 3696               	.LBB1146:
 3697               	.LBB1144:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3698               		.loc 5 168 0
 3699 0f42 8093 0000 		sts endpoints+28,r24
 3700 0f46 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3701               		.loc 5 169 0
 3702 0f4a 2093 0000 		sts endpoints+26,r18
 3703 0f4e 3093 0000 		sts endpoints+26+1,r19
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 3704               		.loc 5 174 0
 3705 0f52 F301      		movw r30,r6
 3706               	/* #APP */
 3707               	 ;  174 "usb/usb.h" 1
 3708 0f54 02E2      		ldi r16, 34
 3709 0f56 0693      		.dc.w 0x9306
 3710               		
 3711               	 ;  0 "" 2
 3712               	/* #NOAPP */
 3713 0f58 00C0      		rjmp .L120
 3714               	.LVL207:
 3715               	.L128:
 3716               	.LBE1144:
 3717               	.LBE1146:
 3718               	.LBB1147:
 3719               	.LBB1148:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3720               		.loc 5 168 0
 3721 0f5a 8093 0000 		sts endpoints+20,r24
 3722 0f5e 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3723               		.loc 5 169 0
 3724 0f62 2093 0000 		sts endpoints+18,r18
 3725 0f66 3093 0000 		sts endpoints+18+1,r19
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 3726               		.loc 5 176 0
 3727 0f6a F301      		movw r30,r6
 3728               	/* #APP */
 3729               	 ;  176 "usb/usb.h" 1
 3730 0f6c 04E1      		ldi r16, 20
 3731 0f6e 0693      		.dc.w 0x9306
 3732               		
 3733               	 ;  0 "" 2
 3734               	/* #NOAPP */
 3735 0f70 00C0      		rjmp .L120
 3736               	.LVL208:
 3737               	.L162:
 3738               	.LBE1148:
 3739               	.LBE1147:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 3740               		.loc 2 69 0
 3741 0f72 40E0      		ldi r20,lo8(0)
 3742 0f74 4093 0000 		sts ep_in_data,r20
 3743               	.LBB1149:
 3744               	.LBB1145:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3745               		.loc 5 168 0
 3746 0f78 872F      		mov r24,r23
 3747 0f7a 9E2F      		mov r25,r30
 3748               	.LBE1145:
 3749               	.LBE1149:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 3750               		.loc 2 72 0
 3751 0f7c 6623      		tst r22
 3752 0f7e 01F4      		brne .L128
 3753 0f80 00C0      		rjmp .L163
 3754               	.LVL209:
 3755               	.L160:
 3756               	.LBE1150:
 3757               	.LBE1181:
 3758               	.LBE1184:
 3759               	.LBE1187:
 3760               	.LBE1196:
 3761               	.LBE1199:
 3762               	.LBE1202:
 3763               	.LBE1205:
 3764               	.LBE1212:
 3765               	.LBE1215:
 3766               	.LBE1224:
 3767               	.LBB1225:
 3768               	.LBB1226:
 3769               	.LBB1227:
 3770               	.LBB1228:
 110:usb/usb_pipe.h **** 	p->data->flush = 1;
 3771               		.loc 2 110 0
 3772 0f82 8093 0000 		sts ep_in_data+1,r24
 3773               	.LVL210:
 3774               	.LBB1229:
 3775               	.LBB1230:
 3776               	.LBB1231:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 3777               		.loc 2 80 0
 3778 0f86 2FB7      		in r18,__SREG__
 3779               	.LVL211:
 3780               	.LBB1232:
 3781               	.LBB1233:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 3782               		.loc 3 50 0
 3783               	/* #APP */
 3784               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 3785 0f88 F894      		cli
 3786               	 ;  0 "" 2
 3787               	.LVL212:
 3788               	/* #NOAPP */
 3789               	.LBE1233:
 3790               	.LBE1232:
 3791               	.LBB1234:
 3792               	.LBB1235:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 3793               		.loc 5 220 0
 3794 0f8a 8091 0000 		lds r24,endpoints+24
 3795 0f8e 8670      		andi r24,lo8(6)
 3796               	.LBE1235:
 3797               	.LBE1234:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 3798               		.loc 2 82 0
 3799 0f90 01F0      		breq .+2
 3800 0f92 00C0      		rjmp .L164
 3801               	.LVL213:
 3802               	.L131:
 3803               	.LBB1236:
 3804               	.LBB1237:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 3805               		.loc 3 70 0
 3806 0f94 2FBF      		out __SREG__,r18
 3807               		.loc 3 71 0
 3808               	.LBE1237:
 3809               	.LBE1236:
 3810               	.LBE1231:
 3811               	.LBE1230:
 3812               	.LBE1229:
 3813               	.LBE1228:
 3814               	.LBE1227:
  27:Framework.h   ****     USB.INTFLAGSBSET = USB_TRNIF_bm;
 3815               		.loc 1 27 0
 3816 0f96 82E0      		ldi r24,lo8(2)
 3817 0f98 E0EC      		ldi r30,lo8(1216)
 3818 0f9a F4E0      		ldi r31,hi8(1216)
 3819 0f9c 8587      		std Z+13,r24
 3820               	.LBB1269:
 3821               	.LBB1270:
 3822               	.LBB1271:
 3823               	.LBB1272:
 3824               	.LBB1273:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 3825               		.loc 4 57 0
 3826 0f9e 36E0      		ldi r19,lo8(6)
 3827               	.LVL214:
 3828               	.L140:
 3829               	.LBE1273:
 3830               	.LBE1272:
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 3831               		.loc 2 123 0
 3832 0fa0 9FB7      		in r25,__SREG__
 3833               	.LVL215:
 3834               	.LBB1275:
 3835               	.LBB1276:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 3836               		.loc 3 50 0
 3837               	/* #APP */
 3838               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 3839 0fa2 F894      		cli
 3840               	 ;  0 "" 2
 3841               	.LVL216:
 3842               	/* #NOAPP */
 3843               	.LBE1276:
 3844               	.LBE1275:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 3845               		.loc 2 124 0
 3846 0fa4 8091 0000 		lds r24,ep_in_data+1
 3847 0fa8 8823      		tst r24
 3848 0faa 01F0      		breq .L165
 3849               	.L145:
 125:usb/usb_pipe.h **** 			r = false;
 3850               		.loc 2 125 0
 3851 0fac 80E0      		ldi r24,lo8(0)
 3852               	.L141:
 3853               	.LBB1277:
 3854               	.LBB1278:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 3855               		.loc 3 70 0
 3856 0fae 9FBF      		out __SREG__,r25
 3857               		.loc 3 71 0
 3858               	.LBE1278:
 3859               	.LBE1277:
 3860               	.LBE1271:
 3861               	.LBE1270:
 3862               	.LBE1269:
  28:Framework.h   ****     while (!usb_pipe_can_write(&ep_in)){
 3863               		.loc 1 28 0
 3864 0fb0 8823      		tst r24
 3865 0fb2 01F0      		breq .+2
 3866 0fb4 00C0      		rjmp .L110
  29:Framework.h   ****         if (timeout_or_sampling_no_longer_enabled){
 3867               		.loc 1 29 0
 3868 0fb6 8091 0000 		lds r24,timeout_or_sampling_no_longer_enabled
 3869 0fba 8823      		tst r24
 3870 0fbc 01F0      		breq .L140
 3871               	.LVL217:
 3872               	.LBB1282:
 3873               	.LBB1283:
 3874               	.LBB1284:
  54:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 3875               		.loc 2 54 0
 3876 0fbe 2FB7      		in r18,__SREG__
 3877               	.LVL218:
 3878               	.LBB1285:
 3879               	.LBB1286:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 3880               		.loc 3 50 0
 3881               	/* #APP */
 3882               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 3883 0fc0 F894      		cli
 3884               	 ;  0 "" 2
 3885               	.LVL219:
 3886               	/* #NOAPP */
 3887               	.LBE1286:
 3888               	.LBE1285:
 3889               	.LBB1287:
 3890               	.LBB1288:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 3891               		.loc 4 90 0
 3892 0fc2 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 3893               		.loc 4 91 0
 3894 0fc6 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 3895 0fc8 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 3896 0fca 8093 0000 		sts ep_in_pipe_data+2,r24
 3897 0fce 9093 0000 		sts ep_in_pipe_data+2+1,r25
 3898 0fd2 8093 0000 		sts ep_in_pipe_data,r24
 3899 0fd6 9093 0000 		sts ep_in_pipe_data+1,r25
 3900               	.LVL220:
 3901               	.LBE1288:
 3902               	.LBE1287:
 3903               	.LBB1289:
 3904               	.LBB1290:
 158:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 3905               		.loc 5 158 0
 3906 0fda E0E0      		ldi r30,lo8(endpoints+24)
 3907 0fdc F0E0      		ldi r31,hi8(endpoints+24)
 3908               	/* #APP */
 3909               	 ;  158 "usb/usb.h" 1
 3910 0fde 06E0      		ldi r16, 6
 3911 0fe0 0593      		.dc.w 0x9305
 3912               		
 3913               	 ;  0 "" 2
 159:usb/usb.h     **** 		LACR16(&e->STATUS, USB_EP_BANK_bm);
 3914               		.loc 5 159 0
 3915               	 ;  159 "usb/usb.h" 1
 3916 0fe2 08E0      		ldi r16, 8
 3917 0fe4 0693      		.dc.w 0x9306
 3918               		
 3919               	 ;  0 "" 2
 3920               	/* #NOAPP */
 3921               	.LBE1290:
 3922               	.LBE1289:
  57:usb/usb_pipe.h **** 		p->data->flush = 0;
 3923               		.loc 2 57 0
 3924 0fe6 1092 0000 		sts ep_in_data+1,__zero_reg__
  58:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
 3925               		.loc 2 58 0
 3926 0fea 1092 0000 		sts ep_in_data+2,__zero_reg__
 3927 0fee 1092 0000 		sts ep_in_data+2+1,__zero_reg__
  59:usb/usb_pipe.h **** 		p->data->bank = 0;
 3928               		.loc 2 59 0
 3929 0ff2 1092 0000 		sts ep_in_data,__zero_reg__
 3930               	.LVL221:
 3931               	.LBB1291:
 3932               	.LBB1292:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 3933               		.loc 3 70 0
 3934 0ff6 2FBF      		out __SREG__,r18
 3935               		.loc 3 71 0
 3936 0ff8 00C0      		rjmp .L110
 3937               	.LVL222:
 3938               	.L165:
 3939               	.LBE1292:
 3940               	.LBE1291:
 3941               	.LBE1284:
 3942               	.LBE1283:
 3943               	.LBE1282:
 3944               	.LBB1293:
 3945               	.LBB1281:
 3946               	.LBB1280:
 3947               	.LBB1279:
 3948               	.LBB1274:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 3949               		.loc 4 57 0
 3950 0ffa 8091 0000 		lds r24,ep_in_pipe_data+4
 3951 0ffe 232F      		mov r18,r19
 3952 1000 281B      		sub r18,r24
 3953               	.LBE1274:
 3954               	.LBE1279:
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 3955               		.loc 2 127 0
 3956 1002 81E0      		ldi r24,lo8(1)
 3957 1004 1216      		cp __zero_reg__,r18
 3958 1006 04F0      		brlt .L141
 3959 1008 00C0      		rjmp .L145
 3960               	.LVL223:
 3961               	.L164:
 3962               	.LBE1280:
 3963               	.LBE1281:
 3964               	.LBE1293:
 3965               	.LBB1294:
 3966               	.LBB1268:
 3967               	.LBB1267:
 3968               	.LBB1266:
 3969               	.LBB1265:
 3970               	.LBB1238:
 3971               	.LBB1239:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 3972               		.loc 4 51 0
 3973 100a 3091 0000 		lds r19,ep_in_pipe_data+4
 3974               	.LBE1239:
 3975               	.LBE1238:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 3976               		.loc 2 83 0
 3977 100e 1316      		cp __zero_reg__,r19
 3978 1010 04F0      		brlt .+2
 3979 1012 00C0      		rjmp .L132
 3980               	.LBB1240:
 3981               	.LBB1241:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 3982               		.loc 4 62 0
 3983 1014 8091 0000 		lds r24,ep_in_pipe_data
 3984 1018 9091 0000 		lds r25,ep_in_pipe_data+1
 3985               	.LVL224:
 3986               	.LBE1241:
 3987               	.LBE1240:
 3988               	.LBB1242:
 3989               	.LBB1243:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 3990               		.loc 2 68 0
 3991 101c 4091 0000 		lds r20,ep_in_data
 3992               	.LVL225:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 3993               		.loc 2 69 0
 3994 1020 51E0      		ldi r21,lo8(1)
 3995 1022 4130      		cpi r20,lo8(1)
 3996 1024 01F4      		brne .L133
 3997 1026 50E0      		ldi r21,lo8(0)
 3998               	.L133:
 3999 1028 5093 0000 		sts ep_in_data,r21
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 4000               		.loc 2 72 0
 4001 102c 4423      		tst r20
 4002 102e 01F4      		brne .L134
 4003               	.LVL226:
 4004               	.LBB1244:
 4005               	.LBB1245:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 4006               		.loc 5 168 0
 4007 1030 8093 0000 		sts endpoints+28,r24
 4008 1034 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 4009               		.loc 5 169 0
 4010 1038 40E4      		ldi r20,lo8(64)
 4011 103a 50E0      		ldi r21,hi8(64)
 4012 103c 4093 0000 		sts endpoints+26,r20
 4013 1040 5093 0000 		sts endpoints+26+1,r21
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 4014               		.loc 5 174 0
 4015 1044 E0E0      		ldi r30,lo8(endpoints+24)
 4016 1046 F0E0      		ldi r31,hi8(endpoints+24)
 4017               	/* #APP */
 4018               	 ;  174 "usb/usb.h" 1
 4019 1048 02E2      		ldi r16, 34
 4020 104a 0693      		.dc.w 0x9306
 4021               		
 4022               	 ;  0 "" 2
 4023               	.LVL227:
 4024               	/* #NOAPP */
 4025               	.L135:
 4026               	.LBE1245:
 4027               	.LBE1244:
 4028               	.LBE1243:
 4029               	.LBE1242:
 4030               	.LBB1249:
 4031               	.LBB1250:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 4032               		.loc 4 72 0
 4033 104c 3150      		subi r19,lo8(-(-1))
 4034 104e 3093 0000 		sts ep_in_pipe_data+4,r19
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 4035               		.loc 4 73 0
 4036 1052 805C      		subi r24,lo8(-(64))
 4037 1054 9F4F      		sbci r25,hi8(-(64))
 4038 1056 8093 0000 		sts ep_in_pipe_data,r24
 4039 105a 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 4040               		.loc 4 75 0
 4041 105e B0E0      		ldi r27,hi8(ep_in_pipe_buffer+512)
 4042 1060 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 4043 1062 9B07      		cpc r25,r27
 4044 1064 01F0      		breq .+2
 4045 1066 00C0      		rjmp .L131
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
 4046               		.loc 4 76 0
 4047 1068 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 4048 106a 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 4049 106c 8093 0000 		sts ep_in_pipe_data,r24
 4050 1070 9093 0000 		sts ep_in_pipe_data+1,r25
 4051 1074 00C0      		rjmp .L131
 4052               	.LVL228:
 4053               	.L134:
 4054               	.LBE1250:
 4055               	.LBE1249:
 4056               	.LBB1251:
 4057               	.LBB1248:
 4058               	.LBB1246:
 4059               	.LBB1247:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 4060               		.loc 5 168 0
 4061 1076 8093 0000 		sts endpoints+20,r24
 4062 107a 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 4063               		.loc 5 169 0
 4064 107e 40E4      		ldi r20,lo8(64)
 4065 1080 50E0      		ldi r21,hi8(64)
 4066 1082 4093 0000 		sts endpoints+18,r20
 4067 1086 5093 0000 		sts endpoints+18+1,r21
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 4068               		.loc 5 176 0
 4069 108a E0E0      		ldi r30,lo8(endpoints+24)
 4070 108c F0E0      		ldi r31,hi8(endpoints+24)
 4071               	/* #APP */
 4072               	 ;  176 "usb/usb.h" 1
 4073 108e 04E1      		ldi r16, 20
 4074 1090 0693      		.dc.w 0x9306
 4075               		
 4076               	 ;  0 "" 2
 4077               	/* #NOAPP */
 4078 1092 00C0      		rjmp .L135
 4079               	.LVL229:
 4080               	.L132:
 4081               	.LBE1247:
 4082               	.LBE1246:
 4083               	.LBE1248:
 4084               	.LBE1251:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 4085               		.loc 2 87 0
 4086 1094 8091 0000 		lds r24,ep_in_data+1
 4087 1098 8130      		cpi r24,lo8(1)
 4088 109a 01F0      		breq .L166
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 4089               		.loc 2 91 0
 4090 109c 8230      		cpi r24,lo8(2)
 4091 109e 01F0      		breq .+2
 4092 10a0 00C0      		rjmp .L131
 4093               	.LVL230:
 4094               	.LBB1252:
 4095               	.LBB1253:
 4096               	.LBB1254:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 4097               		.loc 5 228 0
 4098 10a2 8091 0000 		lds r24,endpoints+24
 4099 10a6 8670      		andi r24,lo8(6)
 4100               	.LBE1254:
 4101               	.LBE1253:
 4102               	.LBE1252:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 4103               		.loc 2 91 0
 4104 10a8 8630      		cpi r24,lo8(6)
 4105 10aa 01F0      		breq .+2
 4106 10ac 00C0      		rjmp .L131
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 4107               		.loc 2 92 0
 4108 10ae 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 4109               		.loc 2 93 0
 4110 10b2 1092 0000 		sts ep_in_data+2,__zero_reg__
 4111 10b6 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 4112               	.LBB1255:
 4113               	.LBB1256:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 4114               		.loc 4 90 0
 4115 10ba 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 4116               		.loc 4 91 0
 4117 10be 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 4118 10c0 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 4119 10c2 8093 0000 		sts ep_in_pipe_data+2,r24
 4120 10c6 9093 0000 		sts ep_in_pipe_data+2+1,r25
 4121 10ca 8093 0000 		sts ep_in_pipe_data,r24
 4122 10ce 9093 0000 		sts ep_in_pipe_data+1,r25
 4123               	.LVL231:
 4124 10d2 00C0      		rjmp .L131
 4125               	.LVL232:
 4126               	.L166:
 4127               	.LBE1256:
 4128               	.LBE1255:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 4129               		.loc 2 88 0
 4130 10d4 82E0      		ldi r24,lo8(2)
 4131 10d6 8093 0000 		sts ep_in_data+1,r24
 4132               	.LBB1257:
 4133               	.LBB1258:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 4134               		.loc 4 62 0
 4135 10da 6091 0000 		lds r22,ep_in_pipe_data
 4136 10de 3091 0000 		lds r19,ep_in_pipe_data+1
 4137               	.LBE1258:
 4138               	.LBE1257:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 4139               		.loc 2 90 0
 4140 10e2 4091 0000 		lds r20,ep_in_data+2
 4141 10e6 5091 0000 		lds r21,ep_in_data+2+1
 4142               	.LVL233:
 4143               	.LBB1259:
 4144               	.LBB1260:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 4145               		.loc 2 68 0
 4146 10ea 8091 0000 		lds r24,ep_in_data
 4147               	.LVL234:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 4148               		.loc 2 69 0
 4149 10ee 91E0      		ldi r25,lo8(1)
 4150 10f0 8130      		cpi r24,lo8(1)
 4151 10f2 01F4      		brne .L138
 4152 10f4 90E0      		ldi r25,lo8(0)
 4153               	.L138:
 4154 10f6 9093 0000 		sts ep_in_data,r25
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 4155               		.loc 2 72 0
 4156 10fa 8823      		tst r24
 4157 10fc 01F4      		brne .L139
 4158               	.LVL235:
 4159               	.LBB1261:
 4160               	.LBB1262:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 4161               		.loc 5 168 0
 4162 10fe 862F      		mov r24,r22
 4163 1100 932F      		mov r25,r19
 4164 1102 8093 0000 		sts endpoints+28,r24
 4165 1106 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 4166               		.loc 5 169 0
 4167 110a 4093 0000 		sts endpoints+26,r20
 4168 110e 5093 0000 		sts endpoints+26+1,r21
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 4169               		.loc 5 174 0
 4170 1112 E0E0      		ldi r30,lo8(endpoints+24)
 4171 1114 F0E0      		ldi r31,hi8(endpoints+24)
 4172               	/* #APP */
 4173               	 ;  174 "usb/usb.h" 1
 4174 1116 02E2      		ldi r16, 34
 4175 1118 0693      		.dc.w 0x9306
 4176               		
 4177               	 ;  0 "" 2
 4178               	/* #NOAPP */
 4179 111a 00C0      		rjmp .L131
 4180               	.LVL236:
 4181               	.L139:
 4182               	.LBE1262:
 4183               	.LBE1261:
 4184               	.LBB1263:
 4185               	.LBB1264:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 4186               		.loc 5 168 0
 4187 111c 862F      		mov r24,r22
 4188 111e 932F      		mov r25,r19
 4189 1120 8093 0000 		sts endpoints+20,r24
 4190 1124 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 4191               		.loc 5 169 0
 4192 1128 4093 0000 		sts endpoints+18,r20
 4193 112c 5093 0000 		sts endpoints+18+1,r21
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 4194               		.loc 5 176 0
 4195 1130 E0E0      		ldi r30,lo8(endpoints+24)
 4196 1132 F0E0      		ldi r31,hi8(endpoints+24)
 4197               	/* #APP */
 4198               	 ;  176 "usb/usb.h" 1
 4199 1134 04E1      		ldi r16, 20
 4200 1136 0693      		.dc.w 0x9306
 4201               		
 4202               	 ;  0 "" 2
 4203               	/* #NOAPP */
 4204 1138 00C0      		rjmp .L131
 4205               	.LBE1264:
 4206               	.LBE1263:
 4207               	.LBE1260:
 4208               	.LBE1259:
 4209               	.LBE1265:
 4210               	.LBE1266:
 4211               	.LBE1267:
 4212               	.LBE1268:
 4213               	.LBE1294:
 4214               	.LBE1226:
 4215               	.LBE1225:
 4216               		.cfi_endproc
 4217               	.LFE68:
 4219               	.global	toggle_power_gps
 4221               	toggle_power_gps:
 4222               	.LFB69:
 4223               		.file 10 "gps/gps.h"
   1:gps/gps.h     **** void gps_init (USART_t* USART, PORT_t* PORT, char PWRPIN_bm, char TXPIN_bm, char RESETPIN_bm);
   2:gps/gps.h     **** void toggle_power_gps(PORT_t* PORT, char PWRPIN_bm);
   3:gps/gps.h     **** 
   4:gps/gps.h     **** void toggle_power_gps(PORT_t* PORT, char PWRPIN_bm)
   5:gps/gps.h     **** {
 4224               		.loc 10 5 0
 4225               		.cfi_startproc
 4226               	.LVL237:
 4227               	/* prologue: function */
 4228               	/* frame size = 0 */
 4229               	/* stack size = 0 */
 4230               	.L__stack_usage = 0
 4231 113a FC01      		movw r30,r24
 4232               	.LVL238:
 4233               	.LBB1295:
 4234               	.LBB1296:
 4235               		.file 11 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h"
   1:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
 103:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 104:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /**
 105:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 109:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 112:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 120:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 129:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 132:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 140:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** {
 144:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 156:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 159:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 164:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 4236               		.loc 11 164 0
 4237 113c 8FEF      		 ldi r24,lo8(12799999)
 4238 113e 9FE4      	    ldi r25,hi8(12799999)
 4239 1140 A3EC      	    ldi r26,hlo8(12799999)
 4240 1142 8150      	    1:subi r24,1
 4241 1144 9040      	    sbci r25,0
 4242 1146 A040      	    sbci r26,0
 4243 1148 01F4      	    brne 1b
 4244               	.LVL239:
 4245 114a 00C0      		rjmp .
 4246 114c 0000      		nop
 4247               	.LBE1296:
 4248               	.LBE1295:
   6:gps/gps.h     ****   // LOW/HIGH transmission of PD0 to wakeup gps module 
   7:gps/gps.h     ****   _delay_ms(2000);
   8:gps/gps.h     ****   PORT->OUTSET |= PWRPIN_bm;
 4249               		.loc 10 8 0
 4250 114e 8581      		ldd r24,Z+5
 4251 1150 862B      		or r24,r22
 4252 1152 8583      		std Z+5,r24
 4253               	.LVL240:
 4254               	.LBB1297:
 4255               	.LBB1298:
 4256               		.loc 11 164 0
 4257 1154 8FEF      		 ldi r24,lo8(1279999)
 4258 1156 97E8      	    ldi r25,hi8(1279999)
 4259 1158 A3E1      	    ldi r26,hlo8(1279999)
 4260 115a 8150      	    1:subi r24,1
 4261 115c 9040      	    sbci r25,0
 4262 115e A040      	    sbci r26,0
 4263 1160 01F4      	    brne 1b
 4264 1162 00C0      		rjmp .
 4265 1164 0000      		nop
 4266               	.LBE1298:
 4267               	.LBE1297:
   9:gps/gps.h     ****   _delay_ms(200);
  10:gps/gps.h     ****   PORT->OUTTGL = PWRPIN_bm;
 4268               		.loc 10 10 0
 4269 1166 6783      		std Z+7,r22
 4270               	.LVL241:
 4271               	.LBB1299:
 4272               	.LBB1300:
 4273               		.loc 11 164 0
 4274 1168 8AEA      		 ldi r24,lo8(26666666)
 4275 116a 96EE      	    ldi r25,hi8(26666666)
 4276 116c A6E9      	    ldi r26,hlo8(26666666)
 4277 116e B1E0      	    ldi r27,hhi8(26666666)
 4278 1170 8150      	    1:subi r24,1
 4279 1172 9040      	    sbci r25,0
 4280 1174 A040      	    sbci r26,0
 4281 1176 B040      	    sbci r27,0
 4282 1178 01F4      	    brne 1b
 4283 117a 0000      		nop
 4284               	/* epilogue start */
 4285               	.LBE1300:
 4286               	.LBE1299:
  11:gps/gps.h     ****   // give gps time to boot up and start sending nmea string
  12:gps/gps.h     ****   _delay_ms(5000);
  13:gps/gps.h     **** }
 4287               		.loc 10 13 0
 4288 117c 0895      		ret
 4289               		.cfi_endproc
 4290               	.LFE69:
 4292               	.global	gps_init
 4294               	gps_init:
 4295               	.LFB70:
  14:gps/gps.h     **** 
  15:gps/gps.h     **** void gps_init(USART_t* USART, PORT_t* PORT, char PWRPIN_bm, char TXPIN_bm, char RESETPIN_bm) {
 4296               		.loc 10 15 0
 4297               		.cfi_startproc
 4298               	.LVL242:
 4299 117e 0F93      		push r16
 4300               	.LCFI107:
 4301               		.cfi_def_cfa_offset 3
 4302               		.cfi_offset 16, -2
 4303               	/* prologue: function */
 4304               	/* frame size = 0 */
 4305               	/* stack size = 1 */
 4306               	.L__stack_usage = 1
 4307 1180 FC01      		movw r30,r24
 4308 1182 DB01      		movw r26,r22
 4309               	.LVL243:
 4310               	.LBB1301:
 4311               	.LBB1302:
 4312               		.loc 11 164 0
 4313 1184 6FEF      		 ldi r22,lo8(9599999)
 4314 1186 7BE7      	    ldi r23,hi8(9599999)
 4315 1188 82E9      	    ldi r24,hlo8(9599999)
 4316 118a 6150      	    1:subi r22,1
 4317 118c 7040      	    sbci r23,0
 4318 118e 8040      	    sbci r24,0
 4319 1190 01F4      	    brne 1b
 4320               	.LVL244:
 4321 1192 00C0      		rjmp .
 4322 1194 0000      		nop
 4323               	.LBE1302:
 4324               	.LBE1301:
  16:gps/gps.h     ****   /*
  17:gps/gps.h     ****   
  18:gps/gps.h     ****   Port numbers, baud rate, etc will need to be changed when switching 
  19:gps/gps.h     ****   to a different port.  This is a bit complex to abstract out to a new 
  20:gps/gps.h     ****   code layer, but we'll give it our best shot.
  21:gps/gps.h     **** 
  22:gps/gps.h     ****   */
  23:gps/gps.h     **** 
  24:gps/gps.h     ****   // wait 1+ seconds after powering on, as recommended by a2235-h data sheet
  25:gps/gps.h     ****   _delay_ms(1500);
  26:gps/gps.h     **** 
  27:gps/gps.h     ****   //Binary logic notes
  28:gps/gps.h     **** 
  29:gps/gps.h     ****   //Flip a 0 to a 1
  30:gps/gps.h     ****   //00000000
  31:gps/gps.h     ****   //   OR
  32:gps/gps.h     ****   //00100000
  33:gps/gps.h     ****   //   =
  34:gps/gps.h     ****   //00100000
  35:gps/gps.h     **** 
  36:gps/gps.h     ****   //Flip a 1 to a 0
  37:gps/gps.h     ****   //00100000
  38:gps/gps.h     ****   //   ~
  39:gps/gps.h     ****   //11011111
  40:gps/gps.h     ****   //  AND
  41:gps/gps.h     ****   //00100000
  42:gps/gps.h     ****   //   =
  43:gps/gps.h     ****   //00000000
  44:gps/gps.h     **** 
  45:gps/gps.h     ****   //76543210
  46:gps/gps.h     **** 
  47:gps/gps.h     **** 
  48:gps/gps.h     **** 
  49:gps/gps.h     ****   // POWER PIN -- ON_OFF
  50:gps/gps.h     ****   // Set PD0 to low
  51:gps/gps.h     ****   PORT->DIRSET |= PWRPIN_bm;
 4325               		.loc 10 51 0
 4326 1196 1196      		adiw r26,1
 4327 1198 8C91      		ld r24,X
 4328 119a 1197      		sbiw r26,1
 4329               	.LVL245:
 4330 119c 842B      		or r24,r20
 4331 119e 1196      		adiw r26,1
 4332 11a0 8C93      		st X,r24
 4333 11a2 1197      		sbiw r26,1
  52:gps/gps.h     ****   PORT->OUTSET &= (~PWRPIN_bm);  
 4334               		.loc 10 52 0
 4335 11a4 1596      		adiw r26,5
 4336 11a6 9C91      		ld r25,X
 4337 11a8 1597      		sbiw r26,5
 4338 11aa 842F      		mov r24,r20
 4339 11ac 8095      		com r24
 4340 11ae 8923      		and r24,r25
 4341 11b0 1596      		adiw r26,5
 4342 11b2 8C93      		st X,r24
 4343 11b4 1597      		sbiw r26,5
  53:gps/gps.h     **** 
  54:gps/gps.h     ****   // RESET PIN : Active LOW
  55:gps/gps.h     ****   // Set to output and send high
  56:gps/gps.h     ****   PORT->DIRSET |= RESETPIN_bm;
 4344               		.loc 10 56 0
 4345 11b6 1196      		adiw r26,1
 4346 11b8 8C91      		ld r24,X
 4347 11ba 1197      		sbiw r26,1
 4348 11bc 802B      		or r24,r16
 4349 11be 1196      		adiw r26,1
 4350 11c0 8C93      		st X,r24
 4351 11c2 1197      		sbiw r26,1
  57:gps/gps.h     ****   PORT->OUTSET |= RESETPIN_bm;
 4352               		.loc 10 57 0
 4353 11c4 1596      		adiw r26,5
 4354 11c6 8C91      		ld r24,X
 4355 11c8 1597      		sbiw r26,5
 4356 11ca 802B      		or r24,r16
 4357 11cc 1596      		adiw r26,5
 4358 11ce 8C93      		st X,r24
 4359 11d0 1597      		sbiw r26,5
  58:gps/gps.h     **** 
  59:gps/gps.h     ****   // Set the TxD pin as an output - set PORT OUT register bit 3 to 1 
  60:gps/gps.h     ****   PORT->DIRSET |= TXPIN_bm; 
 4360               		.loc 10 60 0
 4361 11d2 1196      		adiw r26,1
 4362 11d4 8C91      		ld r24,X
 4363 11d6 1197      		sbiw r26,1
 4364 11d8 282B      		or r18,r24
 4365               	.LVL246:
 4366 11da 1196      		adiw r26,1
 4367 11dc 2C93      		st X,r18
 4368 11de 1197      		sbiw r26,1
 4369               	.LVL247:
  61:gps/gps.h     **** 
  62:gps/gps.h     ****   //Baud rate of 4800 for nmea string communication
  63:gps/gps.h     ****   int BSEL = 12;
  64:gps/gps.h     ****   int BSCALE = 5;
  65:gps/gps.h     ****   USART->BAUDCTRLA = BSEL & 0xFF;
 4370               		.loc 10 65 0
 4371 11e0 8CE0      		ldi r24,lo8(12)
 4372 11e2 8683      		std Z+6,r24
  66:gps/gps.h     ****   USART->BAUDCTRLB = (BSCALE << 4) | (BSEL & 0xF000) >> 8;
 4373               		.loc 10 66 0
 4374 11e4 80E5      		ldi r24,lo8(80)
 4375 11e6 8783      		std Z+7,r24
  67:gps/gps.h     **** 
  68:gps/gps.h     ****   // no interrupts
  69:gps/gps.h     ****   // can't overwrite bits 7:6
  70:gps/gps.h     ****   USART->CTRLA = 0x00;
 4376               		.loc 10 70 0
 4377 11e8 1382      		std Z+3,__zero_reg__
  71:gps/gps.h     **** 
  72:gps/gps.h     ****   // Enable transmitter and receiver
  73:gps/gps.h     ****   USART->CTRLB = USART_TXEN_bm | USART_RXEN_bm;  
 4378               		.loc 10 73 0
 4379 11ea 88E1      		ldi r24,lo8(24)
 4380 11ec 8483      		std Z+4,r24
  74:gps/gps.h     **** 
  75:gps/gps.h     ****   // async, no parity, 1 stop bit, 8 bit data,
  76:gps/gps.h     ****   // 00     00         0           011    
  77:gps/gps.h     ****   USART->CTRLC = 0x03;  
 4381               		.loc 10 77 0
 4382 11ee 83E0      		ldi r24,lo8(3)
 4383 11f0 8583      		std Z+5,r24
 4384               	.LVL248:
 4385               	.LBB1303:
 4386               	.LBB1304:
 4387               	.LBB1305:
 4388               	.LBB1306:
 4389               		.loc 11 164 0
 4390 11f2 6FEF      		 ldi r22,lo8(12799999)
 4391 11f4 7FE4      	    ldi r23,hi8(12799999)
 4392 11f6 83EC      	    ldi r24,hlo8(12799999)
 4393 11f8 6150      	    1:subi r22,1
 4394 11fa 7040      	    sbci r23,0
 4395 11fc 8040      	    sbci r24,0
 4396 11fe 01F4      	    brne 1b
 4397 1200 00C0      		rjmp .
 4398 1202 0000      		nop
 4399               	.LBE1306:
 4400               	.LBE1305:
   8:gps/gps.h     ****   PORT->OUTSET |= PWRPIN_bm;
 4401               		.loc 10 8 0
 4402 1204 1596      		adiw r26,5
 4403 1206 8C91      		ld r24,X
 4404 1208 1597      		sbiw r26,5
 4405 120a 842B      		or r24,r20
 4406 120c 1596      		adiw r26,5
 4407 120e 8C93      		st X,r24
 4408 1210 1597      		sbiw r26,5
 4409               	.LVL249:
 4410               	.LBB1307:
 4411               	.LBB1308:
 4412               		.loc 11 164 0
 4413 1212 6FEF      		 ldi r22,lo8(1279999)
 4414 1214 77E8      	    ldi r23,hi8(1279999)
 4415 1216 83E1      	    ldi r24,hlo8(1279999)
 4416 1218 6150      	    1:subi r22,1
 4417 121a 7040      	    sbci r23,0
 4418 121c 8040      	    sbci r24,0
 4419 121e 01F4      	    brne 1b
 4420 1220 00C0      		rjmp .
 4421 1222 0000      		nop
 4422               	.LBE1308:
 4423               	.LBE1307:
  10:gps/gps.h     ****   PORT->OUTTGL = PWRPIN_bm;
 4424               		.loc 10 10 0
 4425 1224 1796      		adiw r26,7
 4426 1226 4C93      		st X,r20
 4427 1228 1797      		sbiw r26,7
 4428               	.LVL250:
 4429               	.LBB1309:
 4430               	.LBB1310:
 4431               		.loc 11 164 0
 4432 122a 8AEA      		 ldi r24,lo8(26666666)
 4433 122c 96EE      	    ldi r25,hi8(26666666)
 4434 122e A6E9      	    ldi r26,hlo8(26666666)
 4435 1230 B1E0      	    ldi r27,hhi8(26666666)
 4436 1232 8150      	    1:subi r24,1
 4437 1234 9040      	    sbci r25,0
 4438 1236 A040      	    sbci r26,0
 4439 1238 B040      	    sbci r27,0
 4440 123a 01F4      	    brne 1b
 4441 123c 0000      		nop
 4442               	/* epilogue start */
 4443               	.LBE1310:
 4444               	.LBE1309:
 4445               	.LBE1304:
 4446               	.LBE1303:
  78:gps/gps.h     **** 
  79:gps/gps.h     ****   // LOW/HIGH transmission of PD0 to wakeup gps module 
  80:gps/gps.h     ****   toggle_power_gps(PORT, PWRPIN_bm);
  81:gps/gps.h     **** 
  82:gps/gps.h     ****   // send_string("Wake up gps");
  83:gps/gps.h     **** }
 4447               		.loc 10 83 0
 4448 123e 0F91      		pop r16
 4449               	.LVL251:
 4450 1240 0895      		ret
 4451               		.cfi_endproc
 4452               	.LFE70:
 4454               		.data
 4455               	.LC3:
 4456 0013 2447 5052 		.string	"$GPRMC,"
 4456      4D43 2C00 
 4457               		.text
 4458               	.global	gps_receive
 4460               	gps_receive:
 4461               	.LFB71:
  84:gps/gps.h     **** 
  85:gps/gps.h     **** void gps_receive(USART_t* USART, latlng* gps) {
 4462               		.loc 10 85 0
 4463               		.cfi_startproc
 4464               	.LVL252:
 4465 1242 9F92      		push r9
 4466               	.LCFI108:
 4467               		.cfi_def_cfa_offset 3
 4468               		.cfi_offset 9, -2
 4469 1244 AF92      		push r10
 4470               	.LCFI109:
 4471               		.cfi_def_cfa_offset 4
 4472               		.cfi_offset 10, -3
 4473 1246 BF92      		push r11
 4474               	.LCFI110:
 4475               		.cfi_def_cfa_offset 5
 4476               		.cfi_offset 11, -4
 4477 1248 CF92      		push r12
 4478               	.LCFI111:
 4479               		.cfi_def_cfa_offset 6
 4480               		.cfi_offset 12, -5
 4481 124a DF92      		push r13
 4482               	.LCFI112:
 4483               		.cfi_def_cfa_offset 7
 4484               		.cfi_offset 13, -6
 4485 124c EF92      		push r14
 4486               	.LCFI113:
 4487               		.cfi_def_cfa_offset 8
 4488               		.cfi_offset 14, -7
 4489 124e FF92      		push r15
 4490               	.LCFI114:
 4491               		.cfi_def_cfa_offset 9
 4492               		.cfi_offset 15, -8
 4493 1250 0F93      		push r16
 4494               	.LCFI115:
 4495               		.cfi_def_cfa_offset 10
 4496               		.cfi_offset 16, -9
 4497 1252 1F93      		push r17
 4498               	.LCFI116:
 4499               		.cfi_def_cfa_offset 11
 4500               		.cfi_offset 17, -10
 4501 1254 CF93      		push r28
 4502               	.LCFI117:
 4503               		.cfi_def_cfa_offset 12
 4504               		.cfi_offset 28, -11
 4505 1256 DF93      		push r29
 4506               	.LCFI118:
 4507               		.cfi_def_cfa_offset 13
 4508               		.cfi_offset 29, -12
 4509 1258 CDB7      		in r28,__SP_L__
 4510 125a DEB7      		in r29,__SP_H__
 4511 125c CA5F      		subi r28,lo8(-(-250))
 4512 125e D040      		sbci r29,hi8(-(-250))
 4513               	.LCFI119:
 4514               		.cfi_def_cfa 28, 263
 4515 1260 CDBF      		out __SP_L__,r28
 4516 1262 DEBF      		out __SP_H__,r29
 4517               	/* prologue: function */
 4518               	/* frame size = 250 */
 4519               	/* stack size = 261 */
 4520               	.L__stack_usage = 261
 4521 1264 DC01      		movw r26,r24
 4522 1266 8B01      		movw r16,r22
 4523               	.LVL253:
  86:gps/gps.h     ****   //parsing out gps coordinates
  87:gps/gps.h     **** 
  88:gps/gps.h     ****   //code to look for to indicate start of gps coord string
  89:gps/gps.h     ****   char *code = "$GPRMC,";
  90:gps/gps.h     **** 
  91:gps/gps.h     ****   //length of code
  92:gps/gps.h     ****   int length = 7;
  93:gps/gps.h     **** 
  94:gps/gps.h     ****   //keep track of location in code
  95:gps/gps.h     ****   int index = 0;
  96:gps/gps.h     **** 
  97:gps/gps.h     ****   //indicates whether or not a gps string should be built
  98:gps/gps.h     ****   int read = 0;
  99:gps/gps.h     **** 
 100:gps/gps.h     ****   //buffer to hold gps string -- liberally sized
 101:gps/gps.h     ****   char buff[100];
 102:gps/gps.h     **** 
 103:gps/gps.h     ****   //keep track of position in buffer
 104:gps/gps.h     ****   int buff_index = 0;
 4524               		.loc 10 104 0
 4525 1268 40E0      		ldi r20,lo8(0)
 4526 126a 50E0      		ldi r21,hi8(0)
  98:gps/gps.h     ****   int read = 0;
 4527               		.loc 10 98 0
 4528 126c 20E0      		ldi r18,lo8(0)
 4529 126e 30E0      		ldi r19,hi8(0)
  95:gps/gps.h     ****   int index = 0;
 4530               		.loc 10 95 0
 4531 1270 80E0      		ldi r24,lo8(0)
 4532 1272 90E0      		ldi r25,hi8(0)
 4533               	.LVL254:
 4534               	.L183:
 4535               	.LBB1320:
 4536               	.LBB1321:
  30:uart/uart.h   ****     while ( !( USART->STATUS & USART_RXCIF_bm) ); 
 4537               		.loc 9 30 0
 4538 1274 1196      		adiw r26,1
 4539 1276 6C91      		ld r22,X
 4540 1278 1197      		sbiw r26,1
 4541 127a 67FF      		sbrs r22,7
 4542 127c 00C0      		rjmp .L183
  33:uart/uart.h   ****     return USART->DATA; 
 4543               		.loc 9 33 0
 4544 127e 6C91      		ld r22,X
 4545               	.LBE1321:
 4546               	.LBE1320:
 105:gps/gps.h     **** 
 106:gps/gps.h     ****   //char to store bytes from uart
 107:gps/gps.h     ****   char c; 
 108:gps/gps.h     **** 
 109:gps/gps.h     ****   //only terminates when break is hit
 110:gps/gps.h     ****   while (1) {
 111:gps/gps.h     ****     //pull char from uart
 112:gps/gps.h     ****     c = uart_getchar(USART);
 113:gps/gps.h     ****     if (index == length) {
 4547               		.loc 10 113 0
 4548 1280 8730      		cpi r24,7
 4549 1282 9105      		cpc r25,__zero_reg__
 4550 1284 01F0      		breq .L172
 4551               	.LVL255:
 114:gps/gps.h     ****       //if past `length` characters match code set flip read to on
 115:gps/gps.h     ****       read = 1;
 116:gps/gps.h     ****     }
 117:gps/gps.h     **** 
 118:gps/gps.h     ****     if (read == 1) {
 4552               		.loc 10 118 0
 4553 1286 2130      		cpi r18,1
 4554 1288 3105      		cpc r19,__zero_reg__
 4555 128a 01F0      		breq .L172
 119:gps/gps.h     ****       //build string
 120:gps/gps.h     ****       buff[buff_index] = c;
 121:gps/gps.h     ****       buff_index++;
 122:gps/gps.h     **** 
 123:gps/gps.h     ****       if (c == '\r' || c == '\n' || c == 'W' || c == 'E') {
 124:gps/gps.h     ****         //send full string
 125:gps/gps.h     ****         buff[buff_index] = '\0';
 126:gps/gps.h     ****         // send_string(buff);
 127:gps/gps.h     **** 
 128:gps/gps.h     ****         //additional parsing
 129:gps/gps.h     ****         parse_nmea(buff, gps);
 130:gps/gps.h     ****         break;
 131:gps/gps.h     ****       }
 132:gps/gps.h     ****     } else if (c == code[index]) {
 4556               		.loc 10 132 0
 4557 128c FC01      		movw r30,r24
 4558 128e E050      		subi r30,lo8(-(.LC3))
 4559 1290 F040      		sbci r31,hi8(-(.LC3))
 4560 1292 7081      		ld r23,Z
 4561 1294 7617      		cp r23,r22
 4562 1296 01F0      		breq .L184
 133:gps/gps.h     ****       //char from matches corresponding char in code
 134:gps/gps.h     ****       index++;
 135:gps/gps.h     ****     } else {
 136:gps/gps.h     ****       //incorrect character, reset counter
 137:gps/gps.h     ****       index = 0;
 4563               		.loc 10 137 0
 4564 1298 80E0      		ldi r24,lo8(0)
 4565 129a 90E0      		ldi r25,hi8(0)
 4566 129c 00C0      		rjmp .L183
 4567               	.LVL256:
 4568               	.L172:
 120:gps/gps.h     ****       buff[buff_index] = c;
 4569               		.loc 10 120 0
 4570 129e E7E9      		ldi r30,lo8(151)
 4571 12a0 F0E0      		ldi r31,hi8(151)
 4572 12a2 EC0F      		add r30,r28
 4573 12a4 FD1F      		adc r31,r29
 4574 12a6 E40F      		add r30,r20
 4575 12a8 F51F      		adc r31,r21
 4576 12aa 6083      		st Z,r22
 121:gps/gps.h     ****       buff_index++;
 4577               		.loc 10 121 0
 4578 12ac 4F5F      		subi r20,lo8(-(1))
 4579 12ae 5F4F      		sbci r21,hi8(-(1))
 4580               	.LVL257:
 123:gps/gps.h     ****       if (c == '\r' || c == '\n' || c == 'W' || c == 'E') {
 4581               		.loc 10 123 0
 4582 12b0 6D30      		cpi r22,lo8(13)
 4583 12b2 01F0      		breq .L174
 123:gps/gps.h     ****       if (c == '\r' || c == '\n' || c == 'W' || c == 'E') {
 4584               		.loc 10 123 0 is_stmt 0 discriminator 1
 4585 12b4 6A30      		cpi r22,lo8(10)
 4586 12b6 01F0      		breq .L174
 4587 12b8 6735      		cpi r22,lo8(87)
 4588 12ba 01F0      		breq .L174
 4589 12bc 6534      		cpi r22,lo8(69)
 4590 12be 01F0      		breq .L174
 123:gps/gps.h     ****       if (c == '\r' || c == '\n' || c == 'W' || c == 'E') {
 4591               		.loc 10 123 0
 4592 12c0 21E0      		ldi r18,lo8(1)
 4593 12c2 30E0      		ldi r19,hi8(1)
 4594 12c4 00C0      		rjmp .L183
 4595               	.LVL258:
 4596               	.L184:
 134:gps/gps.h     ****       index++;
 4597               		.loc 10 134 0 is_stmt 1
 4598 12c6 0196      		adiw r24,1
 4599               	.LVL259:
 4600 12c8 00C0      		rjmp .L183
 4601               	.LVL260:
 4602               	.L174:
 125:gps/gps.h     ****         buff[buff_index] = '\0';
 4603               		.loc 10 125 0
 4604 12ca 27E9      		ldi r18,lo8(151)
 4605 12cc 30E0      		ldi r19,hi8(151)
 4606 12ce 2C0F      		add r18,r28
 4607 12d0 3D1F      		adc r19,r29
 4608 12d2 420F      		add r20,r18
 4609 12d4 531F      		adc r21,r19
 4610               	.LVL261:
 4611 12d6 DA01      		movw r26,r20
 4612               	.LVL262:
 4613 12d8 1C92      		st X,__zero_reg__
 4614               	.LVL263:
 4615               	.LBB1322:
 4616               	.LBB1323:
 100:nmea/nmea.h   ****     parse_nmea_string(buff, gps);
 4617               		.loc 8 100 0
 4618 12da C901      		movw r24,r18
 4619 12dc B801      		movw r22,r16
 4620 12de 0E94 0000 		call parse_nmea_string
 103:nmea/nmea.h   ****     if (gps->dist > max_dist) {
 4621               		.loc 8 103 0
 4622 12e2 F801      		movw r30,r16
 4623 12e4 6085      		ldd r22,Z+8
 4624 12e6 7185      		ldd r23,Z+9
 4625 12e8 8285      		ldd r24,Z+10
 4626 12ea 9385      		ldd r25,Z+11
 4627 12ec 2091 0000 		lds r18,max_dist
 4628 12f0 3091 0000 		lds r19,max_dist+1
 4629 12f4 4091 0000 		lds r20,max_dist+2
 4630 12f8 5091 0000 		lds r21,max_dist+3
 4631 12fc 0E94 0000 		call __gtsf2
 4632 1300 1816      		cp __zero_reg__,r24
 4633 1302 04F0      		brlt .+2
 4634 1304 00C0      		rjmp .L169
 4635               	.LBB1324:
 109:nmea/nmea.h   ****       sprintf(lat_buff, "%f", gps->lat);
 4636               		.loc 8 109 0
 4637 1306 2DB7      		in r18,__SP_L__
 4638 1308 3EB7      		in r19,__SP_H__
 4639 130a 2850      		subi r18,lo8(-(-8))
 4640 130c 3040      		sbci r19,hi8(-(-8))
 4641 130e 2DBF      		out __SP_L__,r18
 4642 1310 3EBF      		out __SP_H__,r19
 4643 1312 2F5F      		subi r18,lo8(-(1))
 4644 1314 3F4F      		sbci r19,hi8(-(1))
 4645 1316 65E6      		ldi r22,lo8(101)
 4646 1318 E62E      		mov r14,r22
 4647 131a F12C      		mov r15,__zero_reg__
 4648 131c EC0E      		add r14,r28
 4649 131e FD1E      		adc r15,r29
 4650 1320 ADB7      		in r26,__SP_L__
 4651 1322 BEB7      		in r27,__SP_H__
 4652 1324 1196      		adiw r26,1
 4653 1326 ED92      		st X+,r14
 4654 1328 FC92      		st X,r15
 4655 132a 1297      		sbiw r26,1+1
 4656 132c 70E0      		ldi r23,lo8(.LC2)
 4657 132e C72E      		mov r12,r23
 4658 1330 70E0      		ldi r23,hi8(.LC2)
 4659 1332 D72E      		mov r13,r23
 4660 1334 F901      		movw r30,r18
 4661 1336 C282      		std Z+2,r12
 4662 1338 D382      		std Z+3,r13
 4663 133a F801      		movw r30,r16
 4664 133c 8081      		ld r24,Z
 4665 133e 9181      		ldd r25,Z+1
 4666 1340 A281      		ldd r26,Z+2
 4667 1342 B381      		ldd r27,Z+3
 4668 1344 F901      		movw r30,r18
 4669 1346 8483      		std Z+4,r24
 4670 1348 9583      		std Z+5,r25
 4671 134a A683      		std Z+6,r26
 4672 134c B783      		std Z+7,r27
 4673               		.cfi_escape 0x2e,0x8
 4674 134e 0E94 0000 		call sprintf
 110:nmea/nmea.h   ****       sprintf(lng_buff, "%f", gps->lng);
 4675               		.loc 8 110 0
 4676 1352 2DB7      		in r18,__SP_L__
 4677 1354 3EB7      		in r19,__SP_H__
 4678 1356 2F5F      		subi r18,lo8(-(1))
 4679 1358 3F4F      		sbci r19,hi8(-(1))
 4680 135a 83E3      		ldi r24,lo8(51)
 4681 135c A82E      		mov r10,r24
 4682 135e B12C      		mov r11,__zero_reg__
 4683 1360 AC0E      		add r10,r28
 4684 1362 BD1E      		adc r11,r29
 4685 1364 ADB7      		in r26,__SP_L__
 4686 1366 BEB7      		in r27,__SP_H__
 4687 1368 1196      		adiw r26,1
 4688 136a AD92      		st X+,r10
 4689 136c BC92      		st X,r11
 4690 136e 1297      		sbiw r26,1+1
 4691 1370 F901      		movw r30,r18
 4692 1372 C282      		std Z+2,r12
 4693 1374 D382      		std Z+3,r13
 4694 1376 F801      		movw r30,r16
 4695 1378 8481      		ldd r24,Z+4
 4696 137a 9581      		ldd r25,Z+5
 4697 137c A681      		ldd r26,Z+6
 4698 137e B781      		ldd r27,Z+7
 4699 1380 F901      		movw r30,r18
 4700 1382 8483      		std Z+4,r24
 4701 1384 9583      		std Z+5,r25
 4702 1386 A683      		std Z+6,r26
 4703 1388 B783      		std Z+7,r27
 4704 138a 0E94 0000 		call sprintf
 111:nmea/nmea.h   ****       sprintf(dist_buff, "%f", gps->dist);
 4705               		.loc 8 111 0
 4706 138e 2DB7      		in r18,__SP_L__
 4707 1390 3EB7      		in r19,__SP_H__
 4708 1392 2F5F      		subi r18,lo8(-(1))
 4709 1394 3F4F      		sbci r19,hi8(-(1))
 4710 1396 CE01      		movw r24,r28
 4711 1398 0196      		adiw r24,1
 4712 139a ADB7      		in r26,__SP_L__
 4713 139c BEB7      		in r27,__SP_H__
 4714 139e 1196      		adiw r26,1
 4715 13a0 8D93      		st X+,r24
 4716 13a2 9C93      		st X,r25
 4717 13a4 1297      		sbiw r26,1+1
 4718 13a6 F901      		movw r30,r18
 4719 13a8 C282      		std Z+2,r12
 4720 13aa D382      		std Z+3,r13
 4721 13ac F801      		movw r30,r16
 4722 13ae 8085      		ldd r24,Z+8
 4723 13b0 9185      		ldd r25,Z+9
 4724 13b2 A285      		ldd r26,Z+10
 4725 13b4 B385      		ldd r27,Z+11
 4726 13b6 F901      		movw r30,r18
 4727 13b8 8483      		std Z+4,r24
 4728 13ba 9583      		std Z+5,r25
 4729 13bc A683      		std Z+6,r26
 4730 13be B783      		std Z+7,r27
 4731 13c0 0E94 0000 		call sprintf
 4732               	.LVL264:
 4733               	.LBB1325:
 4734               	.LBB1326:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 4735               		.loc 7 16 0
 4736 13c4 D701      		movw r26,r14
 4737 13c6 0D90      		ld __tmp_reg__,X+
 4738 13c8 0020      		tst __tmp_reg__
 4739 13ca 01F4      		brne .-6
 4740 13cc CD01      		movw r24,r26
 4741 13ce 8E19      		sub r24,r14
 4742 13d0 9F09      		sbc r25,r15
 4743 13d2 EDB7      		in r30,__SP_L__
 4744 13d4 FEB7      		in r31,__SP_H__
 4745 13d6 3896      		adiw r30,8
 4746 13d8 EDBF      		out __SP_L__,r30
 4747 13da FEBF      		out __SP_H__,r31
 4748               	.LVL265:
 4749 13dc 0196      		adiw r24,1
 4750               		.cfi_escape 0x2e,0
 4751 13de 0E94 0000 		call malloc
 4752               	.LVL266:
 4753 13e2 992E      		mov r9,r25
 4754 13e4 C82E      		mov r12,r24
 4755 13e6 D92E      		mov r13,r25
 4756               	.LVL267:
  18:utils/utils.h ****     strcpy(result, s1);
 4757               		.loc 7 18 0
 4758 13e8 C601      		movw r24,r12
 4759 13ea B701      		movw r22,r14
 4760 13ec 0E94 0000 		call strcpy
  19:utils/utils.h ****     strcat(result, s2);
 4761               		.loc 7 19 0
 4762 13f0 EC2D      		mov r30,r12
 4763 13f2 F92D      		mov r31,r9
 4764 13f4 DF01      		movw r26,r30
 4765 13f6 0D90      		ld __tmp_reg__,X+
 4766 13f8 0020      		tst __tmp_reg__
 4767 13fa 01F4      		brne .-6
 4768 13fc 1197      		sbiw r26,1
 4769 13fe AE1B      		sub r26,r30
 4770 1400 BF0B      		sbc r27,r31
 4771 1402 AC0D      		add r26,r12
 4772 1404 BD1D      		adc r27,r13
 4773 1406 8CE2      		ldi r24,lo8(44)
 4774 1408 90E0      		ldi r25,hi8(44)
 4775 140a 8D93      		st X+,r24
 4776 140c 9C93      		st X,r25
 4777               	.LVL268:
 4778               	.LBE1326:
 4779               	.LBE1325:
 4780               	.LBB1327:
 4781               	.LBB1328:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 4782               		.loc 7 16 0
 4783 140e AC2D      		mov r26,r12
 4784 1410 B92D      		mov r27,r9
 4785 1412 FD01      		movw r30,r26
 4786 1414 0190      		ld __tmp_reg__,Z+
 4787 1416 0020      		tst __tmp_reg__
 4788 1418 01F4      		brne .-6
 4789 141a 9F01      		movw r18,r30
 4790 141c F501      		movw r30,r10
 4791 141e 0190      		ld __tmp_reg__,Z+
 4792 1420 0020      		tst __tmp_reg__
 4793 1422 01F4      		brne .-6
 4794 1424 CF01      		movw r24,r30
 4795 1426 0197      		sbiw r24,1
 4796 1428 8A19      		sub r24,r10
 4797 142a 9B09      		sbc r25,r11
 4798 142c 8A1B      		sub r24,r26
 4799 142e 9B0B      		sbc r25,r27
 4800 1430 820F      		add r24,r18
 4801 1432 931F      		adc r25,r19
 4802 1434 0E94 0000 		call malloc
 4803 1438 E82E      		mov r14,r24
 4804 143a 992E      		mov r9,r25
 4805               	.LVL269:
  18:utils/utils.h ****     strcpy(result, s1);
 4806               		.loc 7 18 0
 4807 143c B601      		movw r22,r12
 4808 143e 0E94 0000 		call strcpy
 4809               	.LVL270:
  19:utils/utils.h ****     strcat(result, s2);
 4810               		.loc 7 19 0
 4811 1442 8E2D      		mov r24,r14
 4812 1444 992D      		mov r25,r9
 4813 1446 B501      		movw r22,r10
 4814 1448 0E94 0000 		call strcat
 4815               	.LBE1328:
 4816               	.LBE1327:
 138:nmea/nmea.h   ****       gps->sms = concat(concat(lat_str, ","), lng_str);
 4817               		.loc 8 138 0
 4818 144c D801      		movw r26,r16
 4819 144e 1E96      		adiw r26,14
 4820 1450 EC92      		st X,r14
 4821 1452 1E97      		sbiw r26,14
 4822 1454 1F96      		adiw r26,15
 4823 1456 9C92      		st X,r9
 4824 1458 1F97      		sbiw r26,15
 4825               	.LVL271:
 4826               	.L169:
 4827               	/* epilogue start */
 4828               	.LBE1324:
 4829               	.LBE1323:
 4830               	.LBE1322:
 138:gps/gps.h     ****     }
 139:gps/gps.h     ****   }
 140:gps/gps.h     **** }
 4831               		.loc 10 140 0
 4832 145a C650      		subi r28,lo8(-(250))
 4833 145c DF4F      		sbci r29,hi8(-(250))
 4834 145e CDBF      		out __SP_L__,r28
 4835 1460 DEBF      		out __SP_H__,r29
 4836 1462 DF91      		pop r29
 4837 1464 CF91      		pop r28
 4838 1466 1F91      		pop r17
 4839 1468 0F91      		pop r16
 4840               	.LVL272:
 4841 146a FF90      		pop r15
 4842 146c EF90      		pop r14
 4843 146e DF90      		pop r13
 4844 1470 CF90      		pop r12
 4845 1472 BF90      		pop r11
 4846 1474 AF90      		pop r10
 4847 1476 9F90      		pop r9
 4848 1478 0895      		ret
 4849               		.cfi_endproc
 4850               	.LFE71:
 4852               	.global	wake_up_gprs
 4854               	wake_up_gprs:
 4855               	.LFB72:
 4856               		.file 12 "gprs/gprs.h"
   1:gprs/gprs.h   **** void wake_up_gprs(void);
   2:gprs/gprs.h   **** void gprs_init(USART_t* USART, PORT_t* PORT, char TXPIN_bm);
   3:gprs/gprs.h   **** 
   4:gprs/gprs.h   **** void wake_up_gprs(void) {
 4857               		.loc 12 4 0
 4858               		.cfi_startproc
 4859               	/* prologue: function */
 4860               	/* frame size = 0 */
 4861               	/* stack size = 0 */
 4862               	.L__stack_usage = 0
 4863               	/* epilogue start */
   5:gprs/gprs.h   ****   // 
   6:gprs/gprs.h   **** }
 4864               		.loc 12 6 0
 4865 147a 0895      		ret
 4866               		.cfi_endproc
 4867               	.LFE72:
 4869               	.global	gprs_init
 4871               	gprs_init:
 4872               	.LFB73:
   7:gprs/gprs.h   **** 
   8:gprs/gprs.h   **** void gprs_init(USART_t* USART, PORT_t* PORT, char TXPIN_bm) {
 4873               		.loc 12 8 0
 4874               		.cfi_startproc
 4875               	.LVL273:
 4876               	/* prologue: function */
 4877               	/* frame size = 0 */
 4878               	/* stack size = 0 */
 4879               	.L__stack_usage = 0
 4880 147c FC01      		movw r30,r24
 4881 147e DB01      		movw r26,r22
   9:gprs/gprs.h   ****   //change port numbers when we get our proto board
  10:gprs/gprs.h   **** 
  11:gprs/gprs.h   ****   wake_up_gprs();
  12:gprs/gprs.h   **** 
  13:gprs/gprs.h   ****   // Set the TxD pin as an output - set PORTD OUT register bit 3 to 1 
  14:gprs/gprs.h   ****   PORT->DIRSET = TXPIN_bm; 
 4882               		.loc 12 14 0
 4883 1480 1196      		adiw r26,1
 4884 1482 4C93      		st X,r20
 4885 1484 1197      		sbiw r26,1
  15:gprs/gprs.h   **** 
  16:gprs/gprs.h   ****   // Set the TxD pin high - set PORTD DIR register bit 3 to 1 
  17:gprs/gprs.h   ****   PORT->OUTSET = TXPIN_bm; 
 4886               		.loc 12 17 0
 4887 1486 1596      		adiw r26,5
 4888 1488 4C93      		st X,r20
 4889 148a 1597      		sbiw r26,5
 4890               	.LVL274:
  18:gprs/gprs.h   **** 
  19:gprs/gprs.h   ****   //Baud rate of 19200
  20:gprs/gprs.h   ****   uint16_t BSEL = 12;
  21:gprs/gprs.h   ****   uint8_t BSCALE = 3;
  22:gprs/gprs.h   ****   USART->BAUDCTRLA = BSEL & 0XFF;
 4891               		.loc 12 22 0
 4892 148c 8CE0      		ldi r24,lo8(12)
 4893               	.LVL275:
 4894 148e 8683      		std Z+6,r24
  23:gprs/gprs.h   ****   USART->BAUDCTRLB = (BSCALE << 4) | (BSEL & 0xF000) >> 8;
 4895               		.loc 12 23 0
 4896 1490 80E3      		ldi r24,lo8(48)
 4897 1492 8783      		std Z+7,r24
  24:gprs/gprs.h   **** 
  25:gprs/gprs.h   ****   // no interrupts
  26:gprs/gprs.h   ****   // can't overwrite bits 7:6
  27:gprs/gprs.h   ****   USART->CTRLA = 0x00;
 4898               		.loc 12 27 0
 4899 1494 1382      		std Z+3,__zero_reg__
  28:gprs/gprs.h   **** 
  29:gprs/gprs.h   ****   // Enable transmitter and receiver
  30:gprs/gprs.h   ****   USART->CTRLB = USART_TXEN_bm | USART_RXEN_bm;  
 4900               		.loc 12 30 0
 4901 1496 88E1      		ldi r24,lo8(24)
 4902 1498 8483      		std Z+4,r24
  31:gprs/gprs.h   **** 
  32:gprs/gprs.h   ****   // async, no parity, 1 stop bit, 8 bit data,
  33:gprs/gprs.h   ****   // 00     00         00          11    
  34:gprs/gprs.h   ****   USART->CTRLC = 0x03;  
 4903               		.loc 12 34 0
 4904 149a 83E0      		ldi r24,lo8(3)
 4905 149c 8583      		std Z+5,r24
 4906               	/* epilogue start */
  35:gprs/gprs.h   **** }...
 4907               		.loc 12 35 0
 4908 149e 0895      		ret
 4909               		.cfi_endproc
 4910               	.LFE73:
 4912               		.data
 4913               	.LC4:
 4914 001b 4154 2B43 		.string	"AT+CMGF=1"
 4914      4D47 463D 
 4914      3100 
 4915               	.LC5:
 4916 0025 4154 2B43 		.string	"AT+CMGS=\""
 4916      4D47 533D 
 4916      2200 
 4917               		.text
 4918               	.global	send_message
 4920               	send_message:
 4921               	.LFB74:
 4922               		.file 13 "sms/sms.h"
   1:sms/sms.h     **** #include "Framework.h"
   2:sms/sms.h     **** #include <avr/io.h>
   3:sms/sms.h     **** #include <stdlib.h>
   4:sms/sms.h     **** #include <string.h>
   5:sms/sms.h     **** 
   6:sms/sms.h     **** void send_message(char*, char*, USART_t*);
   7:sms/sms.h     **** char* read_message(USART_t*);
   8:sms/sms.h     **** void delSMS(USART_t*);
   9:sms/sms.h     **** void GprsTextModeSMS(USART_t*);
  10:sms/sms.h     **** void ClearGprsMsg(void);
  11:sms/sms.h     **** void GprsReadSmsStore(char* SmsStorePos, USART_t* USART);
  12:sms/sms.h     **** void ProcessGprsMsg(USART_t*);
  13:sms/sms.h     **** void ProcessSms(char* sms);
  14:sms/sms.h     **** void ReceiveTextMessage(USART_t*);
  15:sms/sms.h     **** void SimpleReceive();
  16:sms/sms.h     **** 
  17:sms/sms.h     **** void send_message(char* number, char* text_message, USART_t* USART) {
 4923               		.loc 13 17 0
 4924               		.cfi_startproc
 4925               	.LVL276:
 4926 14a0 AF92      		push r10
 4927               	.LCFI120:
 4928               		.cfi_def_cfa_offset 3
 4929               		.cfi_offset 10, -2
 4930 14a2 BF92      		push r11
 4931               	.LCFI121:
 4932               		.cfi_def_cfa_offset 4
 4933               		.cfi_offset 11, -3
 4934 14a4 CF92      		push r12
 4935               	.LCFI122:
 4936               		.cfi_def_cfa_offset 5
 4937               		.cfi_offset 12, -4
 4938 14a6 DF92      		push r13
 4939               	.LCFI123:
 4940               		.cfi_def_cfa_offset 6
 4941               		.cfi_offset 13, -5
 4942 14a8 EF92      		push r14
 4943               	.LCFI124:
 4944               		.cfi_def_cfa_offset 7
 4945               		.cfi_offset 14, -6
 4946 14aa FF92      		push r15
 4947               	.LCFI125:
 4948               		.cfi_def_cfa_offset 8
 4949               		.cfi_offset 15, -7
 4950 14ac 0F93      		push r16
 4951               	.LCFI126:
 4952               		.cfi_def_cfa_offset 9
 4953               		.cfi_offset 16, -8
 4954 14ae 1F93      		push r17
 4955               	.LCFI127:
 4956               		.cfi_def_cfa_offset 10
 4957               		.cfi_offset 17, -9
 4958 14b0 CF93      		push r28
 4959               	.LCFI128:
 4960               		.cfi_def_cfa_offset 11
 4961               		.cfi_offset 28, -10
 4962 14b2 DF93      		push r29
 4963               	.LCFI129:
 4964               		.cfi_def_cfa_offset 12
 4965               		.cfi_offset 29, -11
 4966               	/* prologue: function */
 4967               	/* frame size = 0 */
 4968               	/* stack size = 10 */
 4969               	.L__stack_usage = 10
 4970 14b4 F82E      		mov r15,r24
 4971 14b6 E92E      		mov r14,r25
 4972 14b8 6B01      		movw r12,r22
 4973 14ba EA01      		movw r28,r20
 4974               	.LVL277:
 4975               	.L188:
 4976               	.LBB1349:
 4977               	.LBB1350:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 4978               		.loc 9 18 0
 4979 14bc 8981      		ldd r24,Y+1
 4980 14be 85FF      		sbrs r24,5
 4981 14c0 00C0      		rjmp .L188
  21:uart/uart.h   ****     USART->DATA = c; 
 4982               		.loc 9 21 0
 4983 14c2 8DE0      		ldi r24,lo8(13)
 4984 14c4 8883      		st Y,r24
 4985               	.LVL278:
 4986               	.LBE1350:
 4987               	.LBE1349:
 4988               	.LBB1351:
 4989               	.LBB1352:
 4990               		.loc 11 164 0
 4991 14c6 8FEF      		 ldi r24,lo8(639999)
 4992 14c8 93EC      	    ldi r25,hi8(639999)
 4993 14ca A9E0      	    ldi r26,hlo8(639999)
 4994 14cc 8150      	    1:subi r24,1
 4995 14ce 9040      	    sbci r25,0
 4996 14d0 A040      	    sbci r26,0
 4997 14d2 01F4      	    brne 1b
 4998 14d4 00C0      		rjmp .
 4999 14d6 0000      		nop
 5000               	.LVL279:
 5001               	.LBE1352:
 5002               	.LBE1351:
 5003               	.LBB1353:
 5004               	.LBB1354:
  18:sms/sms.h     **** 
  19:sms/sms.h     ****   uart_putchar('\r', USART);
  20:sms/sms.h     ****   _delay_ms(100);
  21:sms/sms.h     **** 
  22:sms/sms.h     ****   GprsTextModeSMS(USART);
  23:sms/sms.h     ****   _delay_ms(100);
  24:sms/sms.h     ****   // send_string("GPS TEXT MODE");
  25:sms/sms.h     **** 
  26:sms/sms.h     ****   //build number string
  27:sms/sms.h     ****   char* number_string = concat(concat("AT+CMGS=\"", number), "\"");
  28:sms/sms.h     ****   send_uart(number_string, USART);
  29:sms/sms.h     ****   _delay_ms(100);
  30:sms/sms.h     ****   // send_string(number_string);
  31:sms/sms.h     **** 
  32:sms/sms.h     ****   send_uart(text_message, USART);
  33:sms/sms.h     ****   _delay_ms(100);
  34:sms/sms.h     ****   // send_string(text_message);
  35:sms/sms.h     **** 
  36:sms/sms.h     ****   uart_putchar(26, USART);
  37:sms/sms.h     ****   _delay_ms(100);
  38:sms/sms.h     ****   // send_string("COMPLETE");
  39:sms/sms.h     **** }
  40:sms/sms.h     **** 
  41:sms/sms.h     **** void GprsTextModeSMS(USART_t* USART) {
  42:sms/sms.h     ****   send_uart("AT+CMGF=1", USART);
 5005               		.loc 13 42 0
 5006 14d8 80E0      		ldi r24,lo8(.LC4)
 5007 14da 90E0      		ldi r25,hi8(.LC4)
 5008 14dc BE01      		movw r22,r28
 5009 14de 0E94 0000 		call send_uart
 5010               	.LVL280:
 5011               	.LBE1354:
 5012               	.LBE1353:
 5013               	.LBB1355:
 5014               	.LBB1356:
 5015               		.loc 11 164 0
 5016 14e2 8FEF      		 ldi r24,lo8(639999)
 5017 14e4 93EC      	    ldi r25,hi8(639999)
 5018 14e6 A9E0      	    ldi r26,hlo8(639999)
 5019 14e8 8150      	    1:subi r24,1
 5020 14ea 9040      	    sbci r25,0
 5021 14ec A040      	    sbci r26,0
 5022 14ee 01F4      	    brne 1b
 5023 14f0 00C0      		rjmp .
 5024 14f2 0000      		nop
 5025               	.LVL281:
 5026               	.LBE1356:
 5027               	.LBE1355:
 5028               	.LBB1357:
 5029               	.LBB1358:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 5030               		.loc 7 16 0
 5031 14f4 EF2D      		mov r30,r15
 5032 14f6 FE2D      		mov r31,r14
 5033 14f8 DF01      		movw r26,r30
 5034 14fa 0D90      		ld __tmp_reg__,X+
 5035 14fc 0020      		tst __tmp_reg__
 5036 14fe 01F4      		brne .-6
 5037 1500 CD01      		movw r24,r26
 5038 1502 8E1B      		sub r24,r30
 5039 1504 9F0B      		sbc r25,r31
 5040 1506 0996      		adiw r24,9
 5041 1508 0E94 0000 		call malloc
 5042 150c 182F      		mov r17,r24
 5043 150e 092F      		mov r16,r25
 5044               	.LVL282:
  18:utils/utils.h ****     strcpy(result, s1);
 5045               		.loc 7 18 0
 5046 1510 E82F      		mov r30,r24
 5047 1512 F92F      		mov r31,r25
 5048 1514 A0E0      		ldi r26,lo8(.LC5)
 5049 1516 B0E0      		ldi r27,hi8(.LC5)
 5050 1518 8AE0      		ldi r24,lo8(10)
 5051               	.LVL283:
 5052               	.L189:
 5053 151a 0D90      		ld r0,X+
 5054 151c 0192      		st Z+,r0
 5055 151e 8150      		subi r24,lo8(-(-1))
 5056 1520 01F4      		brne .L189
  19:utils/utils.h ****     strcat(result, s2);
 5057               		.loc 7 19 0
 5058 1522 812F      		mov r24,r17
 5059 1524 902F      		mov r25,r16
 5060               	.LVL284:
 5061 1526 6F2D      		mov r22,r15
 5062 1528 7E2D      		mov r23,r14
 5063 152a 0E94 0000 		call strcat
 5064               	.LVL285:
 5065               	.LBE1358:
 5066               	.LBE1357:
 5067               	.LBB1359:
 5068               	.LBB1360:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 5069               		.loc 7 16 0
 5070 152e E12F      		mov r30,r17
 5071 1530 F02F      		mov r31,r16
 5072 1532 DF01      		movw r26,r30
 5073 1534 0D90      		ld __tmp_reg__,X+
 5074 1536 0020      		tst __tmp_reg__
 5075 1538 01F4      		brne .-6
 5076 153a CD01      		movw r24,r26
 5077 153c 8E1B      		sub r24,r30
 5078 153e 9F0B      		sbc r25,r31
 5079 1540 0196      		adiw r24,1
 5080 1542 0E94 0000 		call malloc
 5081 1546 F92E      		mov r15,r25
 5082               	.LVL286:
 5083 1548 A82E      		mov r10,r24
 5084 154a B92E      		mov r11,r25
 5085               	.LVL287:
  18:utils/utils.h ****     strcpy(result, s1);
 5086               		.loc 7 18 0
 5087 154c C501      		movw r24,r10
 5088 154e 612F      		mov r22,r17
 5089 1550 702F      		mov r23,r16
 5090 1552 0E94 0000 		call strcpy
  19:utils/utils.h ****     strcat(result, s2);
 5091               		.loc 7 19 0
 5092 1556 AA2D      		mov r26,r10
 5093 1558 BF2D      		mov r27,r15
 5094 155a FD01      		movw r30,r26
 5095 155c 0190      		ld __tmp_reg__,Z+
 5096 155e 0020      		tst __tmp_reg__
 5097 1560 01F4      		brne .-6
 5098 1562 3197      		sbiw r30,1
 5099 1564 EA1B      		sub r30,r26
 5100 1566 FB0B      		sbc r31,r27
 5101 1568 EA0D      		add r30,r10
 5102 156a FB1D      		adc r31,r11
 5103 156c 82E2      		ldi r24,lo8(34)
 5104 156e 90E0      		ldi r25,hi8(34)
 5105 1570 8083      		st Z,r24
 5106 1572 9183      		std Z+1,r25
 5107               	.LBE1360:
 5108               	.LBE1359:
  28:sms/sms.h     ****   send_uart(number_string, USART);
 5109               		.loc 13 28 0
 5110 1574 C501      		movw r24,r10
 5111 1576 BE01      		movw r22,r28
 5112 1578 0E94 0000 		call send_uart
 5113               	.LVL288:
 5114               	.LBB1361:
 5115               	.LBB1362:
 5116               		.loc 11 164 0
 5117 157c 8FEF      		 ldi r24,lo8(639999)
 5118 157e 93EC      	    ldi r25,hi8(639999)
 5119 1580 A9E0      	    ldi r26,hlo8(639999)
 5120 1582 8150      	    1:subi r24,1
 5121 1584 9040      	    sbci r25,0
 5122 1586 A040      	    sbci r26,0
 5123 1588 01F4      	    brne 1b
 5124 158a 00C0      		rjmp .
 5125 158c 0000      		nop
 5126               	.LBE1362:
 5127               	.LBE1361:
  32:sms/sms.h     ****   send_uart(text_message, USART);
 5128               		.loc 13 32 0
 5129 158e C601      		movw r24,r12
 5130 1590 BE01      		movw r22,r28
 5131 1592 0E94 0000 		call send_uart
 5132               	.LVL289:
 5133               	.LBB1363:
 5134               	.LBB1364:
 5135               		.loc 11 164 0
 5136 1596 8FEF      		 ldi r24,lo8(639999)
 5137 1598 93EC      	    ldi r25,hi8(639999)
 5138 159a A9E0      	    ldi r26,hlo8(639999)
 5139 159c 8150      	    1:subi r24,1
 5140 159e 9040      	    sbci r25,0
 5141 15a0 A040      	    sbci r26,0
 5142 15a2 01F4      	    brne 1b
 5143 15a4 00C0      		rjmp .
 5144 15a6 0000      		nop
 5145               	.LVL290:
 5146               	.L190:
 5147               	.LBE1364:
 5148               	.LBE1363:
 5149               	.LBB1365:
 5150               	.LBB1366:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 5151               		.loc 9 18 0
 5152 15a8 8981      		ldd r24,Y+1
 5153 15aa 85FF      		sbrs r24,5
 5154 15ac 00C0      		rjmp .L190
  21:uart/uart.h   ****     USART->DATA = c; 
 5155               		.loc 9 21 0
 5156 15ae 8AE1      		ldi r24,lo8(26)
 5157 15b0 8883      		st Y,r24
 5158               	.LVL291:
 5159               	.LBE1366:
 5160               	.LBE1365:
 5161               	.LBB1367:
 5162               	.LBB1368:
 5163               		.loc 11 164 0
 5164 15b2 8FEF      		 ldi r24,lo8(639999)
 5165 15b4 93EC      	    ldi r25,hi8(639999)
 5166 15b6 A9E0      	    ldi r26,hlo8(639999)
 5167 15b8 8150      	    1:subi r24,1
 5168 15ba 9040      	    sbci r25,0
 5169 15bc A040      	    sbci r26,0
 5170 15be 01F4      	    brne 1b
 5171 15c0 00C0      		rjmp .
 5172 15c2 0000      		nop
 5173               	/* epilogue start */
 5174               	.LBE1368:
 5175               	.LBE1367:
  39:sms/sms.h     **** }
 5176               		.loc 13 39 0
 5177 15c4 DF91      		pop r29
 5178 15c6 CF91      		pop r28
 5179               	.LVL292:
 5180 15c8 1F91      		pop r17
 5181               	.LVL293:
 5182 15ca 0F91      		pop r16
 5183 15cc FF90      		pop r15
 5184 15ce EF90      		pop r14
 5185 15d0 DF90      		pop r13
 5186 15d2 CF90      		pop r12
 5187               	.LVL294:
 5188 15d4 BF90      		pop r11
 5189 15d6 AF90      		pop r10
 5190               	.LVL295:
 5191 15d8 0895      		ret
 5192               		.cfi_endproc
 5193               	.LFE74:
 5195               	.global	GprsTextModeSMS
 5197               	GprsTextModeSMS:
 5198               	.LFB75:
  41:sms/sms.h     **** void GprsTextModeSMS(USART_t* USART) {
 5199               		.loc 13 41 0
 5200               		.cfi_startproc
 5201               	.LVL296:
 5202               	/* prologue: function */
 5203               	/* frame size = 0 */
 5204               	/* stack size = 0 */
 5205               	.L__stack_usage = 0
 5206 15da BC01      		movw r22,r24
 5207               		.loc 13 42 0
 5208 15dc 80E0      		ldi r24,lo8(.LC4)
 5209 15de 90E0      		ldi r25,hi8(.LC4)
 5210               	.LVL297:
 5211 15e0 0E94 0000 		call send_uart
 5212               	.LVL298:
 5213               	/* epilogue start */
  43:sms/sms.h     **** }
 5214               		.loc 13 43 0
 5215 15e4 0895      		ret
 5216               		.cfi_endproc
 5217               	.LFE75:
 5219               		.data
 5220               	.LC6:
 5221 002f 4154 2B43 		.string	"AT+CPOWD=1"
 5221      504F 5744 
 5221      3D31 00
 5222               		.text
 5223               	.global	PowerDownModem
 5225               	PowerDownModem:
 5226               	.LFB76:
  44:sms/sms.h     **** 
  45:sms/sms.h     **** void PowerDownModem(USART_t* USART) {
 5227               		.loc 13 45 0
 5228               		.cfi_startproc
 5229               	.LVL299:
 5230               	/* prologue: function */
 5231               	/* frame size = 0 */
 5232               	/* stack size = 0 */
 5233               	.L__stack_usage = 0
 5234 15e6 BC01      		movw r22,r24
  46:sms/sms.h     ****   send_uart("AT+CPOWD=1", USART);
 5235               		.loc 13 46 0
 5236 15e8 80E0      		ldi r24,lo8(.LC6)
 5237 15ea 90E0      		ldi r25,hi8(.LC6)
 5238               	.LVL300:
 5239 15ec 0E94 0000 		call send_uart
 5240               	.LVL301:
 5241               	/* epilogue start */
  47:sms/sms.h     **** }
 5242               		.loc 13 47 0
 5243 15f0 0895      		ret
 5244               		.cfi_endproc
 5245               	.LFE76:
 5247               		.data
 5248               	.LC7:
 5249 003a 4154 2B43 		.string	"AT+CFUN=0"
 5249      4655 4E3D 
 5249      3000 
 5250               		.text
 5251               	.global	SleepModem
 5253               	SleepModem:
 5254               	.LFB77:
  48:sms/sms.h     **** 
  49:sms/sms.h     **** void SleepModem(USART_t* USART) {
 5255               		.loc 13 49 0
 5256               		.cfi_startproc
 5257               	.LVL302:
 5258               	/* prologue: function */
 5259               	/* frame size = 0 */
 5260               	/* stack size = 0 */
 5261               	.L__stack_usage = 0
 5262 15f2 BC01      		movw r22,r24
  50:sms/sms.h     ****   send_uart("AT+CFUN=0", USART);
 5263               		.loc 13 50 0
 5264 15f4 80E0      		ldi r24,lo8(.LC7)
 5265 15f6 90E0      		ldi r25,hi8(.LC7)
 5266               	.LVL303:
 5267 15f8 0E94 0000 		call send_uart
 5268               	.LVL304:
 5269               	/* epilogue start */
  51:sms/sms.h     **** }
 5270               		.loc 13 51 0
 5271 15fc 0895      		ret
 5272               		.cfi_endproc
 5273               	.LFE77:
 5275               		.data
 5276               	.LC8:
 5277 0044 4154 2B43 		.string	"AT+CFUN=1"
 5277      4655 4E3D 
 5277      3100 
 5278               		.text
 5279               	.global	WakeUpModem
 5281               	WakeUpModem:
 5282               	.LFB78:
  52:sms/sms.h     **** 
  53:sms/sms.h     **** void WakeUpModem(USART_t* USART) {
 5283               		.loc 13 53 0
 5284               		.cfi_startproc
 5285               	.LVL305:
 5286               	/* prologue: function */
 5287               	/* frame size = 0 */
 5288               	/* stack size = 0 */
 5289               	.L__stack_usage = 0
 5290 15fe BC01      		movw r22,r24
  54:sms/sms.h     ****   send_uart("AT+CFUN=1", USART);
 5291               		.loc 13 54 0
 5292 1600 80E0      		ldi r24,lo8(.LC8)
 5293 1602 90E0      		ldi r25,hi8(.LC8)
 5294               	.LVL306:
 5295 1604 0E94 0000 		call send_uart
 5296               	.LVL307:
 5297               	/* epilogue start */
  55:sms/sms.h     **** }
 5298               		.loc 13 55 0
 5299 1608 0895      		ret
 5300               		.cfi_endproc
 5301               	.LFE78:
 5303               		.data
 5304               	.LC9:
 5305 004e 5379 6E63 		.string	"Sync"
 5305      00
 5306               	.LC10:
 5307 0053 4154 00   		.string	"AT"
 5308               	.LC11:
 5309 0056 5049 4E47 		.string	"PING"
 5309      00
 5310               	.LC12:
 5311 005b 5465 7874 		.string	"Text Mode"
 5311      204D 6F64 
 5311      6500 
 5312               	.LC13:
 5313 0065 4154 2B43 		.string	"AT+CMGF=?"
 5313      4D47 463D 
 5313      3F00 
 5314               	.LC14:
 5315 006f 4368 6563 		.string	"Check Mode"
 5315      6B20 4D6F 
 5315      6465 00
 5316               		.text
 5317               	.global	SimpleReceive
 5319               	SimpleReceive:
 5320               	.LFB79:
  56:sms/sms.h     **** 
  57:sms/sms.h     **** void SimpleReceive(USART_t* USART) {
 5321               		.loc 13 57 0
 5322               		.cfi_startproc
 5323               	.LVL308:
 5324 160a CF92      		push r12
 5325               	.LCFI130:
 5326               		.cfi_def_cfa_offset 3
 5327               		.cfi_offset 12, -2
 5328 160c DF92      		push r13
 5329               	.LCFI131:
 5330               		.cfi_def_cfa_offset 4
 5331               		.cfi_offset 13, -3
 5332 160e EF92      		push r14
 5333               	.LCFI132:
 5334               		.cfi_def_cfa_offset 5
 5335               		.cfi_offset 14, -4
 5336 1610 FF92      		push r15
 5337               	.LCFI133:
 5338               		.cfi_def_cfa_offset 6
 5339               		.cfi_offset 15, -5
 5340 1612 0F93      		push r16
 5341               	.LCFI134:
 5342               		.cfi_def_cfa_offset 7
 5343               		.cfi_offset 16, -6
 5344 1614 1F93      		push r17
 5345               	.LCFI135:
 5346               		.cfi_def_cfa_offset 8
 5347               		.cfi_offset 17, -7
 5348 1616 CF93      		push r28
 5349               	.LCFI136:
 5350               		.cfi_def_cfa_offset 9
 5351               		.cfi_offset 28, -8
 5352 1618 DF93      		push r29
 5353               	.LCFI137:
 5354               		.cfi_def_cfa_offset 10
 5355               		.cfi_offset 29, -9
 5356 161a CDB7      		in r28,__SP_L__
 5357 161c DEB7      		in r29,__SP_H__
 5358               	.LCFI138:
 5359               		.cfi_def_cfa_register 28
 5360               	/* prologue: function */
 5361               	/* frame size = 0 */
 5362               	/* stack size = 8 */
 5363               	.L__stack_usage = 8
 5364 161e 8C01      		movw r16,r24
  58:sms/sms.h     ****   //not currently functional, perhaps
  59:sms/sms.h     ****   //because of baud rate issues
  60:sms/sms.h     ****   
  61:sms/sms.h     ****   char c;
  62:sms/sms.h     ****   int n = 1;
  63:sms/sms.h     ****   char s[n+1];
  64:sms/sms.h     **** 
  65:sms/sms.h     ****   uart_putchar('A', USART);
  66:sms/sms.h     ****   send_string("Sync");
  67:sms/sms.h     ****   _delay_ms(3000);
  68:sms/sms.h     **** 
  69:sms/sms.h     ****   send_uart("AT", USART);
  70:sms/sms.h     ****   send_string("PING");
  71:sms/sms.h     ****   _delay_ms(100);
  72:sms/sms.h     ****   for (uint8_t i=0; i<n; i++) {
  73:sms/sms.h     ****     c = uart_getchar(USART);
  74:sms/sms.h     ****     s[i] = c;
  75:sms/sms.h     ****   }
  76:sms/sms.h     ****   s[n] = '\0';
  77:sms/sms.h     **** 
  78:sms/sms.h     ****   send_string(s);
  79:sms/sms.h     **** 
  80:sms/sms.h     **** 
  81:sms/sms.h     **** 
  82:sms/sms.h     ****   GprsTextModeSMS(USART);
  83:sms/sms.h     ****   send_string("Text Mode");
  84:sms/sms.h     ****   _delay_ms(800);
  85:sms/sms.h     **** 
  86:sms/sms.h     ****   // send_uart("AT+CMGL=\"REC UNREAD\"", USART); // Read Message 
  87:sms/sms.h     ****   // send_string("Read Messages");
  88:sms/sms.h     ****   // _delay_ms(1000);
  89:sms/sms.h     **** 
  90:sms/sms.h     ****   send_uart("AT+CMGF=?", USART); // Read Message 
  91:sms/sms.h     ****   send_string("Check Mode");
  92:sms/sms.h     ****   _delay_ms(1000);
  93:sms/sms.h     **** }...
 5365               		.loc 13 93 0
 5366 1620 CDB6      		in r12,__SP_L__
 5367 1622 DEB6      		in r13,__SP_H__
 5368               	.LVL309:
  63:sms/sms.h     ****   char s[n+1];
 5369               		.loc 13 63 0
 5370 1624 00D0      		rcall .
 5371 1626 EDB6      		in r14,__SP_L__
 5372 1628 FEB6      		in r15,__SP_H__
 5373 162a 0894      		sec
 5374 162c E11C      		adc r14,__zero_reg__
 5375 162e F11C      		adc r15,__zero_reg__
 5376               	.LVL310:
 5377               	.L199:
 5378               	.LBB1384:
 5379               	.LBB1385:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 5380               		.loc 9 18 0
 5381 1630 D801      		movw r26,r16
 5382 1632 1196      		adiw r26,1
 5383 1634 8C91      		ld r24,X
 5384 1636 1197      		sbiw r26,1
 5385 1638 85FF      		sbrs r24,5
 5386 163a 00C0      		rjmp .L199
  21:uart/uart.h   ****     USART->DATA = c; 
 5387               		.loc 9 21 0
 5388 163c 81E4      		ldi r24,lo8(65)
 5389 163e 8C93      		st X,r24
 5390               	.LBE1385:
 5391               	.LBE1384:
  66:sms/sms.h     ****   send_string("Sync");
 5392               		.loc 13 66 0
 5393 1640 80E0      		ldi r24,lo8(.LC9)
 5394 1642 90E0      		ldi r25,hi8(.LC9)
 5395 1644 0E94 0000 		call send_string
 5396               	.LVL311:
 5397               	.LBB1386:
 5398               	.LBB1387:
 5399               		.loc 11 164 0
 5400 1648 8FEF      		 ldi r24,lo8(15999999)
 5401 164a 93E2      	    ldi r25,hi8(15999999)
 5402 164c A4EF      	    ldi r26,hlo8(15999999)
 5403 164e B0E0      	    ldi r27,hhi8(15999999)
 5404 1650 8150      	    1:subi r24,1
 5405 1652 9040      	    sbci r25,0
 5406 1654 A040      	    sbci r26,0
 5407 1656 B040      	    sbci r27,0
 5408 1658 01F4      	    brne 1b
 5409 165a 00C0      		rjmp .
 5410 165c 0000      		nop
 5411               	.LBE1387:
 5412               	.LBE1386:
  69:sms/sms.h     ****   send_uart("AT", USART);
 5413               		.loc 13 69 0
 5414 165e 80E0      		ldi r24,lo8(.LC10)
 5415 1660 90E0      		ldi r25,hi8(.LC10)
 5416 1662 B801      		movw r22,r16
 5417 1664 0E94 0000 		call send_uart
  70:sms/sms.h     ****   send_string("PING");
 5418               		.loc 13 70 0
 5419 1668 80E0      		ldi r24,lo8(.LC11)
 5420 166a 90E0      		ldi r25,hi8(.LC11)
 5421 166c 0E94 0000 		call send_string
 5422               	.LVL312:
 5423               	.LBB1388:
 5424               	.LBB1389:
 5425               		.loc 11 164 0
 5426 1670 8FEF      		 ldi r24,lo8(639999)
 5427 1672 93EC      	    ldi r25,hi8(639999)
 5428 1674 A9E0      	    ldi r26,hlo8(639999)
 5429 1676 8150      	    1:subi r24,1
 5430 1678 9040      	    sbci r25,0
 5431 167a A040      	    sbci r26,0
 5432 167c 01F4      	    brne 1b
 5433 167e 00C0      		rjmp .
 5434 1680 0000      		nop
 5435               	.LVL313:
 5436               	.L200:
 5437               	.LBE1389:
 5438               	.LBE1388:
 5439               	.LBB1390:
 5440               	.LBB1391:
 5441               	.LBB1392:
  30:uart/uart.h   ****     while ( !( USART->STATUS & USART_RXCIF_bm) ); 
 5442               		.loc 9 30 0
 5443 1682 D801      		movw r26,r16
 5444 1684 1196      		adiw r26,1
 5445 1686 8C91      		ld r24,X
 5446 1688 1197      		sbiw r26,1
 5447 168a 87FF      		sbrs r24,7
 5448 168c 00C0      		rjmp .L200
  33:uart/uart.h   ****     return USART->DATA; 
 5449               		.loc 9 33 0
 5450 168e 8C91      		ld r24,X
 5451               	.LBE1392:
 5452               	.LBE1391:
  74:sms/sms.h     ****     s[i] = c;
 5453               		.loc 13 74 0
 5454 1690 F701      		movw r30,r14
 5455 1692 8083      		st Z,r24
 5456               	.LVL314:
 5457               	.LBE1390:
  76:sms/sms.h     ****   s[n] = '\0';
 5458               		.loc 13 76 0
 5459 1694 1182      		std Z+1,__zero_reg__
  78:sms/sms.h     ****   send_string(s);
 5460               		.loc 13 78 0
 5461 1696 C701      		movw r24,r14
 5462 1698 0E94 0000 		call send_string
 5463               	.LVL315:
 5464               	.LBB1393:
 5465               	.LBB1394:
  42:sms/sms.h     ****   send_uart("AT+CMGF=1", USART);
 5466               		.loc 13 42 0
 5467 169c 80E0      		ldi r24,lo8(.LC4)
 5468 169e 90E0      		ldi r25,hi8(.LC4)
 5469 16a0 B801      		movw r22,r16
 5470 16a2 0E94 0000 		call send_uart
 5471               	.LBE1394:
 5472               	.LBE1393:
  83:sms/sms.h     ****   send_string("Text Mode");
 5473               		.loc 13 83 0
 5474 16a6 80E0      		ldi r24,lo8(.LC12)
 5475 16a8 90E0      		ldi r25,hi8(.LC12)
 5476 16aa 0E94 0000 		call send_string
 5477               	.LVL316:
 5478               	.LBB1395:
 5479               	.LBB1396:
 5480               		.loc 11 164 0
 5481 16ae 8FEF      		 ldi r24,lo8(5119999)
 5482 16b0 9FE1      	    ldi r25,hi8(5119999)
 5483 16b2 AEE4      	    ldi r26,hlo8(5119999)
 5484 16b4 8150      	    1:subi r24,1
 5485 16b6 9040      	    sbci r25,0
 5486 16b8 A040      	    sbci r26,0
 5487 16ba 01F4      	    brne 1b
 5488 16bc 00C0      		rjmp .
 5489 16be 0000      		nop
 5490               	.LBE1396:
 5491               	.LBE1395:
  90:sms/sms.h     ****   send_uart("AT+CMGF=?", USART); // Read Message 
 5492               		.loc 13 90 0
 5493 16c0 80E0      		ldi r24,lo8(.LC13)
 5494 16c2 90E0      		ldi r25,hi8(.LC13)
 5495 16c4 B801      		movw r22,r16
 5496 16c6 0E94 0000 		call send_uart
  91:sms/sms.h     ****   send_string("Check Mode");
 5497               		.loc 13 91 0
 5498 16ca 80E0      		ldi r24,lo8(.LC14)
 5499 16cc 90E0      		ldi r25,hi8(.LC14)
 5500 16ce 0E94 0000 		call send_string
 5501               	.LVL317:
 5502               	.LBB1397:
 5503               	.LBB1398:
 5504               		.loc 11 164 0
 5505 16d2 8FEF      		 ldi r24,lo8(6399999)
 5506 16d4 97EA      	    ldi r25,hi8(6399999)
 5507 16d6 A1E6      	    ldi r26,hlo8(6399999)
 5508 16d8 8150      	    1:subi r24,1
 5509 16da 9040      	    sbci r25,0
 5510 16dc A040      	    sbci r26,0
 5511 16de 01F4      	    brne 1b
 5512 16e0 00C0      		rjmp .
 5513 16e2 0000      		nop
 5514               	.LBE1398:
 5515               	.LBE1397:
 5516               		.loc 13 93 0
 5517 16e4 CDBE      		out __SP_L__,r12
 5518 16e6 DEBE      		out __SP_H__,r13
 5519               	/* epilogue start */
 5520 16e8 DF91      		pop r29
 5521 16ea CF91      		pop r28
 5522 16ec 1F91      		pop r17
 5523 16ee 0F91      		pop r16
 5524               	.LVL318:
 5525 16f0 FF90      		pop r15
 5526 16f2 EF90      		pop r14
 5527               	.LVL319:
 5528 16f4 DF90      		pop r13
 5529 16f6 CF90      		pop r12
 5530               	.LVL320:
 5531 16f8 0895      		ret
 5532               		.cfi_endproc
 5533               	.LFE79:
 5535               		.section	.text.startup,"ax",@progbits
 5536               	.global	main
 5538               	main:
 5539               	.LFB80:
  29:main.c        **** int main(void){
 5540               		.loc 6 29 0
 5541               		.cfi_startproc
 5542 0000 CF93      		push r28
 5543               	.LCFI139:
 5544               		.cfi_def_cfa_offset 3
 5545               		.cfi_offset 28, -2
 5546 0002 DF93      		push r29
 5547               	.LCFI140:
 5548               		.cfi_def_cfa_offset 4
 5549               		.cfi_offset 29, -3
 5550 0004 CDB7      		in r28,__SP_L__
 5551 0006 DEB7      		in r29,__SP_H__
 5552 0008 CA5F      		subi r28,lo8(-(-250))
 5553 000a D040      		sbci r29,hi8(-(-250))
 5554               	.LCFI141:
 5555               		.cfi_def_cfa 28, 254
 5556 000c CDBF      		out __SP_L__,r28
 5557 000e DEBF      		out __SP_H__,r29
 5558               	/* prologue: function */
 5559               	/* frame size = 250 */
 5560               	/* stack size = 252 */
 5561               	.L__stack_usage = 252
  32:main.c        **** 	USB_ConfigureClock();
 5562               		.loc 6 32 0
 5563 0010 0E94 0000 		call USB_ConfigureClock
  33:main.c        **** 	USB_Init();
 5564               		.loc 6 33 0
 5565 0014 0E94 0000 		call USB_Init
  34:main.c        **** 	USB.INTCTRLA = USB_BUSEVIE_bm | USB_INTLVL_MED_gc;
 5566               		.loc 6 34 0
 5567 0018 E0EC      		ldi r30,lo8(1216)
 5568 001a F4E0      		ldi r31,hi8(1216)
 5569 001c 82E4      		ldi r24,lo8(66)
 5570 001e 8087      		std Z+8,r24
  35:main.c        **** 	USB.INTCTRLB = USB_TRNIE_bm | USB_SETUPIE_bm;
 5571               		.loc 6 35 0
 5572 0020 83E0      		ldi r24,lo8(3)
 5573 0022 8187      		std Z+9,r24
  36:main.c        **** 	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
 5574               		.loc 6 36 0
 5575 0024 E0EA      		ldi r30,lo8(160)
 5576 0026 F0E0      		ldi r31,hi8(160)
 5577 0028 8283      		std Z+2,r24
  37:main.c        **** 	sei();
 5578               		.loc 6 37 0
 5579               	/* #APP */
 5580               	 ;  37 "main.c" 1
 5581 002a 7894      		sei
 5582               	 ;  0 "" 2
 5583               	.LVL321:
 5584               	/* #NOAPP */
 5585               	.LBB1551:
 5586               	.LBB1552:
  14:gprs/gprs.h   ****   PORT->DIRSET = TXPIN_bm; 
 5587               		.loc 12 14 0
 5588 002c E0E4      		ldi r30,lo8(1600)
 5589 002e F6E0      		ldi r31,hi8(1600)
 5590 0030 98E0      		ldi r25,lo8(8)
 5591 0032 9183      		std Z+1,r25
  17:gprs/gprs.h   ****   PORT->OUTSET = TXPIN_bm; 
 5592               		.loc 12 17 0
 5593 0034 9583      		std Z+5,r25
 5594               	.LVL322:
  22:gprs/gprs.h   ****   USART->BAUDCTRLA = BSEL & 0XFF;
 5595               		.loc 12 22 0
 5596 0036 E0EA      		ldi r30,lo8(2208)
 5597 0038 F8E0      		ldi r31,hi8(2208)
 5598 003a 9CE0      		ldi r25,lo8(12)
 5599 003c 9683      		std Z+6,r25
  23:gprs/gprs.h   ****   USART->BAUDCTRLB = (BSCALE << 4) | (BSEL & 0xF000) >> 8;
 5600               		.loc 12 23 0
 5601 003e 90E3      		ldi r25,lo8(48)
 5602 0040 9783      		std Z+7,r25
  27:gprs/gprs.h   ****   USART->CTRLA = 0x00;
 5603               		.loc 12 27 0
 5604 0042 1382      		std Z+3,__zero_reg__
  30:gprs/gprs.h   ****   USART->CTRLB = USART_TXEN_bm | USART_RXEN_bm;  
 5605               		.loc 12 30 0
 5606 0044 98E1      		ldi r25,lo8(24)
 5607 0046 9483      		std Z+4,r25
  34:gprs/gprs.h   ****   USART->CTRLC = 0x03;  
 5608               		.loc 12 34 0
 5609 0048 8583      		std Z+5,r24
 5610               	.LBE1552:
 5611               	.LBE1551:
  47:main.c        **** 		gps_init(&USARTD0, &PORTD, PIN0_bm, PIN3_bm, PIN4_bm);
 5612               		.loc 6 47 0
 5613 004a 80EA      		ldi r24,lo8(2464)
 5614 004c 99E0      		ldi r25,hi8(2464)
 5615 004e 60E6      		ldi r22,lo8(1632)
 5616 0050 76E0      		ldi r23,hi8(1632)
 5617 0052 41E0      		ldi r20,lo8(1)
 5618 0054 28E0      		ldi r18,lo8(8)
 5619 0056 00E1      		ldi r16,lo8(16)
 5620 0058 0E94 0000 		call gps_init
 5621               	.LVL323:
 5622               	.LBB1553:
 5623               	.LBB1554:
 5624               	.LBB1555:
 5625               	.LBB1556:
 110:usb/usb_pipe.h **** 	p->data->flush = 1;
 5626               		.loc 2 110 0
 5627 005c 81E0      		ldi r24,lo8(1)
 5628 005e 8093 0000 		sts ep_in_data+1,r24
 5629               	.LVL324:
 5630               	.LBB1557:
 5631               	.LBB1558:
 5632               	.LBB1559:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 5633               		.loc 2 80 0
 5634 0062 EFB6      		in r14,__SREG__
 5635               	.LVL325:
 5636               	.LBB1560:
 5637               	.LBB1561:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 5638               		.loc 3 50 0
 5639               	/* #APP */
 5640               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 5641 0064 F894      		cli
 5642               	 ;  0 "" 2
 5643               	/* #NOAPP */
 5644 0066 B091 0000 		lds r27,ep_in_pipe_data+4
 5645 006a 8091 0000 		lds r24,ep_in_pipe_data
 5646 006e 9091 0000 		lds r25,ep_in_pipe_data+1
 5647 0072 0091 0000 		lds r16,ep_in_data
 5648 0076 A091 0000 		lds r26,ep_in_data+1
 5649 007a 4091 0000 		lds r20,ep_in_data+2
 5650 007e 5091 0000 		lds r21,ep_in_data+2+1
 5651 0082 6091 0000 		lds r22,ep_in_pipe_data+2
 5652 0086 7091 0000 		lds r23,ep_in_pipe_data+2+1
 5653               	.LVL326:
 5654               	.LBE1561:
 5655               	.LBE1560:
 5656               	.LBB1562:
 5657               	.LBB1563:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 5658               		.loc 5 220 0
 5659 008a 2091 0000 		lds r18,endpoints+24
 5660 008e 2670      		andi r18,lo8(6)
 5661               	.LBE1563:
 5662               	.LBE1562:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 5663               		.loc 2 82 0
 5664 0090 01F0      		breq .+2
 5665 0092 00C0      		rjmp .L204
 5666 0094 E0E0      		ldi r30,lo8(endpoints+24)
 5667 0096 F0E0      		ldi r31,hi8(endpoints+24)
 5668 0098 20E0      		ldi r18,lo8(ep_in_pipe_buffer)
 5669 009a 30E0      		ldi r19,hi8(ep_in_pipe_buffer)
 5670               	.LVL327:
 5671               	.L205:
 5672               	.LBB1564:
 5673               	.LBB1565:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 5674               		.loc 3 70 0
 5675 009c EFBE      		out __SREG__,r14
 5676               		.loc 3 71 0
 5677               	.LBE1565:
 5678               	.LBE1564:
 5679               	.LBE1559:
 5680               	.LBE1558:
 5681               	.LBE1557:
 5682               	.LBE1556:
 5683               	.LBE1555:
  27:Framework.h   ****     USB.INTFLAGSBSET = USB_TRNIF_bm;
 5684               		.loc 1 27 0
 5685 009e 82E0      		ldi r24,lo8(2)
 5686 00a0 A0EC      		ldi r26,lo8(1216)
 5687 00a2 B4E0      		ldi r27,hi8(1216)
 5688 00a4 1D96      		adiw r26,13
 5689 00a6 8C93      		st X,r24
 5690 00a8 1D97      		sbiw r26,13
 5691               	.LBB1597:
 5692               	.LBB1598:
 5693               	.LBB1599:
 5694               	.LBB1600:
 5695               	.LBB1601:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 5696               		.loc 4 57 0
 5697 00aa 96E0      		ldi r25,lo8(6)
 5698               	.L214:
 5699               	.LVL328:
 5700               	.LBE1601:
 5701               	.LBE1600:
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 5702               		.loc 2 123 0
 5703 00ac 4FB7      		in r20,__SREG__
 5704               	.LVL329:
 5705               	.LBB1603:
 5706               	.LBB1604:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 5707               		.loc 3 50 0
 5708               	/* #APP */
 5709               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 5710 00ae F894      		cli
 5711               	 ;  0 "" 2
 5712               	.LVL330:
 5713               	/* #NOAPP */
 5714               	.LBE1604:
 5715               	.LBE1603:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 5716               		.loc 2 124 0
 5717 00b0 8091 0000 		lds r24,ep_in_data+1
 5718 00b4 8823      		tst r24
 5719 00b6 01F4      		brne .+2
 5720 00b8 00C0      		rjmp .L265
 5721               	.L244:
 125:usb/usb_pipe.h **** 			r = false;
 5722               		.loc 2 125 0
 5723 00ba 80E0      		ldi r24,lo8(0)
 5724               	.L216:
 5725               	.LBB1605:
 5726               	.LBB1606:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 5727               		.loc 3 70 0
 5728 00bc 4FBF      		out __SREG__,r20
 5729               		.loc 3 71 0
 5730               	.LBE1606:
 5731               	.LBE1605:
 5732               	.LBE1599:
 5733               	.LBE1598:
 5734               	.LBE1597:
  28:Framework.h   ****     while (!usb_pipe_can_write(&ep_in)){
 5735               		.loc 1 28 0
 5736 00be 8823      		tst r24
 5737 00c0 01F4      		brne .L219
  29:Framework.h   ****         if (timeout_or_sampling_no_longer_enabled){
 5738               		.loc 1 29 0
 5739 00c2 8091 0000 		lds r24,timeout_or_sampling_no_longer_enabled
 5740 00c6 8823      		tst r24
 5741 00c8 01F0      		breq .L214
 5742               	.LVL331:
 5743               	.LBB1610:
 5744               	.LBB1611:
 5745               	.LBB1612:
  54:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 5746               		.loc 2 54 0
 5747 00ca 8FB7      		in r24,__SREG__
 5748               	.LVL332:
 5749               	.LBB1613:
 5750               	.LBB1614:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 5751               		.loc 3 50 0
 5752               	/* #APP */
 5753               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 5754 00cc F894      		cli
 5755               	 ;  0 "" 2
 5756               	.LVL333:
 5757               	/* #NOAPP */
 5758               	.LBE1614:
 5759               	.LBE1613:
 5760               	.LBB1615:
 5761               	.LBB1616:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 5762               		.loc 4 90 0
 5763 00ce 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 5764               		.loc 4 91 0
 5765 00d2 2093 0000 		sts ep_in_pipe_data+2,r18
 5766 00d6 3093 0000 		sts ep_in_pipe_data+2+1,r19
 5767 00da 2093 0000 		sts ep_in_pipe_data,r18
 5768 00de 3093 0000 		sts ep_in_pipe_data+1,r19
 5769               	.LVL334:
 5770               	.LBE1616:
 5771               	.LBE1615:
 5772               	.LBB1617:
 5773               	.LBB1618:
 158:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 5774               		.loc 5 158 0
 5775               	/* #APP */
 5776               	 ;  158 "usb/usb.h" 1
 5777 00e2 06E0      		ldi r16, 6
 5778 00e4 0593      		.dc.w 0x9305
 5779               		
 5780               	 ;  0 "" 2
 159:usb/usb.h     **** 		LACR16(&e->STATUS, USB_EP_BANK_bm);
 5781               		.loc 5 159 0
 5782               	 ;  159 "usb/usb.h" 1
 5783 00e6 08E0      		ldi r16, 8
 5784 00e8 0693      		.dc.w 0x9306
 5785               		
 5786               	 ;  0 "" 2
 5787               	/* #NOAPP */
 5788               	.LBE1618:
 5789               	.LBE1617:
  57:usb/usb_pipe.h **** 		p->data->flush = 0;
 5790               		.loc 2 57 0
 5791 00ea 1092 0000 		sts ep_in_data+1,__zero_reg__
  58:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
 5792               		.loc 2 58 0
 5793 00ee 1092 0000 		sts ep_in_data+2,__zero_reg__
 5794 00f2 1092 0000 		sts ep_in_data+2+1,__zero_reg__
  59:usb/usb_pipe.h **** 		p->data->bank = 0;
 5795               		.loc 2 59 0
 5796 00f6 1092 0000 		sts ep_in_data,__zero_reg__
 5797               	.LVL335:
 5798               	.LBB1619:
 5799               	.LBB1620:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 5800               		.loc 3 70 0
 5801 00fa 8FBF      		out __SREG__,r24
 5802               		.loc 3 71 0
 5803               	.LVL336:
 5804               	.L219:
 5805               	.LBE1620:
 5806               	.LBE1619:
 5807               	.LBE1612:
 5808               	.LBE1611:
 5809               	.LBE1610:
 5810               	.LBE1554:
 5811               	.LBE1553:
 5812               	.LBB1626:
 5813               	.LBB1627:
  95:gps/gps.h     ****   int index = 0;
 5814               		.loc 10 95 0
 5815 00fc 60E0      		ldi r22,lo8(0)
 5816 00fe 70E0      		ldi r23,hi8(0)
 5817 0100 40E0      		ldi r20,lo8(0)
 5818 0102 50E0      		ldi r21,hi8(0)
 5819               	.LVL337:
 5820 0104 20E0      		ldi r18,lo8(0)
 5821 0106 30E0      		ldi r19,hi8(0)
 5822 0108 7E01      		movw r14,r28
 5823               	.LVL338:
 5824 010a 0894      		sec
 5825 010c E11C      		adc r14,__zero_reg__
 5826 010e F11C      		adc r15,__zero_reg__
 5827 0110 E5E6      		ldi r30,lo8(101)
 5828 0112 CE2E      		mov r12,r30
 5829 0114 D12C      		mov r13,__zero_reg__
 5830 0116 CC0E      		add r12,r28
 5831 0118 DD1E      		adc r13,r29
 5832 011a F0E0      		ldi r31,lo8(.LC2)
 5833 011c 8F2E      		mov r8,r31
 5834 011e F0E0      		ldi r31,hi8(.LC2)
 5835 0120 9F2E      		mov r9,r31
 5836 0122 A3E3      		ldi r26,lo8(51)
 5837 0124 AA2E      		mov r10,r26
 5838 0126 B12C      		mov r11,__zero_reg__
 5839 0128 AC0E      		add r10,r28
 5840 012a BD1E      		adc r11,r29
 5841               	.LVL339:
 5842               	.L260:
 5843               	.LBE1627:
 5844               	.LBE1626:
 5845               	.LBB1628:
 5846               	.LBB1629:
 5847               	.LBB1630:
 5848               	.LBB1631:
  30:uart/uart.h   ****     while ( !( USART->STATUS & USART_RXCIF_bm) ); 
 5849               		.loc 9 30 0
 5850 012c 8091 A109 		lds r24,2465
 5851 0130 87FF      		sbrs r24,7
 5852 0132 00C0      		rjmp .L260
  33:uart/uart.h   ****     return USART->DATA; 
 5853               		.loc 9 33 0
 5854 0134 8091 A009 		lds r24,2464
 5855               	.LBE1631:
 5856               	.LBE1630:
 113:gps/gps.h     ****     if (index == length) {
 5857               		.loc 10 113 0
 5858 0138 2730      		cpi r18,7
 5859 013a 3105      		cpc r19,__zero_reg__
 5860 013c 01F4      		brne .+2
 5861 013e 00C0      		rjmp .L221
 5862               	.LVL340:
 118:gps/gps.h     ****     if (read == 1) {
 5863               		.loc 10 118 0
 5864 0140 4130      		cpi r20,1
 5865 0142 5105      		cpc r21,__zero_reg__
 5866 0144 01F4      		brne .+2
 5867 0146 00C0      		rjmp .L221
 132:gps/gps.h     ****     } else if (c == code[index]) {
 5868               		.loc 10 132 0
 5869 0148 F901      		movw r30,r18
 5870 014a E050      		subi r30,lo8(-(.LC3))
 5871 014c F040      		sbci r31,hi8(-(.LC3))
 5872 014e 9081      		ld r25,Z
 5873 0150 8917      		cp r24,r25
 5874 0152 01F4      		brne .+2
 5875 0154 00C0      		rjmp .L266
 137:gps/gps.h     ****       index = 0;
 5876               		.loc 10 137 0
 5877 0156 20E0      		ldi r18,lo8(0)
 5878 0158 30E0      		ldi r19,hi8(0)
 5879 015a 00C0      		rjmp .L260
 5880               	.LVL341:
 5881               	.L204:
 5882               	.LBE1629:
 5883               	.LBE1628:
 5884               	.LBB1658:
 5885               	.LBB1624:
 5886               	.LBB1621:
 5887               	.LBB1595:
 5888               	.LBB1593:
 5889               	.LBB1591:
 5890               	.LBB1589:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 5891               		.loc 2 83 0
 5892 015c 1B16      		cp __zero_reg__,r27
 5893 015e 04F4      		brge .L206
 5894               	.LVL342:
 5895               	.LBB1566:
 5896               	.LBB1567:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 5897               		.loc 2 69 0
 5898 0160 11E0      		ldi r17,lo8(1)
 5899 0162 0130      		cpi r16,lo8(1)
 5900 0164 01F4      		brne .L207
 5901 0166 10E0      		ldi r17,lo8(0)
 5902               	.L207:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 5903               		.loc 2 72 0
 5904 0168 0023      		tst r16
 5905 016a 01F0      		breq .+2
 5906 016c 00C0      		rjmp .L208
 5907               	.LVL343:
 5908               	.LBB1568:
 5909               	.LBB1569:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 5910               		.loc 5 168 0
 5911 016e 8093 0000 		sts endpoints+28,r24
 5912 0172 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 5913               		.loc 5 169 0
 5914 0176 20E4      		ldi r18,lo8(64)
 5915 0178 30E0      		ldi r19,hi8(64)
 5916 017a 2093 0000 		sts endpoints+26,r18
 5917 017e 3093 0000 		sts endpoints+26+1,r19
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 5918               		.loc 5 174 0
 5919 0182 E0E0      		ldi r30,lo8(endpoints+24)
 5920 0184 F0E0      		ldi r31,hi8(endpoints+24)
 5921               	.LVL344:
 5922               	/* #APP */
 5923               	 ;  174 "usb/usb.h" 1
 5924 0186 02E2      		ldi r16, 34
 5925 0188 0693      		.dc.w 0x9306
 5926               		
 5927               	 ;  0 "" 2
 5928               	.LVL345:
 5929               	/* #NOAPP */
 5930               	.L209:
 5931               	.LBE1569:
 5932               	.LBE1568:
 5933               	.LBE1567:
 5934               	.LBE1566:
 5935               	.LBB1573:
 5936               	.LBB1574:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 5937               		.loc 4 72 0
 5938 018a B150      		subi r27,lo8(-(-1))
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 5939               		.loc 4 73 0
 5940 018c 805C      		subi r24,lo8(-(64))
 5941 018e 9F4F      		sbci r25,hi8(-(64))
 5942               	.LVL346:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 5943               		.loc 2 69 0
 5944 0190 012F      		mov r16,r17
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 5945               		.loc 4 75 0
 5946 0192 20E0      		ldi r18,hi8(ep_in_pipe_buffer+512)
 5947 0194 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 5948 0196 9207      		cpc r25,r18
 5949 0198 01F4      		brne .+2
 5950 019a 00C0      		rjmp .L267
 5951 019c 20E0      		ldi r18,lo8(ep_in_pipe_buffer)
 5952 019e 30E0      		ldi r19,hi8(ep_in_pipe_buffer)
 5953               	.LVL347:
 5954               	.L210:
 5955               	.LBE1574:
 5956               	.LBE1573:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 5957               		.loc 2 91 0
 5958 01a0 B093 0000 		sts ep_in_pipe_data+4,r27
 5959 01a4 8093 0000 		sts ep_in_pipe_data,r24
 5960 01a8 9093 0000 		sts ep_in_pipe_data+1,r25
 5961 01ac 0093 0000 		sts ep_in_data,r16
 5962 01b0 A093 0000 		sts ep_in_data+1,r26
 5963 01b4 4093 0000 		sts ep_in_data+2,r20
 5964 01b8 5093 0000 		sts ep_in_data+2+1,r21
 5965 01bc A0E0      		ldi r26,lo8(ep_in_pipe_data)
 5966 01be B0E0      		ldi r27,hi8(ep_in_pipe_data)
 5967 01c0 1296      		adiw r26,2
 5968 01c2 6D93      		st X+,r22
 5969 01c4 7C93      		st X,r23
 5970 01c6 1397      		sbiw r26,2+1
 5971 01c8 00C0      		rjmp .L205
 5972               	.LVL348:
 5973               	.L206:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 5974               		.loc 2 87 0
 5975 01ca A130      		cpi r26,lo8(1)
 5976 01cc 01F4      		brne .+2
 5977 01ce 00C0      		rjmp .L268
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 5978               		.loc 2 91 0
 5979 01d0 A230      		cpi r26,lo8(2)
 5980 01d2 01F4      		brne .+2
 5981 01d4 00C0      		rjmp .L261
 5982               	.L264:
 5983 01d6 E0E0      		ldi r30,lo8(endpoints+24)
 5984 01d8 F0E0      		ldi r31,hi8(endpoints+24)
 5985 01da 20E0      		ldi r18,lo8(ep_in_pipe_buffer)
 5986 01dc 30E0      		ldi r19,hi8(ep_in_pipe_buffer)
 5987 01de 00C0      		rjmp .L210
 5988               	.LVL349:
 5989               	.L221:
 5990               	.LBE1589:
 5991               	.LBE1591:
 5992               	.LBE1593:
 5993               	.LBE1595:
 5994               	.LBE1621:
 5995               	.LBE1624:
 5996               	.LBE1658:
 5997               	.LBB1659:
 5998               	.LBB1655:
 120:gps/gps.h     ****       buff[buff_index] = c;
 5999               		.loc 10 120 0
 6000 01e0 E7E9      		ldi r30,lo8(151)
 6001 01e2 F0E0      		ldi r31,hi8(151)
 6002 01e4 EC0F      		add r30,r28
 6003 01e6 FD1F      		adc r31,r29
 6004 01e8 E60F      		add r30,r22
 6005 01ea F71F      		adc r31,r23
 6006 01ec 8083      		st Z,r24
 121:gps/gps.h     ****       buff_index++;
 6007               		.loc 10 121 0
 6008 01ee 6F5F      		subi r22,lo8(-(1))
 6009 01f0 7F4F      		sbci r23,hi8(-(1))
 6010               	.LVL350:
 123:gps/gps.h     ****       if (c == '\r' || c == '\n' || c == 'W' || c == 'E') {
 6011               		.loc 10 123 0
 6012 01f2 8D30      		cpi r24,lo8(13)
 6013 01f4 01F0      		breq .L223
 6014 01f6 8A30      		cpi r24,lo8(10)
 6015 01f8 01F0      		breq .L223
 6016 01fa 8735      		cpi r24,lo8(87)
 6017 01fc 01F0      		breq .L223
 6018 01fe 8534      		cpi r24,lo8(69)
 6019 0200 01F0      		breq .L223
 6020 0202 41E0      		ldi r20,lo8(1)
 6021 0204 50E0      		ldi r21,hi8(1)
 6022 0206 00C0      		rjmp .L260
 6023               	.LVL351:
 6024               	.L266:
 134:gps/gps.h     ****       index++;
 6025               		.loc 10 134 0
 6026 0208 2F5F      		subi r18,lo8(-(1))
 6027 020a 3F4F      		sbci r19,hi8(-(1))
 6028               	.LVL352:
 6029 020c 00C0      		rjmp .L260
 6030               	.LVL353:
 6031               	.L223:
 125:gps/gps.h     ****         buff[buff_index] = '\0';
 6032               		.loc 10 125 0
 6033 020e 87E9      		ldi r24,lo8(151)
 6034 0210 90E0      		ldi r25,hi8(151)
 6035 0212 8C0F      		add r24,r28
 6036 0214 9D1F      		adc r25,r29
 6037 0216 680F      		add r22,r24
 6038 0218 791F      		adc r23,r25
 6039               	.LVL354:
 6040 021a DB01      		movw r26,r22
 6041 021c 1C92      		st X,__zero_reg__
 6042               	.LVL355:
 6043               	.LBB1632:
 6044               	.LBB1633:
 6045               	.LBB1634:
 6046               	.LBB1635:
  45:nmea/nmea.h   ****   token[0] = strtok(s, ","); //get pointer to first token found and store in
 6047               		.loc 8 45 0
 6048 021e CE01      		movw r24,r28
 6049 0220 8956      		subi r24,lo8(-(151))
 6050 0222 9F4F      		sbci r25,hi8(-(151))
 6051 0224 60E0      		ldi r22,lo8(.LC0)
 6052 0226 70E0      		ldi r23,hi8(.LC0)
 6053 0228 0E94 0000 		call strtok
  47:nmea/nmea.h   ****   while(token[i] != NULL) {  //while commas continue to be found
 6054               		.loc 8 47 0
 6055 022c 0097      		sbiw r24,0
 6056 022e 01F0      		breq .L225
 6057 0230 10E0      		ldi r17,lo8(0)
 6058               	.LVL356:
 6059               	.L226:
  48:nmea/nmea.h   ****       i++;  
 6060               		.loc 8 48 0
 6061 0232 1F5F      		subi r17,lo8(-(1))
 6062               	.LVL357:
  49:nmea/nmea.h   ****       token[i] = strtok(NULL, ","); //continue to split the string
 6063               		.loc 8 49 0
 6064 0234 80E0      		ldi r24,lo8(0)
 6065 0236 90E0      		ldi r25,hi8(0)
 6066 0238 60E0      		ldi r22,lo8(.LC0)
 6067 023a 70E0      		ldi r23,hi8(.LC0)
 6068 023c 0E94 0000 		call strtok
 6069 0240 E12F      		mov r30,r17
 6070 0242 F0E0      		ldi r31,lo8(0)
 6071 0244 EE0F      		lsl r30
 6072 0246 FF1F      		rol r31
 6073 0248 EE0D      		add r30,r14
 6074 024a FF1D      		adc r31,r15
 6075 024c 8083      		st Z,r24
 6076 024e 9183      		std Z+1,r25
  47:nmea/nmea.h   ****   while(token[i] != NULL) {  //while commas continue to be found
 6077               		.loc 8 47 0
 6078 0250 0097      		sbiw r24,0
 6079 0252 01F4      		brne .L226
 6080               	.LVL358:
 6081               	.L225:
  67:nmea/nmea.h   ****   char* valid = token[1]; //A --> Valid, V --> Invalid
 6082               		.loc 8 67 0
 6083 0254 EB81      		ldd r30,Y+3
 6084 0256 FC81      		ldd r31,Y+4
 6085               	.LVL359:
  68:nmea/nmea.h   ****   char* lat_str = token[2]; //longitude
 6086               		.loc 8 68 0
 6087 0258 5D80      		ldd r5,Y+5
 6088 025a 4E80      		ldd r4,Y+6
 6089               	.LVL360:
  69:nmea/nmea.h   ****   char* lng_str = token[4]; //latitude
 6090               		.loc 8 69 0
 6091 025c 3984      		ldd r3,Y+9
 6092 025e 2A84      		ldd r2,Y+10
 6093               	.LVL361:
  71:nmea/nmea.h   ****   gps->valid = *valid;
 6094               		.loc 8 71 0
 6095 0260 8081      		ld r24,Z
 6096 0262 8093 0000 		sts gps+12,r24
  73:nmea/nmea.h   ****   if (*valid == 'A') {
 6097               		.loc 8 73 0
 6098 0266 8081      		ld r24,Z
 6099 0268 8134      		cpi r24,lo8(65)
 6100 026a 01F0      		breq .L269
  89:nmea/nmea.h   ****     gps->valid = 0;
 6101               		.loc 8 89 0
 6102 026c 1092 0000 		sts gps+12,__zero_reg__
  90:nmea/nmea.h   ****     send_string("No GPS Signal");
 6103               		.loc 8 90 0
 6104 0270 80E0      		ldi r24,lo8(.LC1)
 6105 0272 90E0      		ldi r25,hi8(.LC1)
 6106 0274 0E94 0000 		call send_string
 6107               	.LBE1635:
 6108               	.LBE1634:
 103:nmea/nmea.h   ****     if (gps->dist > max_dist) {
 6109               		.loc 8 103 0
 6110 0278 6091 0000 		lds r22,max_dist
 6111 027c 7091 0000 		lds r23,max_dist+1
 6112 0280 8091 0000 		lds r24,max_dist+2
 6113 0284 9091 0000 		lds r25,max_dist+3
 6114 0288 2091 0000 		lds r18,gps+8
 6115 028c 3091 0000 		lds r19,gps+8+1
 6116 0290 4091 0000 		lds r20,gps+8+2
 6117 0294 5091 0000 		lds r21,gps+8+3
 6118 0298 0E94 0000 		call __ltsf2
 6119 029c 87FD      		sbrc r24,7
 6120 029e 00C0      		rjmp .L230
 6121               	.L231:
 6122               	.LBE1633:
 6123               	.LBE1632:
 6124               	.LBE1655:
 6125               	.LBE1659:
  63:main.c        ****     if (gps.valid) {
 6126               		.loc 6 63 0
 6127 02a0 8091 0000 		lds r24,gps+12
 6128 02a4 8823      		tst r24
 6129 02a6 01F0      		breq .L242
  64:main.c        ****     	if (gps.roaming) {
 6130               		.loc 6 64 0
 6131 02a8 8091 0000 		lds r24,gps+13
 6132 02ac 8823      		tst r24
 6133 02ae 01F0      		breq .+2
 6134 02b0 00C0      		rjmp .L270
  69:main.c        ****     		freq = LOW_FREQ;
 6135               		.loc 6 69 0
 6136 02b2 1092 0000 		sts freq,__zero_reg__
 6137               	.L242:
 6138               	.LVL362:
 6139               	.LBB1660:
 6140               	.LBB1661:
 6141               		.loc 11 164 0
 6142 02b6 8FEF      		 ldi r24,lo8(159999999)
 6143 02b8 97E6      	    ldi r25,hi8(159999999)
 6144 02ba A9E8      	    ldi r26,hlo8(159999999)
 6145 02bc B9E0      	    ldi r27,hhi8(159999999)
 6146 02be 8150      	    1:subi r24,1
 6147 02c0 9040      	    sbci r25,0
 6148 02c2 A040      	    sbci r26,0
 6149 02c4 B040      	    sbci r27,0
 6150 02c6 01F4      	    brne 1b
 6151 02c8 00C0      		rjmp .
 6152 02ca 0000      		nop
 104:gps/gps.h     ****   int buff_index = 0;
 6153               		.loc 10 104 0
 6154 02cc 60E0      		ldi r22,lo8(0)
 6155 02ce 70E0      		ldi r23,hi8(0)
  98:gps/gps.h     ****   int read = 0;
 6156               		.loc 10 98 0
 6157 02d0 40E0      		ldi r20,lo8(0)
 6158 02d2 50E0      		ldi r21,hi8(0)
  95:gps/gps.h     ****   int index = 0;
 6159               		.loc 10 95 0
 6160 02d4 20E0      		ldi r18,lo8(0)
 6161 02d6 30E0      		ldi r19,hi8(0)
 6162               	.LVL363:
 6163 02d8 00C0      		rjmp .L260
 6164               	.LVL364:
 6165               	.L269:
 6166               	.LBE1661:
 6167               	.LBE1660:
 6168               	.LBB1662:
 6169               	.LBB1656:
 6170               	.LBB1653:
 6171               	.LBB1651:
 6172               	.LBB1644:
 6173               	.LBB1642:
 6174               	.LBB1636:
  74:nmea/nmea.h   ****     gps->valid = 1;
 6175               		.loc 8 74 0
 6176 02da B1E0      		ldi r27,lo8(1)
 6177 02dc B093 0000 		sts gps+12,r27
 6178               	.LVL365:
 6179               	.LBB1637:
 6180               	.LBB1638:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 6181               		.loc 7 16 0
 6182 02e0 E32D      		mov r30,r3
 6183 02e2 F22D      		mov r31,r2
 6184 02e4 DF01      		movw r26,r30
 6185 02e6 0D90      		ld __tmp_reg__,X+
 6186 02e8 0020      		tst __tmp_reg__
 6187 02ea 01F4      		brne .-6
 6188 02ec CD01      		movw r24,r26
 6189 02ee 8E1B      		sub r24,r30
 6190 02f0 9F0B      		sbc r25,r31
 6191 02f2 0196      		adiw r24,1
 6192 02f4 0E94 0000 		call malloc
 6193 02f8 792E      		mov r7,r25
 6194 02fa 082F      		mov r16,r24
 6195 02fc 192F      		mov r17,r25
 6196               	.LVL366:
  18:utils/utils.h ****     strcpy(result, s1);
 6197               		.loc 7 18 0
 6198 02fe 20E2      		ldi r18,lo8(32)
 6199 0300 30E0      		ldi r19,hi8(32)
 6200 0302 F801      		movw r30,r16
 6201 0304 2083      		st Z,r18
 6202 0306 3183      		std Z+1,r19
  19:utils/utils.h ****     strcat(result, s2);
 6203               		.loc 7 19 0
 6204 0308 C801      		movw r24,r16
 6205 030a 632D      		mov r22,r3
 6206 030c 722D      		mov r23,r2
 6207 030e 0E94 0000 		call strcat
 6208               	.LVL367:
 6209               	.LBE1638:
 6210               	.LBE1637:
 6211               	.LBB1639:
 6212               	.LBB1640:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 6213               		.loc 7 16 0
 6214 0312 452D      		mov r20,r5
 6215 0314 542D      		mov r21,r4
 6216 0316 DA01      		movw r26,r20
 6217 0318 0D90      		ld __tmp_reg__,X+
 6218 031a 0020      		tst __tmp_reg__
 6219 031c 01F4      		brne .-6
 6220 031e 9D01      		movw r18,r26
 6221 0320 E02F      		mov r30,r16
 6222 0322 F72D      		mov r31,r7
 6223 0324 DF01      		movw r26,r30
 6224 0326 0D90      		ld __tmp_reg__,X+
 6225 0328 0020      		tst __tmp_reg__
 6226 032a 01F4      		brne .-6
 6227 032c CD01      		movw r24,r26
 6228 032e 0197      		sbiw r24,1
 6229 0330 8E1B      		sub r24,r30
 6230 0332 9F0B      		sbc r25,r31
 6231 0334 841B      		sub r24,r20
 6232 0336 950B      		sbc r25,r21
 6233 0338 820F      		add r24,r18
 6234 033a 931F      		adc r25,r19
 6235 033c 0E94 0000 		call malloc
 6236 0340 782E      		mov r7,r24
 6237 0342 692E      		mov r6,r25
 6238               	.LVL368:
  18:utils/utils.h ****     strcpy(result, s1);
 6239               		.loc 7 18 0
 6240 0344 652D      		mov r22,r5
 6241 0346 742D      		mov r23,r4
 6242 0348 0E94 0000 		call strcpy
 6243               	.LVL369:
  19:utils/utils.h ****     strcat(result, s2);
 6244               		.loc 7 19 0
 6245 034c 872D      		mov r24,r7
 6246 034e 962D      		mov r25,r6
 6247 0350 B801      		movw r22,r16
 6248 0352 0E94 0000 		call strcat
 6249               	.LBE1640:
 6250               	.LBE1639:
  76:nmea/nmea.h   ****     send_string(string_rep);
 6251               		.loc 8 76 0
 6252 0356 872D      		mov r24,r7
 6253 0358 962D      		mov r25,r6
 6254 035a 0E94 0000 		call send_string
  78:nmea/nmea.h   ****     gps->lat = atof(lat_str)/100.;
 6255               		.loc 8 78 0
 6256 035e 852D      		mov r24,r5
 6257 0360 942D      		mov r25,r4
 6258 0362 0E94 0000 		call atof
 6259 0366 20E0      		ldi r18,lo8(0x42c80000)
 6260 0368 30E0      		ldi r19,hi8(0x42c80000)
 6261 036a 48EC      		ldi r20,hlo8(0x42c80000)
 6262 036c 52E4      		ldi r21,hhi8(0x42c80000)
 6263 036e 0E94 0000 		call __divsf3
 6264 0372 DC01      		movw r26,r24
 6265 0374 CB01      		movw r24,r22
 6266 0376 8093 0000 		sts gps,r24
 6267 037a 9093 0000 		sts gps+1,r25
 6268 037e A093 0000 		sts gps+2,r26
 6269 0382 B093 0000 		sts gps+3,r27
  81:nmea/nmea.h   ****     gps->lng = atof(lng_str)/100.;
 6270               		.loc 8 81 0
 6271 0386 832D      		mov r24,r3
 6272 0388 922D      		mov r25,r2
 6273 038a 0E94 0000 		call atof
 6274 038e 20E0      		ldi r18,lo8(0x42c80000)
 6275 0390 30E0      		ldi r19,hi8(0x42c80000)
 6276 0392 48EC      		ldi r20,hlo8(0x42c80000)
 6277 0394 52E4      		ldi r21,hhi8(0x42c80000)
 6278 0396 0E94 0000 		call __divsf3
 6279 039a F62F      		mov r31,r22
 6280 039c E72F      		mov r30,r23
 6281 039e 382F      		mov r19,r24
 6282 03a0 292F      		mov r18,r25
 6283 03a2 DF01      		movw r26,r30
 6284 03a4 C901      		movw r24,r18
 6285 03a6 4B2F      		mov r20,r27
 6286 03a8 5A2F      		mov r21,r26
 6287 03aa 692F      		mov r22,r25
 6288 03ac 782F      		mov r23,r24
 6289 03ae 4093 0000 		sts gps+4,r20
 6290 03b2 5093 0000 		sts gps+4+1,r21
 6291 03b6 6093 0000 		sts gps+4+2,r22
 6292 03ba 7093 0000 		sts gps+4+3,r23
  82:nmea/nmea.h   ****     gps->dist = distance(gps->lat, gps->lng);
 6293               		.loc 8 82 0
 6294 03be 4091 0000 		lds r20,gps
 6295 03c2 5091 0000 		lds r21,gps+1
 6296 03c6 6091 0000 		lds r22,gps+2
 6297 03ca 7091 0000 		lds r23,gps+3
 6298 03ce CB01      		movw r24,r22
 6299 03d0 BA01      		movw r22,r20
 6300 03d2 A901      		movw r20,r18
 6301 03d4 0B2F      		mov r16,r27
 6302               	.LVL370:
 6303 03d6 1A2F      		mov r17,r26
 6304 03d8 252F      		mov r18,r21
 6305 03da 342F      		mov r19,r20
 6306 03dc A901      		movw r20,r18
 6307 03de 9801      		movw r18,r16
 6308 03e0 0E94 0000 		call distance
 6309 03e4 6093 0000 		sts gps+8,r22
 6310 03e8 7093 0000 		sts gps+8+1,r23
 6311 03ec 8093 0000 		sts gps+8+2,r24
 6312 03f0 9093 0000 		sts gps+8+3,r25
  83:nmea/nmea.h   ****     if (gps->dist > max_dist) {
 6313               		.loc 8 83 0
 6314 03f4 2091 0000 		lds r18,max_dist
 6315 03f8 3091 0000 		lds r19,max_dist+1
 6316 03fc 4091 0000 		lds r20,max_dist+2
 6317 0400 5091 0000 		lds r21,max_dist+3
 6318 0404 0E94 0000 		call __gtsf2
 6319 0408 1816      		cp __zero_reg__,r24
 6320 040a 04F0      		brlt .+2
 6321 040c 00C0      		rjmp .L263
  84:nmea/nmea.h   ****       gps->roaming = 1;
 6322               		.loc 8 84 0
 6323 040e B1E0      		ldi r27,lo8(1)
 6324 0410 B093 0000 		sts gps+13,r27
 6325               	.LVL371:
 6326               	.L230:
 6327               	.LBE1636:
 6328               	.LBE1642:
 6329               	.LBE1644:
 6330               	.LBB1645:
 109:nmea/nmea.h   ****       sprintf(lat_buff, "%f", gps->lat);
 6331               		.loc 8 109 0
 6332 0414 EDB7      		in r30,__SP_L__
 6333 0416 FEB7      		in r31,__SP_H__
 6334 0418 3897      		sbiw r30,8
 6335 041a EDBF      		out __SP_L__,r30
 6336 041c FEBF      		out __SP_H__,r31
 6337 041e 3196      		adiw r30,1
 6338 0420 ADB7      		in r26,__SP_L__
 6339 0422 BEB7      		in r27,__SP_H__
 6340 0424 1196      		adiw r26,1
 6341 0426 CD92      		st X+,r12
 6342 0428 DC92      		st X,r13
 6343 042a 1297      		sbiw r26,1+1
 6344 042c 8282      		std Z+2,r8
 6345 042e 9382      		std Z+3,r9
 6346 0430 8091 0000 		lds r24,gps
 6347 0434 9091 0000 		lds r25,gps+1
 6348 0438 A091 0000 		lds r26,gps+2
 6349 043c B091 0000 		lds r27,gps+3
 6350 0440 8483      		std Z+4,r24
 6351 0442 9583      		std Z+5,r25
 6352 0444 A683      		std Z+6,r26
 6353 0446 B783      		std Z+7,r27
 6354               		.cfi_escape 0x2e,0x8
 6355 0448 0E94 0000 		call sprintf
 110:nmea/nmea.h   ****       sprintf(lng_buff, "%f", gps->lng);
 6356               		.loc 8 110 0
 6357 044c EDB7      		in r30,__SP_L__
 6358 044e FEB7      		in r31,__SP_H__
 6359 0450 3196      		adiw r30,1
 6360 0452 ADB7      		in r26,__SP_L__
 6361 0454 BEB7      		in r27,__SP_H__
 6362 0456 1196      		adiw r26,1
 6363 0458 AD92      		st X+,r10
 6364 045a BC92      		st X,r11
 6365 045c 1297      		sbiw r26,1+1
 6366 045e 8282      		std Z+2,r8
 6367 0460 9382      		std Z+3,r9
 6368 0462 8091 0000 		lds r24,gps+4
 6369 0466 9091 0000 		lds r25,gps+4+1
 6370 046a A091 0000 		lds r26,gps+4+2
 6371 046e B091 0000 		lds r27,gps+4+3
 6372 0472 8483      		std Z+4,r24
 6373 0474 9583      		std Z+5,r25
 6374 0476 A683      		std Z+6,r26
 6375 0478 B783      		std Z+7,r27
 6376 047a 0E94 0000 		call sprintf
 111:nmea/nmea.h   ****       sprintf(dist_buff, "%f", gps->dist);
 6377               		.loc 8 111 0
 6378 047e EDB7      		in r30,__SP_L__
 6379 0480 FEB7      		in r31,__SP_H__
 6380 0482 3196      		adiw r30,1
 6381 0484 ADB7      		in r26,__SP_L__
 6382 0486 BEB7      		in r27,__SP_H__
 6383 0488 1196      		adiw r26,1
 6384 048a ED92      		st X+,r14
 6385 048c FC92      		st X,r15
 6386 048e 1297      		sbiw r26,1+1
 6387 0490 8282      		std Z+2,r8
 6388 0492 9382      		std Z+3,r9
 6389 0494 8091 0000 		lds r24,gps+8
 6390 0498 9091 0000 		lds r25,gps+8+1
 6391 049c A091 0000 		lds r26,gps+8+2
 6392 04a0 B091 0000 		lds r27,gps+8+3
 6393 04a4 8483      		std Z+4,r24
 6394 04a6 9583      		std Z+5,r25
 6395 04a8 A683      		std Z+6,r26
 6396 04aa B783      		std Z+7,r27
 6397 04ac 0E94 0000 		call sprintf
 6398               	.LVL372:
 6399               	.LBB1646:
 6400               	.LBB1647:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 6401               		.loc 7 16 0
 6402 04b0 F601      		movw r30,r12
 6403 04b2 0190      		ld __tmp_reg__,Z+
 6404 04b4 0020      		tst __tmp_reg__
 6405 04b6 01F4      		brne .-6
 6406 04b8 CF01      		movw r24,r30
 6407 04ba 8C19      		sub r24,r12
 6408 04bc 9D09      		sbc r25,r13
 6409 04be 2DB7      		in r18,__SP_L__
 6410 04c0 3EB7      		in r19,__SP_H__
 6411 04c2 285F      		subi r18,lo8(-(8))
 6412 04c4 3F4F      		sbci r19,hi8(-(8))
 6413 04c6 2DBF      		out __SP_L__,r18
 6414 04c8 3EBF      		out __SP_H__,r19
 6415 04ca 0196      		adiw r24,1
 6416               		.cfi_escape 0x2e,0
 6417 04cc 0E94 0000 		call malloc
 6418 04d0 792E      		mov r7,r25
 6419 04d2 082F      		mov r16,r24
 6420 04d4 192F      		mov r17,r25
 6421               	.LVL373:
  18:utils/utils.h ****     strcpy(result, s1);
 6422               		.loc 7 18 0
 6423 04d6 C801      		movw r24,r16
 6424 04d8 B601      		movw r22,r12
 6425 04da 0E94 0000 		call strcpy
  19:utils/utils.h ****     strcat(result, s2);
 6426               		.loc 7 19 0
 6427 04de A02F      		mov r26,r16
 6428 04e0 B72D      		mov r27,r7
 6429 04e2 FD01      		movw r30,r26
 6430 04e4 0190      		ld __tmp_reg__,Z+
 6431 04e6 0020      		tst __tmp_reg__
 6432 04e8 01F4      		brne .-6
 6433 04ea 3197      		sbiw r30,1
 6434 04ec EA1B      		sub r30,r26
 6435 04ee FB0B      		sbc r31,r27
 6436 04f0 E00F      		add r30,r16
 6437 04f2 F11F      		adc r31,r17
 6438 04f4 8CE2      		ldi r24,lo8(44)
 6439 04f6 90E0      		ldi r25,hi8(44)
 6440 04f8 8083      		st Z,r24
 6441 04fa 9183      		std Z+1,r25
 6442               	.LVL374:
 6443               	.LBE1647:
 6444               	.LBE1646:
 6445               	.LBB1648:
 6446               	.LBB1649:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 6447               		.loc 7 16 0
 6448 04fc FD01      		movw r30,r26
 6449 04fe 0190      		ld __tmp_reg__,Z+
 6450 0500 0020      		tst __tmp_reg__
 6451 0502 01F4      		brne .-6
 6452 0504 9F01      		movw r18,r30
 6453 0506 F501      		movw r30,r10
 6454 0508 0190      		ld __tmp_reg__,Z+
 6455 050a 0020      		tst __tmp_reg__
 6456 050c 01F4      		brne .-6
 6457 050e CF01      		movw r24,r30
 6458 0510 0197      		sbiw r24,1
 6459 0512 8A19      		sub r24,r10
 6460 0514 9B09      		sbc r25,r11
 6461 0516 8A1B      		sub r24,r26
 6462 0518 9B0B      		sbc r25,r27
 6463 051a 820F      		add r24,r18
 6464 051c 931F      		adc r25,r19
 6465 051e 0E94 0000 		call malloc
 6466 0522 782E      		mov r7,r24
 6467 0524 692E      		mov r6,r25
 6468               	.LVL375:
  18:utils/utils.h ****     strcpy(result, s1);
 6469               		.loc 7 18 0
 6470 0526 B801      		movw r22,r16
 6471 0528 0E94 0000 		call strcpy
 6472               	.LVL376:
  19:utils/utils.h ****     strcat(result, s2);
 6473               		.loc 7 19 0
 6474 052c 872D      		mov r24,r7
 6475 052e 962D      		mov r25,r6
 6476 0530 B501      		movw r22,r10
 6477 0532 0E94 0000 		call strcat
 6478               	.LBE1649:
 6479               	.LBE1648:
 138:nmea/nmea.h   ****       gps->sms = concat(concat(lat_str, ","), lng_str);
 6480               		.loc 8 138 0
 6481 0536 7092 0000 		sts gps+14,r7
 6482 053a 6092 0000 		sts gps+15,r6
 6483 053e 00C0      		rjmp .L231
 6484               	.LVL377:
 6485               	.L270:
 6486               	.LBE1645:
 6487               	.LBE1651:
 6488               	.LBE1653:
 6489               	.LBE1656:
 6490               	.LBE1662:
  65:main.c        **** 		  	send_message(phonenumber, gps.sms, &USARTC0);
 6491               		.loc 6 65 0
 6492 0540 1091 0000 		lds r17,phonenumber
 6493 0544 0091 0000 		lds r16,phonenumber+1
 6494 0548 4090 0000 		lds r4,gps+14
 6495 054c 5090 0000 		lds r5,gps+14+1
 6496               	.LVL378:
 6497               	.L235:
 6498               	.LBB1663:
 6499               	.LBB1664:
 6500               	.LBB1665:
 6501               	.LBB1666:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 6502               		.loc 9 18 0
 6503 0550 8091 A108 		lds r24,2209
 6504 0554 85FF      		sbrs r24,5
 6505 0556 00C0      		rjmp .L235
  21:uart/uart.h   ****     USART->DATA = c; 
 6506               		.loc 9 21 0
 6507 0558 FDE0      		ldi r31,lo8(13)
 6508 055a F093 A008 		sts 2208,r31
 6509               	.LVL379:
 6510               	.LBE1666:
 6511               	.LBE1665:
 6512               	.LBB1667:
 6513               	.LBB1668:
 6514               		.loc 11 164 0
 6515 055e 8FEF      		 ldi r24,lo8(639999)
 6516 0560 93EC      	    ldi r25,hi8(639999)
 6517 0562 A9E0      	    ldi r26,hlo8(639999)
 6518 0564 8150      	    1:subi r24,1
 6519 0566 9040      	    sbci r25,0
 6520 0568 A040      	    sbci r26,0
 6521 056a 01F4      	    brne 1b
 6522 056c 00C0      		rjmp .
 6523 056e 0000      		nop
 6524               	.LVL380:
 6525               	.LBE1668:
 6526               	.LBE1667:
 6527               	.LBB1669:
 6528               	.LBB1670:
  42:sms/sms.h     ****   send_uart("AT+CMGF=1", USART);
 6529               		.loc 13 42 0
 6530 0570 80E0      		ldi r24,lo8(.LC4)
 6531 0572 90E0      		ldi r25,hi8(.LC4)
 6532 0574 60EA      		ldi r22,lo8(2208)
 6533 0576 78E0      		ldi r23,hi8(2208)
 6534 0578 0E94 0000 		call send_uart
 6535               	.LVL381:
 6536               	.LBE1670:
 6537               	.LBE1669:
 6538               	.LBB1671:
 6539               	.LBB1672:
 6540               		.loc 11 164 0
 6541 057c 8FEF      		 ldi r24,lo8(639999)
 6542 057e 93EC      	    ldi r25,hi8(639999)
 6543 0580 A9E0      	    ldi r26,hlo8(639999)
 6544 0582 8150      	    1:subi r24,1
 6545 0584 9040      	    sbci r25,0
 6546 0586 A040      	    sbci r26,0
 6547 0588 01F4      	    brne 1b
 6548 058a 00C0      		rjmp .
 6549 058c 0000      		nop
 6550               	.LVL382:
 6551               	.LBE1672:
 6552               	.LBE1671:
 6553               	.LBB1673:
 6554               	.LBB1674:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 6555               		.loc 7 16 0
 6556 058e E12F      		mov r30,r17
 6557 0590 F02F      		mov r31,r16
 6558 0592 DF01      		movw r26,r30
 6559 0594 0D90      		ld __tmp_reg__,X+
 6560 0596 0020      		tst __tmp_reg__
 6561 0598 01F4      		brne .-6
 6562 059a CD01      		movw r24,r26
 6563 059c 8E1B      		sub r24,r30
 6564 059e 9F0B      		sbc r25,r31
 6565 05a0 0996      		adiw r24,9
 6566 05a2 0E94 0000 		call malloc
 6567 05a6 782E      		mov r7,r24
 6568 05a8 692E      		mov r6,r25
 6569               	.LVL383:
  18:utils/utils.h ****     strcpy(result, s1);
 6570               		.loc 7 18 0
 6571 05aa E82F      		mov r30,r24
 6572 05ac F92F      		mov r31,r25
 6573 05ae A0E0      		ldi r26,lo8(.LC5)
 6574 05b0 B0E0      		ldi r27,hi8(.LC5)
 6575 05b2 8AE0      		ldi r24,lo8(10)
 6576               	.LVL384:
 6577               	.L236:
 6578 05b4 0D90      		ld r0,X+
 6579 05b6 0192      		st Z+,r0
 6580 05b8 8150      		subi r24,lo8(-(-1))
 6581 05ba 01F4      		brne .L236
  19:utils/utils.h ****     strcat(result, s2);
 6582               		.loc 7 19 0
 6583 05bc 872D      		mov r24,r7
 6584 05be 962D      		mov r25,r6
 6585               	.LVL385:
 6586 05c0 612F      		mov r22,r17
 6587 05c2 702F      		mov r23,r16
 6588 05c4 0E94 0000 		call strcat
 6589               	.LVL386:
 6590               	.LBE1674:
 6591               	.LBE1673:
 6592               	.LBB1675:
 6593               	.LBB1676:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 6594               		.loc 7 16 0
 6595 05c8 E72D      		mov r30,r7
 6596 05ca F62D      		mov r31,r6
 6597 05cc DF01      		movw r26,r30
 6598 05ce 0D90      		ld __tmp_reg__,X+
 6599 05d0 0020      		tst __tmp_reg__
 6600 05d2 01F4      		brne .-6
 6601 05d4 CD01      		movw r24,r26
 6602 05d6 8E1B      		sub r24,r30
 6603 05d8 9F0B      		sbc r25,r31
 6604 05da 0196      		adiw r24,1
 6605 05dc 0E94 0000 		call malloc
 6606 05e0 392E      		mov r3,r25
 6607 05e2 082F      		mov r16,r24
 6608               	.LVL387:
 6609 05e4 192F      		mov r17,r25
 6610               	.LVL388:
  18:utils/utils.h ****     strcpy(result, s1);
 6611               		.loc 7 18 0
 6612 05e6 C801      		movw r24,r16
 6613 05e8 672D      		mov r22,r7
 6614 05ea 762D      		mov r23,r6
 6615 05ec 0E94 0000 		call strcpy
  19:utils/utils.h ****     strcat(result, s2);
 6616               		.loc 7 19 0
 6617 05f0 A02F      		mov r26,r16
 6618 05f2 B32D      		mov r27,r3
 6619 05f4 FD01      		movw r30,r26
 6620 05f6 0190      		ld __tmp_reg__,Z+
 6621 05f8 0020      		tst __tmp_reg__
 6622 05fa 01F4      		brne .-6
 6623 05fc 3197      		sbiw r30,1
 6624 05fe EA1B      		sub r30,r26
 6625 0600 FB0B      		sbc r31,r27
 6626 0602 E00F      		add r30,r16
 6627 0604 F11F      		adc r31,r17
 6628 0606 22E2      		ldi r18,lo8(34)
 6629 0608 30E0      		ldi r19,hi8(34)
 6630 060a 2083      		st Z,r18
 6631 060c 3183      		std Z+1,r19
 6632               	.LBE1676:
 6633               	.LBE1675:
  28:sms/sms.h     ****   send_uart(number_string, USART);
 6634               		.loc 13 28 0
 6635 060e C801      		movw r24,r16
 6636 0610 60EA      		ldi r22,lo8(2208)
 6637 0612 78E0      		ldi r23,hi8(2208)
 6638 0614 0E94 0000 		call send_uart
 6639               	.LVL389:
 6640               	.LBB1677:
 6641               	.LBB1678:
 6642               		.loc 11 164 0
 6643 0618 8FEF      		 ldi r24,lo8(639999)
 6644 061a 93EC      	    ldi r25,hi8(639999)
 6645 061c A9E0      	    ldi r26,hlo8(639999)
 6646 061e 8150      	    1:subi r24,1
 6647 0620 9040      	    sbci r25,0
 6648 0622 A040      	    sbci r26,0
 6649 0624 01F4      	    brne 1b
 6650 0626 00C0      		rjmp .
 6651 0628 0000      		nop
 6652               	.LBE1678:
 6653               	.LBE1677:
  32:sms/sms.h     ****   send_uart(text_message, USART);
 6654               		.loc 13 32 0
 6655 062a C201      		movw r24,r4
 6656 062c 60EA      		ldi r22,lo8(2208)
 6657 062e 78E0      		ldi r23,hi8(2208)
 6658 0630 0E94 0000 		call send_uart
 6659               	.LVL390:
 6660               	.LBB1679:
 6661               	.LBB1680:
 6662               		.loc 11 164 0
 6663 0634 8FEF      		 ldi r24,lo8(639999)
 6664 0636 93EC      	    ldi r25,hi8(639999)
 6665 0638 A9E0      	    ldi r26,hlo8(639999)
 6666 063a 8150      	    1:subi r24,1
 6667 063c 9040      	    sbci r25,0
 6668 063e A040      	    sbci r26,0
 6669 0640 01F4      	    brne 1b
 6670 0642 00C0      		rjmp .
 6671 0644 0000      		nop
 6672               	.LVL391:
 6673               	.L237:
 6674               	.LBE1680:
 6675               	.LBE1679:
 6676               	.LBB1681:
 6677               	.LBB1682:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 6678               		.loc 9 18 0
 6679 0646 8091 A108 		lds r24,2209
 6680 064a 85FF      		sbrs r24,5
 6681 064c 00C0      		rjmp .L237
  21:uart/uart.h   ****     USART->DATA = c; 
 6682               		.loc 9 21 0
 6683 064e 9AE1      		ldi r25,lo8(26)
 6684 0650 9093 A008 		sts 2208,r25
 6685               	.LVL392:
 6686               	.LBE1682:
 6687               	.LBE1681:
 6688               	.LBB1683:
 6689               	.LBB1684:
 6690               		.loc 11 164 0
 6691 0654 8FEF      		 ldi r24,lo8(639999)
 6692 0656 93EC      	    ldi r25,hi8(639999)
 6693 0658 A9E0      	    ldi r26,hlo8(639999)
 6694 065a 8150      	    1:subi r24,1
 6695 065c 9040      	    sbci r25,0
 6696 065e A040      	    sbci r26,0
 6697 0660 01F4      	    brne 1b
 6698 0662 00C0      		rjmp .
 6699 0664 0000      		nop
 6700               	.LBE1684:
 6701               	.LBE1683:
 6702               	.LBE1664:
 6703               	.LBE1663:
  66:main.c        ****       	send_message(twilio_number, gps.sms, &USARTC0);
 6704               		.loc 6 66 0
 6705 0666 1091 0000 		lds r17,twilio_number
 6706 066a 0091 0000 		lds r16,twilio_number+1
 6707               	.LVL393:
 6708 066e 4090 0000 		lds r4,gps+14
 6709 0672 5090 0000 		lds r5,gps+14+1
 6710               	.LVL394:
 6711               	.L238:
 6712               	.LBB1685:
 6713               	.LBB1686:
 6714               	.LBB1687:
 6715               	.LBB1688:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 6716               		.loc 9 18 0
 6717 0676 8091 A108 		lds r24,2209
 6718 067a 85FF      		sbrs r24,5
 6719 067c 00C0      		rjmp .L238
  21:uart/uart.h   ****     USART->DATA = c; 
 6720               		.loc 9 21 0
 6721 067e 9DE0      		ldi r25,lo8(13)
 6722 0680 9093 A008 		sts 2208,r25
 6723               	.LBE1688:
 6724               	.LBE1687:
 6725               	.LBB1689:
 6726               	.LBB1690:
 6727               		.loc 11 164 0
 6728 0684 8FEF      		 ldi r24,lo8(639999)
 6729 0686 93EC      	    ldi r25,hi8(639999)
 6730 0688 A9E0      	    ldi r26,hlo8(639999)
 6731 068a 8150      	    1:subi r24,1
 6732 068c 9040      	    sbci r25,0
 6733 068e A040      	    sbci r26,0
 6734 0690 01F4      	    brne 1b
 6735 0692 00C0      		rjmp .
 6736 0694 0000      		nop
 6737               	.LVL395:
 6738               	.LBE1690:
 6739               	.LBE1689:
 6740               	.LBB1691:
 6741               	.LBB1692:
  42:sms/sms.h     ****   send_uart("AT+CMGF=1", USART);
 6742               		.loc 13 42 0
 6743 0696 80E0      		ldi r24,lo8(.LC4)
 6744 0698 90E0      		ldi r25,hi8(.LC4)
 6745 069a 60EA      		ldi r22,lo8(2208)
 6746 069c 78E0      		ldi r23,hi8(2208)
 6747 069e 0E94 0000 		call send_uart
 6748               	.LVL396:
 6749               	.LBE1692:
 6750               	.LBE1691:
 6751               	.LBB1693:
 6752               	.LBB1694:
 6753               		.loc 11 164 0
 6754 06a2 8FEF      		 ldi r24,lo8(639999)
 6755 06a4 93EC      	    ldi r25,hi8(639999)
 6756 06a6 A9E0      	    ldi r26,hlo8(639999)
 6757 06a8 8150      	    1:subi r24,1
 6758 06aa 9040      	    sbci r25,0
 6759 06ac A040      	    sbci r26,0
 6760 06ae 01F4      	    brne 1b
 6761 06b0 00C0      		rjmp .
 6762 06b2 0000      		nop
 6763               	.LVL397:
 6764               	.LBE1694:
 6765               	.LBE1693:
 6766               	.LBB1695:
 6767               	.LBB1696:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 6768               		.loc 7 16 0
 6769 06b4 E12F      		mov r30,r17
 6770 06b6 F02F      		mov r31,r16
 6771 06b8 DF01      		movw r26,r30
 6772 06ba 0D90      		ld __tmp_reg__,X+
 6773 06bc 0020      		tst __tmp_reg__
 6774 06be 01F4      		brne .-6
 6775 06c0 CD01      		movw r24,r26
 6776 06c2 8E1B      		sub r24,r30
 6777 06c4 9F0B      		sbc r25,r31
 6778 06c6 0996      		adiw r24,9
 6779 06c8 0E94 0000 		call malloc
 6780 06cc 782E      		mov r7,r24
 6781               	.LVL398:
 6782 06ce 692E      		mov r6,r25
 6783               	.LVL399:
  18:utils/utils.h ****     strcpy(result, s1);
 6784               		.loc 7 18 0
 6785 06d0 E82F      		mov r30,r24
 6786 06d2 F92F      		mov r31,r25
 6787 06d4 A0E0      		ldi r26,lo8(.LC5)
 6788 06d6 B0E0      		ldi r27,hi8(.LC5)
 6789 06d8 8AE0      		ldi r24,lo8(10)
 6790               	.LVL400:
 6791               	.L239:
 6792 06da 0D90      		ld r0,X+
 6793 06dc 0192      		st Z+,r0
 6794 06de 8150      		subi r24,lo8(-(-1))
 6795 06e0 01F4      		brne .L239
  19:utils/utils.h ****     strcat(result, s2);
 6796               		.loc 7 19 0
 6797 06e2 872D      		mov r24,r7
 6798 06e4 962D      		mov r25,r6
 6799               	.LVL401:
 6800 06e6 612F      		mov r22,r17
 6801 06e8 702F      		mov r23,r16
 6802 06ea 0E94 0000 		call strcat
 6803               	.LVL402:
 6804               	.LBE1696:
 6805               	.LBE1695:
 6806               	.LBB1697:
 6807               	.LBB1698:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 6808               		.loc 7 16 0
 6809 06ee E72D      		mov r30,r7
 6810 06f0 F62D      		mov r31,r6
 6811 06f2 DF01      		movw r26,r30
 6812 06f4 0D90      		ld __tmp_reg__,X+
 6813 06f6 0020      		tst __tmp_reg__
 6814 06f8 01F4      		brne .-6
 6815 06fa CD01      		movw r24,r26
 6816 06fc 8E1B      		sub r24,r30
 6817 06fe 9F0B      		sbc r25,r31
 6818 0700 0196      		adiw r24,1
 6819 0702 0E94 0000 		call malloc
 6820 0706 392E      		mov r3,r25
 6821 0708 082F      		mov r16,r24
 6822               	.LVL403:
 6823 070a 192F      		mov r17,r25
 6824               	.LVL404:
  18:utils/utils.h ****     strcpy(result, s1);
 6825               		.loc 7 18 0
 6826 070c C801      		movw r24,r16
 6827 070e 672D      		mov r22,r7
 6828 0710 762D      		mov r23,r6
 6829 0712 0E94 0000 		call strcpy
  19:utils/utils.h ****     strcat(result, s2);
 6830               		.loc 7 19 0
 6831 0716 A02F      		mov r26,r16
 6832 0718 B32D      		mov r27,r3
 6833 071a FD01      		movw r30,r26
 6834 071c 0190      		ld __tmp_reg__,Z+
 6835 071e 0020      		tst __tmp_reg__
 6836 0720 01F4      		brne .-6
 6837 0722 3197      		sbiw r30,1
 6838 0724 EA1B      		sub r30,r26
 6839 0726 FB0B      		sbc r31,r27
 6840 0728 E00F      		add r30,r16
 6841 072a F11F      		adc r31,r17
 6842 072c 22E2      		ldi r18,lo8(34)
 6843 072e 30E0      		ldi r19,hi8(34)
 6844 0730 2083      		st Z,r18
 6845 0732 3183      		std Z+1,r19
 6846               	.LBE1698:
 6847               	.LBE1697:
  28:sms/sms.h     ****   send_uart(number_string, USART);
 6848               		.loc 13 28 0
 6849 0734 C801      		movw r24,r16
 6850 0736 60EA      		ldi r22,lo8(2208)
 6851 0738 78E0      		ldi r23,hi8(2208)
 6852 073a 0E94 0000 		call send_uart
 6853               	.LBB1699:
 6854               	.LBB1700:
 6855               		.loc 11 164 0
 6856 073e 8FEF      		 ldi r24,lo8(639999)
 6857 0740 93EC      	    ldi r25,hi8(639999)
 6858 0742 A9E0      	    ldi r26,hlo8(639999)
 6859 0744 8150      	    1:subi r24,1
 6860 0746 9040      	    sbci r25,0
 6861 0748 A040      	    sbci r26,0
 6862 074a 01F4      	    brne 1b
 6863 074c 00C0      		rjmp .
 6864 074e 0000      		nop
 6865               	.LBE1700:
 6866               	.LBE1699:
  32:sms/sms.h     ****   send_uart(text_message, USART);
 6867               		.loc 13 32 0
 6868 0750 C201      		movw r24,r4
 6869 0752 60EA      		ldi r22,lo8(2208)
 6870 0754 78E0      		ldi r23,hi8(2208)
 6871 0756 0E94 0000 		call send_uart
 6872               	.LBB1701:
 6873               	.LBB1702:
 6874               		.loc 11 164 0
 6875 075a 8FEF      		 ldi r24,lo8(639999)
 6876 075c 93EC      	    ldi r25,hi8(639999)
 6877 075e A9E0      	    ldi r26,hlo8(639999)
 6878 0760 8150      	    1:subi r24,1
 6879 0762 9040      	    sbci r25,0
 6880 0764 A040      	    sbci r26,0
 6881 0766 01F4      	    brne 1b
 6882 0768 00C0      		rjmp .
 6883 076a 0000      		nop
 6884               	.LVL405:
 6885               	.L240:
 6886               	.LBE1702:
 6887               	.LBE1701:
 6888               	.LBB1703:
 6889               	.LBB1704:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 6890               		.loc 9 18 0
 6891 076c 8091 A108 		lds r24,2209
 6892 0770 85FF      		sbrs r24,5
 6893 0772 00C0      		rjmp .L240
  21:uart/uart.h   ****     USART->DATA = c; 
 6894               		.loc 9 21 0
 6895 0774 9AE1      		ldi r25,lo8(26)
 6896 0776 9093 A008 		sts 2208,r25
 6897               	.LVL406:
 6898               	.LBE1704:
 6899               	.LBE1703:
 6900               	.LBB1705:
 6901               	.LBB1706:
 6902               		.loc 11 164 0
 6903 077a 8FEF      		 ldi r24,lo8(639999)
 6904 077c 93EC      	    ldi r25,hi8(639999)
 6905 077e A9E0      	    ldi r26,hlo8(639999)
 6906 0780 8150      	    1:subi r24,1
 6907 0782 9040      	    sbci r25,0
 6908 0784 A040      	    sbci r26,0
 6909 0786 01F4      	    brne 1b
 6910 0788 00C0      		rjmp .
 6911 078a 0000      		nop
 6912               	.LBE1706:
 6913               	.LBE1705:
 6914               	.LBE1686:
 6915               	.LBE1685:
  67:main.c        ****       	freq = HIGH_FREQ;
 6916               		.loc 6 67 0
 6917 078c 91E0      		ldi r25,lo8(1)
 6918 078e 9093 0000 		sts freq,r25
 6919 0792 00C0      		rjmp .L242
 6920               	.LVL407:
 6921               	.L263:
 6922               	.LBB1707:
 6923               	.LBB1657:
 6924               	.LBB1654:
 6925               	.LBB1652:
 6926               	.LBB1650:
 6927               	.LBB1643:
 6928               	.LBB1641:
  86:nmea/nmea.h   ****       gps->roaming = 0;
 6929               		.loc 8 86 0
 6930 0794 1092 0000 		sts gps+13,__zero_reg__
 6931 0798 00C0      		rjmp .L231
 6932               	.LVL408:
 6933               	.L265:
 6934               	.LBE1641:
 6935               	.LBE1643:
 6936               	.LBE1650:
 6937               	.LBE1652:
 6938               	.LBE1654:
 6939               	.LBE1657:
 6940               	.LBE1707:
 6941               	.LBB1708:
 6942               	.LBB1625:
 6943               	.LBB1622:
 6944               	.LBB1609:
 6945               	.LBB1608:
 6946               	.LBB1607:
 6947               	.LBB1602:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 6948               		.loc 4 57 0
 6949 079a 8091 0000 		lds r24,ep_in_pipe_data+4
 6950 079e 592F      		mov r21,r25
 6951 07a0 581B      		sub r21,r24
 6952               	.LBE1602:
 6953               	.LBE1607:
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 6954               		.loc 2 127 0
 6955 07a2 81E0      		ldi r24,lo8(1)
 6956 07a4 1516      		cp __zero_reg__,r21
 6957 07a6 04F4      		brge .+2
 6958 07a8 00C0      		rjmp .L216
 6959 07aa 00C0      		rjmp .L244
 6960               	.LVL409:
 6961               	.L261:
 6962               	.LBE1608:
 6963               	.LBE1609:
 6964               	.LBE1622:
 6965               	.LBB1623:
 6966               	.LBB1596:
 6967               	.LBB1594:
 6968               	.LBB1592:
 6969               	.LBB1590:
 6970               	.LBB1576:
 6971               	.LBB1577:
 6972               	.LBB1578:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 6973               		.loc 5 228 0
 6974 07ac 2091 0000 		lds r18,endpoints+24
 6975 07b0 2670      		andi r18,lo8(6)
 6976               	.LBE1578:
 6977               	.LBE1577:
 6978               	.LBE1576:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 6979               		.loc 2 91 0
 6980 07b2 2630      		cpi r18,lo8(6)
 6981 07b4 01F0      		breq .+2
 6982 07b6 00C0      		rjmp .L264
 6983               		.loc 4 91 0
 6984 07b8 60E0      		ldi r22,lo8(ep_in_pipe_buffer)
 6985 07ba 70E0      		ldi r23,hi8(ep_in_pipe_buffer)
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 6986               		.loc 2 93 0
 6987 07bc 40E0      		ldi r20,lo8(0)
 6988 07be 50E0      		ldi r21,hi8(0)
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 6989               		.loc 2 92 0
 6990 07c0 A0E0      		ldi r26,lo8(0)
 6991               		.loc 4 91 0
 6992 07c2 9B01      		movw r18,r22
 6993 07c4 CB01      		movw r24,r22
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 6994               		.loc 4 90 0
 6995 07c6 B0E0      		ldi r27,lo8(0)
 6996 07c8 E0E0      		ldi r30,lo8(endpoints+24)
 6997 07ca F0E0      		ldi r31,hi8(endpoints+24)
 6998 07cc 00C0      		rjmp .L210
 6999               	.LVL410:
 7000               	.L268:
 7001               	.LBB1579:
 7002               	.LBB1580:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 7003               		.loc 2 69 0
 7004 07ce 21E0      		ldi r18,lo8(1)
 7005 07d0 0130      		cpi r16,lo8(1)
 7006 07d2 01F4      		brne .L212
 7007 07d4 20E0      		ldi r18,lo8(0)
 7008               	.L212:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 7009               		.loc 2 72 0
 7010 07d6 0023      		tst r16
 7011 07d8 01F4      		brne .L213
 7012               	.LVL411:
 7013               	.LBB1581:
 7014               	.LBB1582:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 7015               		.loc 5 168 0
 7016 07da 8093 0000 		sts endpoints+28,r24
 7017 07de 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 7018               		.loc 5 169 0
 7019 07e2 4093 0000 		sts endpoints+26,r20
 7020 07e6 5093 0000 		sts endpoints+26+1,r21
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 7021               		.loc 5 174 0
 7022 07ea E0E0      		ldi r30,lo8(endpoints+24)
 7023 07ec F0E0      		ldi r31,hi8(endpoints+24)
 7024               	.LVL412:
 7025               	/* #APP */
 7026               	 ;  174 "usb/usb.h" 1
 7027 07ee 02E2      		ldi r16, 34
 7028 07f0 0693      		.dc.w 0x9306
 7029               		
 7030               	 ;  0 "" 2
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 7031               		.loc 2 69 0
 7032               	/* #NOAPP */
 7033 07f2 022F      		mov r16,r18
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 7034               		.loc 2 88 0
 7035 07f4 A2E0      		ldi r26,lo8(2)
 7036 07f6 20E0      		ldi r18,lo8(ep_in_pipe_buffer)
 7037 07f8 30E0      		ldi r19,hi8(ep_in_pipe_buffer)
 7038 07fa 00C0      		rjmp .L210
 7039               	.LVL413:
 7040               	.L267:
 7041               	.LBE1582:
 7042               	.LBE1581:
 7043               	.LBE1580:
 7044               	.LBE1579:
 7045               	.LBB1586:
 7046               	.LBB1575:
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
 7047               		.loc 4 76 0
 7048 07fc 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 7049 07fe 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 7050 0800 9C01      		movw r18,r24
 7051 0802 00C0      		rjmp .L210
 7052               	.LVL414:
 7053               	.L208:
 7054               	.LBE1575:
 7055               	.LBE1586:
 7056               	.LBB1587:
 7057               	.LBB1572:
 7058               	.LBB1570:
 7059               	.LBB1571:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 7060               		.loc 5 168 0
 7061 0804 8093 0000 		sts endpoints+20,r24
 7062 0808 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 7063               		.loc 5 169 0
 7064 080c 20E4      		ldi r18,lo8(64)
 7065 080e 30E0      		ldi r19,hi8(64)
 7066 0810 2093 0000 		sts endpoints+18,r18
 7067 0814 3093 0000 		sts endpoints+18+1,r19
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 7068               		.loc 5 176 0
 7069 0818 E0E0      		ldi r30,lo8(endpoints+24)
 7070 081a F0E0      		ldi r31,hi8(endpoints+24)
 7071               	/* #APP */
 7072               	 ;  176 "usb/usb.h" 1
 7073 081c 04E1      		ldi r16, 20
 7074 081e 0693      		.dc.w 0x9306
 7075               		
 7076               	 ;  0 "" 2
 7077               	/* #NOAPP */
 7078 0820 00C0      		rjmp .L209
 7079               	.LVL415:
 7080               	.L213:
 7081               	.LBE1571:
 7082               	.LBE1570:
 7083               	.LBE1572:
 7084               	.LBE1587:
 7085               	.LBB1588:
 7086               	.LBB1585:
 7087               	.LBB1583:
 7088               	.LBB1584:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 7089               		.loc 5 168 0
 7090 0822 8093 0000 		sts endpoints+20,r24
 7091 0826 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 7092               		.loc 5 169 0
 7093 082a 4093 0000 		sts endpoints+18,r20
 7094 082e 5093 0000 		sts endpoints+18+1,r21
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 7095               		.loc 5 176 0
 7096 0832 E0E0      		ldi r30,lo8(endpoints+24)
 7097 0834 F0E0      		ldi r31,hi8(endpoints+24)
 7098               	/* #APP */
 7099               	 ;  176 "usb/usb.h" 1
 7100 0836 04E1      		ldi r16, 20
 7101 0838 0693      		.dc.w 0x9306
 7102               		
 7103               	 ;  0 "" 2
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 7104               		.loc 2 69 0
 7105               	/* #NOAPP */
 7106 083a 022F      		mov r16,r18
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 7107               		.loc 2 88 0
 7108 083c A2E0      		ldi r26,lo8(2)
 7109 083e 20E0      		ldi r18,lo8(ep_in_pipe_buffer)
 7110 0840 30E0      		ldi r19,hi8(ep_in_pipe_buffer)
 7111 0842 00C0      		rjmp .L210
 7112               	.LBE1584:
 7113               	.LBE1583:
 7114               	.LBE1585:
 7115               	.LBE1588:
 7116               	.LBE1590:
 7117               	.LBE1592:
 7118               	.LBE1594:
 7119               	.LBE1596:
 7120               	.LBE1623:
 7121               	.LBE1625:
 7122               	.LBE1708:
 7123               		.cfi_endproc
 7124               	.LFE80:
 7126               		.text
 7127               	.global	EVENT_USB_Device_ControlRequest
 7129               	EVENT_USB_Device_ControlRequest:
 7130               	.LFB81:
  97:main.c        **** bool EVENT_USB_Device_ControlRequest(USB_Request_Header_t* req){
 7131               		.loc 6 97 0
 7132               		.cfi_startproc
 7133               	.LVL416:
 7134 16fa 0F93      		push r16
 7135               	.LCFI142:
 7136               		.cfi_def_cfa_offset 3
 7137               		.cfi_offset 16, -2
 7138 16fc 1F93      		push r17
 7139               	.LCFI143:
 7140               		.cfi_def_cfa_offset 4
 7141               		.cfi_offset 17, -3
 7142 16fe CF93      		push r28
 7143               	.LCFI144:
 7144               		.cfi_def_cfa_offset 5
 7145               		.cfi_offset 28, -4
 7146 1700 DF93      		push r29
 7147               	.LCFI145:
 7148               		.cfi_def_cfa_offset 6
 7149               		.cfi_offset 29, -5
 7150               	/* prologue: function */
 7151               	/* frame size = 0 */
 7152               	/* stack size = 4 */
 7153               	.L__stack_usage = 4
 7154 1702 9C01      		movw r18,r24
 7155               	.LVL417:
 157:main.c        **** 	return false;
 7156               		.loc 6 157 0
 7157 1704 A0E0      		ldi r26,lo8(ep0_buf_in)
 7158 1706 B0E0      		ldi r27,hi8(ep0_buf_in)
  97:main.c        **** bool EVENT_USB_Device_ControlRequest(USB_Request_Header_t* req){
 7159               		.loc 6 97 0
 7160 1708 8D01      		movw r16,r26
 7161 170a 80E0      		ldi r24,lo8(ep0_buf_in+64)
 7162 170c 90E0      		ldi r25,hi8(ep0_buf_in+64)
 7163               	.LVL418:
 7164 170e FD01      		movw r30,r26
 7165               	.LVL419:
 7166               	.L272:
 7167               	.LBB1709:
  99:main.c        **** 	for (uint8_t i = 0; i < 64; i++) ep0_buf_in[i] = 0;
 7168               		.loc 6 99 0 discriminator 2
 7169 1710 1192      		st Z+,__zero_reg__
 7170 1712 40E0      		ldi r20,hi8(ep0_buf_in+64)
 7171 1714 E030      		cpi r30,lo8(ep0_buf_in+64)
 7172 1716 F407      		cpc r31,r20
 7173 1718 01F4      		brne .L272
 7174               	.LBE1709:
 100:main.c        **** 	usb_cmd = 0;
 7175               		.loc 6 100 0
 7176 171a 1092 0000 		sts usb_cmd,__zero_reg__
 101:main.c        **** 	if ((req->bmRequestType & CONTROL_REQTYPE_TYPE) == REQTYPE_VENDOR){
 7177               		.loc 6 101 0
 7178 171e F901      		movw r30,r18
 7179 1720 C081      		ld r28,Z
 7180 1722 D0E0      		ldi r29,lo8(0)
 7181 1724 C076      		andi r28,lo8(96)
 7182 1726 D070      		andi r29,hi8(96)
 7183 1728 C034      		cpi r28,64
 7184 172a D105      		cpc r29,__zero_reg__
 7185 172c 01F0      		breq .L296
 7186               	.L290:
 157:main.c        **** 	return false;
 7187               		.loc 6 157 0
 7188 172e 80E0      		ldi r24,lo8(0)
 7189               	.LVL420:
 7190               	.L273:
 7191               	/* epilogue start */
 158:main.c        **** }
 7192               		.loc 6 158 0
 7193 1730 DF91      		pop r29
 7194 1732 CF91      		pop r28
 7195 1734 1F91      		pop r17
 7196 1736 0F91      		pop r16
 7197 1738 0895      		ret
 7198               	.LVL421:
 7199               	.L296:
 102:main.c        **** 		switch(req->bRequest){
 7200               		.loc 6 102 0
 7201 173a 4181      		ldd r20,Z+1
 7202 173c 4631      		cpi r20,lo8(22)
 7203 173e 01F4      		brne .+2
 7204 1740 00C0      		rjmp .L278
 7205 1742 4731      		cpi r20,lo8(23)
 7206 1744 00F0      		brlo .L297
 7207 1746 4B3B      		cpi r20,lo8(-69)
 7208 1748 01F4      		brne .+2
 7209 174a 00C0      		rjmp .L280
 7210 174c 4C3B      		cpi r20,lo8(-68)
 7211 174e 00F0      		brlo .+2
 7212 1750 00C0      		rjmp .L285
 7213 1752 4731      		cpi r20,lo8(23)
 7214 1754 01F4      		brne .L290
 7215               	.LBB1710:
 133:main.c        **** 				addr = (uint16_t *) req->wIndex;
 7216               		.loc 6 133 0
 7217 1756 0480      		ldd __tmp_reg__,Z+4
 7218 1758 F581      		ldd r31,Z+5
 7219 175a E02D      		mov r30,__tmp_reg__
 7220               	.LVL422:
 134:main.c        **** 				ep0_buf_in[0] = *addr & 0xFF;
 7221               		.loc 6 134 0
 7222 175c 8081      		ld r24,Z
 7223 175e 8093 0000 		sts ep0_buf_in,r24
 135:main.c        **** 				ep0_buf_in[1] = *addr >> 8;
 7224               		.loc 6 135 0
 7225 1762 8181      		ldd r24,Z+1
 7226 1764 8093 0000 		sts ep0_buf_in+1,r24
 7227               	.LVL423:
 7228               	.LBB1711:
 7229               	.LBB1712:
 7230               	.LBB1713:
 7231               	.LBB1714:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 7232               		.loc 5 168 0
 7233 1768 0093 0000 		sts endpoints+12,r16
 7234 176c 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 7235               		.loc 5 169 0
 7236 1770 82E0      		ldi r24,lo8(2)
 7237 1772 90E0      		ldi r25,hi8(2)
 7238 1774 8093 0000 		sts endpoints+10,r24
 7239 1778 9093 0000 		sts endpoints+10+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 7240               		.loc 5 174 0
 7241 177c E0E0      		ldi r30,lo8(endpoints+8)
 7242 177e F0E0      		ldi r31,hi8(endpoints+8)
 7243               	/* #APP */
 7244               	 ;  174 "usb/usb.h" 1
 7245 1780 02E2      		ldi r16, 34
 7246 1782 0693      		.dc.w 0x9306
 7247               		
 7248               	 ;  0 "" 2
 7249               	/* #NOAPP */
 7250               	.LBE1714:
 7251               	.LBE1713:
 7252               	.LBE1712:
 7253               	.LBE1711:
 7254               	.LBE1710:
 137:main.c        **** 				return true;
 7255               		.loc 6 137 0
 7256 1784 81E0      		ldi r24,lo8(1)
 7257 1786 00C0      		rjmp .L273
 7258               	.LVL424:
 7259               	.L297:
 102:main.c        **** 		switch(req->bRequest){
 7260               		.loc 6 102 0
 7261 1788 4230      		cpi r20,lo8(2)
 7262 178a 01F4      		brne .+2
 7263 178c 00C0      		rjmp .L275
 7264 178e 4330      		cpi r20,lo8(3)
 7265 1790 00F4      		brsh .L284
 7266 1792 4423      		tst r20
 7267 1794 01F4      		brne .L290
 104:main.c        **** 				if (req->wIndex == 0){
 7268               		.loc 6 104 0
 7269 1796 8481      		ldd r24,Z+4
 7270 1798 9581      		ldd r25,Z+5
 7271 179a 0097      		sbiw r24,0
 7272 179c 01F4      		brne .+2
 7273 179e 00C0      		rjmp .L298
 106:main.c        **** 				}else if (req->wIndex == 1){
 7274               		.loc 6 106 0
 7275 17a0 8130      		cpi r24,1
 7276 17a2 9105      		cpc r25,__zero_reg__
 7277 17a4 01F4      		brne .+2
 7278 17a6 00C0      		rjmp .L299
 109:main.c        **** 				return true;
 7279               		.loc 6 109 0
 7280 17a8 81E0      		ldi r24,lo8(1)
 7281 17aa 00C0      		rjmp .L273
 7282               	.L284:
 102:main.c        **** 		switch(req->bRequest){
 7283               		.loc 6 102 0
 7284 17ac 4830      		cpi r20,lo8(8)
 7285 17ae 01F0      		breq .L276
 7286 17b0 4930      		cpi r20,lo8(9)
 7287 17b2 01F0      		breq .+2
 7288 17b4 00C0      		rjmp .L290
 124:main.c        **** 				ep0_buf_in[0] = * ((uint8_t *) req->wIndex);
 7289               		.loc 6 124 0
 7290 17b6 0480      		ldd __tmp_reg__,Z+4
 7291 17b8 F581      		ldd r31,Z+5
 7292 17ba E02D      		mov r30,__tmp_reg__
 7293 17bc 8081      		ld r24,Z
 7294 17be 8093 0000 		sts ep0_buf_in,r24
 7295               	.LVL425:
 7296               	.LBB1715:
 7297               	.LBB1716:
 7298               	.LBB1717:
 7299               	.LBB1718:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 7300               		.loc 5 168 0
 7301 17c2 0093 0000 		sts endpoints+12,r16
 7302 17c6 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 7303               		.loc 5 169 0
 7304 17ca 81E0      		ldi r24,lo8(1)
 7305 17cc 90E0      		ldi r25,hi8(1)
 7306 17ce 8093 0000 		sts endpoints+10,r24
 7307 17d2 9093 0000 		sts endpoints+10+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 7308               		.loc 5 174 0
 7309 17d6 E0E0      		ldi r30,lo8(endpoints+8)
 7310 17d8 F0E0      		ldi r31,hi8(endpoints+8)
 7311               	.LVL426:
 7312               	/* #APP */
 7313               	 ;  174 "usb/usb.h" 1
 7314 17da 02E2      		ldi r16, 34
 7315 17dc 0693      		.dc.w 0x9306
 7316               		
 7317               	 ;  0 "" 2
 7318               	/* #NOAPP */
 7319               	.LBE1718:
 7320               	.LBE1717:
 7321               	.LBE1716:
 7322               	.LBE1715:
 126:main.c        **** 				return true;
 7323               		.loc 6 126 0
 7324 17de 81E0      		ldi r24,lo8(1)
 7325 17e0 00C0      		rjmp .L273
 7326               	.LVL427:
 7327               	.L285:
 102:main.c        **** 		switch(req->bRequest){
 7328               		.loc 6 102 0
 7329 17e2 403E      		cpi r20,lo8(-32)
 7330 17e4 01F0      		breq .L281
 7331 17e6 413E      		cpi r20,lo8(-31)
 7332 17e8 01F0      		breq .+2
 7333 17ea 00C0      		rjmp .L290
 146:main.c        **** 				usb_cmd = req->bRequest;
 7334               		.loc 6 146 0
 7335 17ec 4093 0000 		sts usb_cmd,r20
 147:main.c        **** 				cmd_data = req->wIndex;
 7336               		.loc 6 147 0
 7337 17f0 8481      		ldd r24,Z+4
 7338 17f2 8093 0000 		sts cmd_data,r24
 7339               	.LVL428:
 7340               	.L295:
 7341               	.LBB1719:
 7342               	.LBB1720:
 7343               	.LBB1721:
 7344               	.LBB1722:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 7345               		.loc 5 168 0
 7346 17f6 0093 0000 		sts endpoints+12,r16
 7347 17fa 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 7348               		.loc 5 169 0
 7349 17fe 1092 0000 		sts endpoints+10,__zero_reg__
 7350 1802 1092 0000 		sts endpoints+10+1,__zero_reg__
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 7351               		.loc 5 174 0
 7352 1806 E0E0      		ldi r30,lo8(endpoints+8)
 7353 1808 F0E0      		ldi r31,hi8(endpoints+8)
 7354               	.LVL429:
 7355               	/* #APP */
 7356               	 ;  174 "usb/usb.h" 1
 7357 180a 02E2      		ldi r16, 34
 7358 180c 0693      		.dc.w 0x9306
 7359               		
 7360               	 ;  0 "" 2
 7361               	/* #NOAPP */
 7362               	.LBE1722:
 7363               	.LBE1721:
 7364               	.LBE1720:
 7365               	.LBE1719:
 130:main.c        **** 				return true;
 7366               		.loc 6 130 0
 7367 180e 81E0      		ldi r24,lo8(1)
 7368               	/* epilogue start */
 158:main.c        **** }
 7369               		.loc 6 158 0
 7370 1810 DF91      		pop r29
 7371 1812 CF91      		pop r28
 7372 1814 1F91      		pop r17
 7373 1816 0F91      		pop r16
 7374 1818 0895      		ret
 7375               	.LVL430:
 7376               	.L276:
 120:main.c        **** 				* ((uint8_t *) req->wIndex) = req->wValue;
 7377               		.loc 6 120 0
 7378 181a D901      		movw r26,r18
 7379 181c 0480      		ldd __tmp_reg__,Z+4
 7380 181e F581      		ldd r31,Z+5
 7381 1820 E02D      		mov r30,__tmp_reg__
 7382 1822 1296      		adiw r26,2
 7383 1824 8C91      		ld r24,X
 7384 1826 1297      		sbiw r26,2
 7385 1828 8083      		st Z,r24
 7386               	.LVL431:
 7387 182a 00C0      		rjmp .L295
 7388               	.LVL432:
 7389               	.L281:
 140:main.c        **** 				eeprom_read_block(ep0_buf_in, (void*)(req->wIndex*64), 64);
 7390               		.loc 6 140 0
 7391 182c F901      		movw r30,r18
 7392 182e 6481      		ldd r22,Z+4
 7393 1830 7581      		ldd r23,Z+5
 7394 1832 0024      		clr __tmp_reg__
 7395 1834 7695      		lsr r23
 7396 1836 6795      		ror r22
 7397 1838 0794      		ror __tmp_reg__
 7398 183a 7695      		lsr r23
 7399 183c 6795      		ror r22
 7400 183e 0794      		ror __tmp_reg__
 7401 1840 762F      		mov r23,r22
 7402 1842 602D      		mov r22,__tmp_reg__
 7403 1844 80E0      		ldi r24,lo8(ep0_buf_in)
 7404 1846 90E0      		ldi r25,hi8(ep0_buf_in)
 7405 1848 40E4      		ldi r20,lo8(64)
 7406 184a 50E0      		ldi r21,hi8(64)
 7407 184c 0E94 0000 		call __eerd_block_x32a4u
 7408               	.LVL433:
 7409               	.LBB1723:
 7410               	.LBB1724:
 7411               	.LBB1725:
 7412               	.LBB1726:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 7413               		.loc 5 168 0
 7414 1850 0093 0000 		sts endpoints+12,r16
 7415 1854 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 7416               		.loc 5 169 0
 7417 1858 C093 0000 		sts endpoints+10,r28
 7418 185c D093 0000 		sts endpoints+10+1,r29
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 7419               		.loc 5 174 0
 7420 1860 E0E0      		ldi r30,lo8(endpoints+8)
 7421 1862 F0E0      		ldi r31,hi8(endpoints+8)
 7422               	.LVL434:
 7423               	/* #APP */
 7424               	 ;  174 "usb/usb.h" 1
 7425 1864 02E2      		ldi r16, 34
 7426 1866 0693      		.dc.w 0x9306
 7427               		
 7428               	 ;  0 "" 2
 7429               	/* #NOAPP */
 7430               	.LBE1726:
 7431               	.LBE1725:
 7432               	.LBE1724:
 7433               	.LBE1723:
 142:main.c        **** 				return true;
 7434               		.loc 6 142 0
 7435 1868 81E0      		ldi r24,lo8(1)
 7436 186a 00C0      		rjmp .L273
 7437               	.LVL435:
 7438               	.L280:
 7439               	.LBB1727:
 7440               	.LBB1728:
 330:usb/usb.h     **** 		USB_ep0_enableOut();
 331:usb/usb.h     **** 	}
 332:usb/usb.h     **** }
 333:usb/usb.h     **** 
 334:usb/usb.h     **** static inline void USB_enter_bootloader(void){
 335:usb/usb.h     **** 	cli();
 7441               		.loc 5 335 0
 7442               	/* #APP */
 7443               	 ;  335 "usb/usb.h" 1
 7444 186c F894      		cli
 7445               	 ;  0 "" 2
 7446               	.LVL436:
 7447               	/* #NOAPP */
 7448               	.LBB1729:
 7449               	.LBB1730:
 7450               	.LBB1731:
 7451               	.LBB1732:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 7452               		.loc 5 168 0
 7453 186e 0093 0000 		sts endpoints+12,r16
 7454 1872 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 7455               		.loc 5 169 0
 7456 1876 1092 0000 		sts endpoints+10,__zero_reg__
 7457 187a 1092 0000 		sts endpoints+10+1,__zero_reg__
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 7458               		.loc 5 174 0
 7459 187e E0E0      		ldi r30,lo8(endpoints+8)
 7460 1880 F0E0      		ldi r31,hi8(endpoints+8)
 7461               	.LVL437:
 7462               	/* #APP */
 7463               	 ;  174 "usb/usb.h" 1
 7464 1882 02E2      		ldi r16, 34
 7465 1884 0693      		.dc.w 0x9306
 7466               		
 7467               	 ;  0 "" 2
 7468               	/* #NOAPP */
 7469               	.LBE1732:
 7470               	.LBE1731:
 7471               	.LBE1730:
 7472               	.LBE1729:
 7473               	.LBB1733:
 7474               	.LBB1734:
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 7475               		.loc 5 280 0
 7476 1886 3897      		sbiw r30,8
 7477               	.LVL438:
 7478               	/* #APP */
 7479               	 ;  280 "usb/usb.h" 1
 7480 1888 02E7      		ldi r16, 114
 7481 188a 0693      		.dc.w 0x9306
 7482               		
 7483               	 ;  0 "" 2
 7484               	.LVL439:
 7485               	/* #NOAPP */
 7486               	.L288:
 7487               	.LBE1734:
 7488               	.LBE1733:
 7489               	.LBB1735:
 7490               	.LBB1736:
 7491               	.LBB1737:
 7492               	.LBB1738:
 202:usb/usb.h     **** 		return e->STATUS & USB_EP_TRNCOMPL0_bm;
 7493               		.loc 5 202 0
 7494 188c 8091 0000 		lds r24,endpoints
 7495               	.LBE1738:
 7496               	.LBE1737:
 253:usb/usb.h     **** 	while (!USB_ep_done(ep)){};
 7497               		.loc 5 253 0
 7498 1890 85FF      		sbrs r24,5
 7499 1892 00C0      		rjmp .L288
 7500               	.LVL440:
 7501               	.LBE1736:
 7502               	.LBE1735:
 7503               	.LBB1739:
 7504               	.LBB1740:
 7505               		.loc 11 164 0
 7506 1894 8FEF      		 ldi r24,lo8(63999)
 7507 1896 99EF      	    ldi r25,hi8(63999)
 7508 1898 A0E0      	    ldi r26,hlo8(63999)
 7509 189a 8150      	    1:subi r24,1
 7510 189c 9040      	    sbci r25,0
 7511 189e A040      	    sbci r26,0
 7512 18a0 01F4      	    brne 1b
 7513 18a2 00C0      		rjmp .
 7514 18a4 0000      		nop
 7515               	.LBE1740:
 7516               	.LBE1739:
 7517               	.LBB1741:
 7518               	.LBB1742:
 296:usb/usb.h     **** 	USB.CTRLB &= ~USB_ATTACH_bm;
 7519               		.loc 5 296 0
 7520 18a6 8091 C104 		lds r24,1217
 7521 18aa 8E7F      		andi r24,lo8(-2)
 7522 18ac E0EC      		ldi r30,lo8(1216)
 7523 18ae F4E0      		ldi r31,hi8(1216)
 7524               	.LVL441:
 7525 18b0 8183      		std Z+1,r24
 7526               	.LVL442:
 7527               	.LBE1742:
 7528               	.LBE1741:
 7529               	.LBB1743:
 7530               	.LBB1744:
 7531               		.loc 11 164 0
 7532 18b2 8FEF      		 ldi r24,lo8(639999)
 7533 18b4 93EC      	    ldi r25,hi8(639999)
 7534 18b6 A9E0      	    ldi r26,hlo8(639999)
 7535 18b8 8150      	    1:subi r24,1
 7536 18ba 9040      	    sbci r25,0
 7537 18bc A040      	    sbci r26,0
 7538 18be 01F4      	    brne 1b
 7539 18c0 00C0      		rjmp .
 7540 18c2 0000      		nop
 7541               	.LVL443:
 7542               	.LBE1744:
 7543               	.LBE1743:
 336:usb/usb.h     **** 	USB_ep0_send(0);
 337:usb/usb.h     **** 	USB_ep0_enableOut();
 338:usb/usb.h     **** 	USB_ep_wait(0x00); // Wait for the status stage to complete
 339:usb/usb.h     **** 	_delay_ms(10);
 340:usb/usb.h     **** 	USB_Detach();
 341:usb/usb.h     **** 	_delay_ms(100);
 342:usb/usb.h     **** 	void (*enter_bootloader)(void) = (void*) 0x47fc /*0x8ff8/2*/;
 343:usb/usb.h     **** 	enter_bootloader();
 7544               		.loc 5 343 0
 7545 18c4 ECEF      		ldi r30,lo8(18428)
 7546 18c6 F7E4      		ldi r31,hi8(18428)
 7547 18c8 0995      		icall
 7548               	.LVL444:
 7549               	.LBE1728:
 7550               	.LBE1727:
 154:main.c        **** 				return true;
 7551               		.loc 6 154 0
 7552 18ca 81E0      		ldi r24,lo8(1)
 7553 18cc 00C0      		rjmp .L273
 7554               	.LVL445:
 7555               	.L275:
 7556               	.LBB1745:
 112:main.c        **** 					int l = strlen(message);
 7557               		.loc 6 112 0
 7558 18ce 3091 0000 		lds r19,message
 7559 18d2 2091 0000 		lds r18,message+1
 7560               	.LVL446:
 7561 18d6 C32F      		mov r28,r19
 7562 18d8 D22F      		mov r29,r18
 7563 18da FE01      		movw r30,r28
 7564               	.LVL447:
 7565 18dc 0190      		ld __tmp_reg__,Z+
 7566 18de 0020      		tst __tmp_reg__
 7567 18e0 01F4      		brne .-6
 7568 18e2 3197      		sbiw r30,1
 7569 18e4 E31B      		sub r30,r19
 7570               	.LVL448:
 7571               	.L287:
 7572               	.LBB1746:
 114:main.c        **** 						ep0_buf_in[i] = message[i];
 7573               		.loc 6 114 0 discriminator 2
 7574 18e6 2991      		ld r18,Y+
 7575 18e8 2D93      		st X+,r18
 113:main.c        **** 					for (uint8_t i=0; i<64; i++) {
 7576               		.loc 6 113 0 discriminator 2
 7577 18ea 8A17      		cp r24,r26
 7578 18ec 9B07      		cpc r25,r27
 7579 18ee 01F4      		brne .L287
 7580               	.LVL449:
 7581               	.LBE1746:
 7582               	.LBB1747:
 7583               	.LBB1748:
 247:usb/usb.h     **** 	USB_ep_in_start(0x80, ep0_buf_in, size);
 7584               		.loc 5 247 0
 7585 18f0 8E2F      		mov r24,r30
 7586 18f2 90E0      		ldi r25,lo8(0)
 7587               	.LVL450:
 7588               	.LBB1749:
 7589               	.LBB1750:
 7590               	.LBB1751:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 7591               		.loc 5 168 0
 7592 18f4 0093 0000 		sts endpoints+12,r16
 7593 18f8 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 7594               		.loc 5 169 0
 7595 18fc 8093 0000 		sts endpoints+10,r24
 7596 1900 9093 0000 		sts endpoints+10+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 7597               		.loc 5 174 0
 7598 1904 E0E0      		ldi r30,lo8(endpoints+8)
 7599 1906 F0E0      		ldi r31,hi8(endpoints+8)
 7600               	.LVL451:
 7601               	/* #APP */
 7602               	 ;  174 "usb/usb.h" 1
 7603 1908 02E2      		ldi r16, 34
 7604 190a 0693      		.dc.w 0x9306
 7605               		
 7606               	 ;  0 "" 2
 7607               	/* #NOAPP */
 7608               	.LBE1751:
 7609               	.LBE1750:
 7610               	.LBE1749:
 7611               	.LBE1748:
 7612               	.LBE1747:
 117:main.c        **** 					return true;
 7613               		.loc 6 117 0
 7614 190c 81E0      		ldi r24,lo8(1)
 7615               	.LVL452:
 7616 190e 00C0      		rjmp .L273
 7617               	.LVL453:
 7618               	.L278:
 7619               	.LBE1745:
 128:main.c        **** 				* ((uint16_t *) req->wIndex) = req->wValue;
 7620               		.loc 6 128 0
 7621 1910 F901      		movw r30,r18
 7622 1912 8281      		ldd r24,Z+2
 7623 1914 9381      		ldd r25,Z+3
 7624 1916 0480      		ldd __tmp_reg__,Z+4
 7625 1918 F581      		ldd r31,Z+5
 7626 191a E02D      		mov r30,__tmp_reg__
 7627 191c 8083      		st Z,r24
 7628 191e 9183      		std Z+1,r25
 7629 1920 00C0      		rjmp .L295
 7630               	.L299:
 107:main.c        **** 					USB_ep0_send_progmem((uint8_t*)fwversion, sizeof(fwversion));
 7631               		.loc 6 107 0
 7632 1922 80E0      		ldi r24,lo8(fwversion)
 7633 1924 90E0      		ldi r25,hi8(fwversion)
 7634 1926 6BE0      		ldi r22,lo8(11)
 7635 1928 70E0      		ldi r23,hi8(11)
 7636 192a 0E94 0000 		call USB_ep0_send_progmem
 7637               	.LVL454:
 109:main.c        **** 				return true;
 7638               		.loc 6 109 0
 7639 192e 81E0      		ldi r24,lo8(1)
 7640 1930 00C0      		rjmp .L273
 7641               	.LVL455:
 7642               	.L298:
 105:main.c        **** 					USB_ep0_send_progmem((uint8_t*)hwversion, sizeof(hwversion));
 7643               		.loc 6 105 0
 7644 1932 80E0      		ldi r24,lo8(hwversion)
 7645 1934 90E0      		ldi r25,hi8(hwversion)
 7646 1936 6BE0      		ldi r22,lo8(11)
 7647 1938 70E0      		ldi r23,hi8(11)
 7648 193a 0E94 0000 		call USB_ep0_send_progmem
 7649               	.LVL456:
 109:main.c        **** 				return true;
 7650               		.loc 6 109 0
 7651 193e 81E0      		ldi r24,lo8(1)
 7652 1940 00C0      		rjmp .L273
 7653               		.cfi_endproc
 7654               	.LFE81:
 7656               	.global	EVENT_USB_Device_ControlOUT
 7658               	EVENT_USB_Device_ControlOUT:
 7659               	.LFB82:
 160:main.c        **** void EVENT_USB_Device_ControlOUT(uint8_t* buf, uint8_t count){
 7660               		.loc 6 160 0
 7661               		.cfi_startproc
 7662               	.LVL457:
 7663               	/* prologue: function */
 7664               	/* frame size = 0 */
 7665               	/* stack size = 0 */
 7666               	.L__stack_usage = 0
 7667 1942 462F      		mov r20,r22
 161:main.c        **** 	switch (usb_cmd){
 7668               		.loc 6 161 0
 7669 1944 2091 0000 		lds r18,usb_cmd
 7670 1948 213E      		cpi r18,lo8(-31)
 7671 194a 01F0      		breq .L303
 7672               	.LVL458:
 7673 194c 0895      		ret
 7674               	.L303:
 7675               		.loc 6 163 0
 7676 194e 2091 0000 		lds r18,cmd_data
 7677 1952 30E0      		ldi r19,lo8(0)
 7678 1954 0024      		clr __tmp_reg__
 7679 1956 3695      		lsr r19
 7680 1958 2795      		ror r18
 7681 195a 0794      		ror __tmp_reg__
 7682 195c 3695      		lsr r19
 7683 195e 2795      		ror r18
 7684 1960 0794      		ror __tmp_reg__
 7685 1962 322F      		mov r19,r18
 7686 1964 202D      		mov r18,__tmp_reg__
 7687 1966 B901      		movw r22,r18
 7688 1968 50E0      		ldi r21,lo8(0)
 7689 196a 0E94 0000 		call __eeupd_block_x32a4u
 7690               	.LVL459:
 7691 196e 0895      		ret
 7692               		.cfi_endproc
 7693               	.LFE82:
 7695               	.global	cmd_data
 7696               	.global	cmd_data
 7697               		.section .bss
 7700               	cmd_data:
 7701 0000 00        		.skip 1,0
 7702               	.global	usb_cmd
 7703               	.global	usb_cmd
 7706               	usb_cmd:
 7707 0001 00        		.skip 1,0
 7708               	.global	fwversion
 7709               		.section	.progmem.data,"a",@progbits
 7712               	fwversion:
 7713 0000 4657 5F56 		.string	"FW_VERSION"
 7713      4552 5349 
 7713      4F4E 00
 7714               	.global	hwversion
 7717               	hwversion:
 7718 000b 4857 5F56 		.string	"HW_VERSION"
 7718      4552 5349 
 7718      4F4E 00
 7719               		.comm gps,16,1
 7720               		.comm count,1,1
 7721               	.global	updating
 7722               	.global	updating
 7723               		.section .bss
 7726               	updating:
 7727 0002 00        		.skip 1,0
 7728               		.comm message,2,1
 7729               	.global	twilio_number
 7730               		.data
 7731               	.LC15:
 7732 007a 2B31 3330 		.string	"+13042493059"
 7732      3432 3439 
 7732      3330 3539 
 7732      00
 7735               	twilio_number:
 7736 0087 0000      		.word	.LC15
 7737               	.global	phonenumber
 7738               	.LC16:
 7739 0089 2B31 3835 		.string	"+18572080246"
 7739      3732 3038 
 7739      3032 3436 
 7739      00
 7742               	phonenumber:
 7743 0096 0000      		.word	.LC16
 7744               	.global	freq
 7745               	.global	freq
 7746               		.section .bss
 7749               	freq:
 7750 0003 00        		.skip 1,0
 7751               	.global	high_freq
 7752               		.data
 7755               	high_freq:
 7756 0098 3075      		.word	30000
 7757               	.global	low_freq
 7760               	low_freq:
 7761 009a 3075      		.word	30000
 7762               	.global	debug
 7763               	.global	debug
 7764               		.section .bss
 7767               	debug:
 7768 0004 00        		.skip 1,0
 7769               	.global	max_dist
 7770               		.data
 7773               	max_dist:
 7774 009c CD        		.byte	-51
 7775 009d CC        		.byte	-52
 7776 009e 4C        		.byte	76
 7777 009f 3E        		.byte	62
 7778               	.global	lng
 7781               	lng:
 7782 00a0 00        		.byte	0
 7783 00a1 00        		.byte	0
 7784 00a2 92        		.byte	-110
 7785 00a3 C2        		.byte	-62
 7786               	.global	lat
 7789               	lat:
 7790 00a4 00        		.byte	0
 7791 00a5 00        		.byte	0
 7792 00a6 2C        		.byte	44
 7793 00a7 42        		.byte	66
 7794               	.global	timeout_or_sampling_no_longer_enabled
 7795               	.global	timeout_or_sampling_no_longer_enabled
 7796               		.section .bss
 7799               	timeout_or_sampling_no_longer_enabled:
 7800 0005 00        		.skip 1,0
 7801               	.global	ep_in_data
 7802               	.global	ep_in_data
 7805               	ep_in_data:
 7806 0006 0000 0000 		.skip 4,0
 7807               	.global	ep_in_pipe_data
 7808               		.data
 7811               	ep_in_pipe_data:
 7812 00a8 0000      		.word	ep_in_pipe_buffer
 7813 00aa 0000      		.word	ep_in_pipe_buffer
 7814 00ac 00        		.byte	0
 7815               		.comm ep_in_pipe_buffer,512,1
 7816               		.text
 7817               	.Letext0:
 7818               		.file 14 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/stdint.h"
 7819               		.file 15 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/avr/iox32a4u.h"
 7820               		.file 16 "usb/StdRequestType.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccOm9UCy.s:2      *ABS*:000000000000003f __SREG__
     /tmp/ccOm9UCy.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/ccOm9UCy.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/ccOm9UCy.s:5      *ABS*:0000000000000034 __CCP__
     /tmp/ccOm9UCy.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccOm9UCy.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccOm9UCy.s:15     .text:0000000000000000 EVENT_USB_Device_ConfigurationChanged
     /tmp/ccOm9UCy.s:7811   .data:00000000000000a8 ep_in_pipe_data
                            *COM*:0000000000000200 ep_in_pipe_buffer
     /tmp/ccOm9UCy.s:7805   .bss:0000000000000006 ep_in_data
     /tmp/ccOm9UCy.s:108    .text:000000000000004e __vector_125
     /tmp/ccOm9UCy.s:246    .text:00000000000000d8 __vector_126
     /tmp/ccOm9UCy.s:7706   .bss:0000000000000001 usb_cmd
     /tmp/ccOm9UCy.s:7700   .bss:0000000000000000 cmd_data
     /tmp/ccOm9UCy.s:782    .text:00000000000002ea send_string
     /tmp/ccOm9UCy.s:7799   .bss:0000000000000005 timeout_or_sampling_no_longer_enabled
     /tmp/ccOm9UCy.s:1916   .text:00000000000006e2 concat
     /tmp/ccOm9UCy.s:2010   .text:000000000000074e distance
     /tmp/ccOm9UCy.s:7789   .data:00000000000000a4 lat
     /tmp/ccOm9UCy.s:7781   .data:00000000000000a0 lng
     /tmp/ccOm9UCy.s:2305   .text:000000000000090e parse_nmea_string
     /tmp/ccOm9UCy.s:7773   .data:000000000000009c max_dist
     /tmp/ccOm9UCy.s:2634   .text:0000000000000ada parse_nmea
     /tmp/ccOm9UCy.s:2932   .text:0000000000000c98 uart_putchar
     /tmp/ccOm9UCy.s:2978   .text:0000000000000cb8 uart_getchar
     /tmp/ccOm9UCy.s:3004   .text:0000000000000cc4 send_uart
     /tmp/ccOm9UCy.s:7767   .bss:0000000000000004 debug
     /tmp/ccOm9UCy.s:4221   .text:000000000000113a toggle_power_gps
     /tmp/ccOm9UCy.s:4294   .text:000000000000117e gps_init
     /tmp/ccOm9UCy.s:4460   .text:0000000000001242 gps_receive
     /tmp/ccOm9UCy.s:4854   .text:000000000000147a wake_up_gprs
     /tmp/ccOm9UCy.s:4871   .text:000000000000147c gprs_init
     /tmp/ccOm9UCy.s:4920   .text:00000000000014a0 send_message
     /tmp/ccOm9UCy.s:5197   .text:00000000000015da GprsTextModeSMS
     /tmp/ccOm9UCy.s:5225   .text:00000000000015e6 PowerDownModem
     /tmp/ccOm9UCy.s:5253   .text:00000000000015f2 SleepModem
     /tmp/ccOm9UCy.s:5281   .text:00000000000015fe WakeUpModem
     /tmp/ccOm9UCy.s:5319   .text:000000000000160a SimpleReceive
     /tmp/ccOm9UCy.s:5538   .text.startup:0000000000000000 main
                            *COM*:0000000000000010 gps
     /tmp/ccOm9UCy.s:7749   .bss:0000000000000003 freq
     /tmp/ccOm9UCy.s:7742   .data:0000000000000096 phonenumber
     /tmp/ccOm9UCy.s:7735   .data:0000000000000087 twilio_number
     /tmp/ccOm9UCy.s:7129   .text:00000000000016fa EVENT_USB_Device_ControlRequest
                            *COM*:0000000000000002 message
     /tmp/ccOm9UCy.s:7712   .progmem.data:0000000000000000 fwversion
     /tmp/ccOm9UCy.s:7717   .progmem.data:000000000000000b hwversion
     /tmp/ccOm9UCy.s:7658   .text:0000000000001942 EVENT_USB_Device_ControlOUT
                            *COM*:0000000000000001 count
     /tmp/ccOm9UCy.s:7726   .bss:0000000000000002 updating
     /tmp/ccOm9UCy.s:7755   .data:0000000000000098 high_freq
     /tmp/ccOm9UCy.s:7760   .data:000000000000009a low_freq

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
endpoints
USB_Init
USB_HandleSetup
ep0_buf_out
__eeupd_block_x32a4u
malloc
strcpy
strcat
__subsf3
__mulsf3
sin
cos
__addsf3
sqrt
atan2
strtok
atof
__divsf3
__gtsf2
sprintf
USB_ConfigureClock
__ltsf2
ep0_buf_in
__eerd_block_x32a4u
USB_ep0_send_progmem
