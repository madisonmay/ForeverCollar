   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	EVENT_USB_Device_ConfigurationChanged
  15               	EVENT_USB_Device_ConfigurationChanged:
  16               	.LFB57:
  17               		.file 1 "Framework.h"
   1:Framework.h   **** #pragma once
   2:Framework.h   **** #define F_CPU 32000000UL
   3:Framework.h   **** 
   4:Framework.h   **** // includes
   5:Framework.h   **** #include <avr/interrupt.h>
   6:Framework.h   **** #include <util/delay.h>
   7:Framework.h   **** #include "Descriptors.h"
   8:Framework.h   **** #include "usb/usb.h"
   9:Framework.h   **** #include "usb/usb_pipe.h"
  10:Framework.h   **** #include <avr/eeprom.h>
  11:Framework.h   **** #include <avr/io.h>
  12:Framework.h   **** 
  13:Framework.h   **** USB_PIPE(ep_in, 0x81 | USB_EP_PP, USB_EP_TYPE_BULK_gc, 64, 8, PIPE_ENABLE_FLUSH);
  14:Framework.h   **** 
  15:Framework.h   **** bool timeout_or_sampling_no_longer_enabled = 0;
  16:Framework.h   **** 
  17:Framework.h   **** // Queue a byte to be sent over the bulk EP. Blocks if the buffer is full
  18:Framework.h   **** static inline void send_byte(uint8_t byte){
  19:Framework.h   ****     // this should never actually block if your buffer is big enough
  20:Framework.h   ****     while (!usb_pipe_can_write(&ep_in));
  21:Framework.h   **** 	usb_pipe_write_byte(&ep_in, byte);
  22:Framework.h   **** }
  23:Framework.h   **** 
  24:Framework.h   **** // Sends a break to end the USB read and flushes the USB pipe
  25:Framework.h   **** static inline void break_and_flush(){
  26:Framework.h   ****     usb_pipe_flush(&ep_in);
  27:Framework.h   ****     USB.INTFLAGSBSET = USB_TRNIF_bm;
  28:Framework.h   ****     while (!usb_pipe_can_write(&ep_in)){
  29:Framework.h   ****         if (timeout_or_sampling_no_longer_enabled){
  30:Framework.h   ****             usb_pipe_reset(&ep_in);
  31:Framework.h   ****             return;
  32:Framework.h   ****         }
  33:Framework.h   ****     }
  34:Framework.h   **** } 
  35:Framework.h   **** 
  36:Framework.h   **** void EVENT_USB_Device_ConfigurationChanged(uint8_t config){
  18               		.loc 1 36 0
  19               		.cfi_startproc
  20               	.LVL0:
  21               	/* prologue: function */
  22               	/* frame size = 0 */
  23               	/* stack size = 0 */
  24               	.L__stack_usage = 0
  25               	.LBB410:
  26               	.LBB411:
  27               		.file 2 "usb/usb_pipe.h"
   1:usb/usb_pipe.h **** #include "pipe.h"
   2:usb/usb_pipe.h **** #include "usb.h"
   3:usb/usb_pipe.h **** 
   4:usb/usb_pipe.h **** #include <util/atomic.h>
   5:usb/usb_pipe.h **** #ifndef PIPE_ATOMIC
   6:usb/usb_pipe.h **** #define PIPE_ATOMIC ATOMIC_RESTORESTATE
   7:usb/usb_pipe.h **** #endif 
   8:usb/usb_pipe.h **** 
   9:usb/usb_pipe.h **** typedef struct USB_Pipe_data{
  10:usb/usb_pipe.h **** 	bool bank;
  11:usb/usb_pipe.h **** 	uint8_t flush;
  12:usb/usb_pipe.h **** 	uint16_t packet_offset; // Index into current packet for byte mode
  13:usb/usb_pipe.h **** } USB_Pipe_data;
  14:usb/usb_pipe.h **** 
  15:usb/usb_pipe.h **** // Immutable part, constant-folded at compile time
  16:usb/usb_pipe.h **** typedef struct USB_Pipe{
  17:usb/usb_pipe.h **** 	uint8_t ep;
  18:usb/usb_pipe.h **** 	uint8_t type;
  19:usb/usb_pipe.h **** 	USB_Pipe_data* data;
  20:usb/usb_pipe.h **** 	const Pipe* pipe;
  21:usb/usb_pipe.h **** 	uint8_t features;
  22:usb/usb_pipe.h **** } USB_Pipe;
  23:usb/usb_pipe.h **** 
  24:usb/usb_pipe.h **** #define PIPE_ENABLE_FLUSH (1<<0)
  25:usb/usb_pipe.h **** 
  26:usb/usb_pipe.h **** #define USB_PIPE(NAME, EPNO, TYPE, PACKET_SIZE, BUFFER_PACKETS, FEATURES) \
  27:usb/usb_pipe.h **** 	PIPE(NAME##_pipe, (BUFFER_PACKETS), (PACKET_SIZE),               \
  28:usb/usb_pipe.h **** 		((EPNO)&USB_EP_IN)?0:2,                      \
  29:usb/usb_pipe.h **** 		((EPNO)&USB_EP_IN)?2:0                       \
  30:usb/usb_pipe.h **** 	);                                               \
  31:usb/usb_pipe.h **** 	USB_Pipe_data NAME##_data = {      \
  32:usb/usb_pipe.h **** 		.bank = 0,                   \
  33:usb/usb_pipe.h **** 		.flush = 0,                    \
  34:usb/usb_pipe.h **** 	};                                 \
  35:usb/usb_pipe.h **** 	const static USB_Pipe NAME = {     \
  36:usb/usb_pipe.h **** 		.ep = (EPNO),                  \
  37:usb/usb_pipe.h **** 		.type = (TYPE),                \
  38:usb/usb_pipe.h **** 		.data = &(NAME##_data),        \
  39:usb/usb_pipe.h **** 		.pipe = &(NAME##_pipe),        \
  40:usb/usb_pipe.h **** 		.features = (FEATURES),        \
  41:usb/usb_pipe.h **** 	};                                 \
  42:usb/usb_pipe.h **** 
  43:usb/usb_pipe.h **** static inline void usb_pipe_init(const USB_Pipe* p){
  44:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
  28               		.loc 2 44 0
  29 0000 2FB7      		in r18,__SREG__
  30               	.LVL1:
  31               	.LBB412:
  32               	.LBB413:
  33               		.file 3 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h"
   1:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    All rights reserved.
   3:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
   4:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
   7:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  10:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      distribution.
  14:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  15:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****      from this software without specific prior written permission.
  18:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  19:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** */
  31:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  32:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** /* $Id: atomic.h 2158 2010-06-10 15:48:28Z joerg_wunsch $ */
  33:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  34:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  37:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #include <avr/io.h>
  38:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #include <avr/interrupt.h>
  39:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  40:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** #if !defined(__DOXYGEN__)
  41:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** /* Internal helper functions. */
  42:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  44:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     sei();
  45:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     return 1;
  46:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** }
  47:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  48:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
  49:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
  34               		.loc 3 50 0
  35               	/* #APP */
  36               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
  37 0002 F894      		cli
  38               	 ;  0 "" 2
  39               	.LVL2:
  40               	/* #NOAPP */
  41               	.LBE413:
  42               	.LBE412:
  43               	.LBB414:
  44               	.LBB415:
  45               		.file 4 "usb/pipe.h"
   1:usb/pipe.h    **** // Ring buffer that takes heavy advantage of constant folding
   2:usb/pipe.h    **** #pragma once
   3:usb/pipe.h    **** 
   4:usb/pipe.h    **** #include "Common.h"
   5:usb/pipe.h    **** 
   6:usb/pipe.h    **** // Mutable part, becomes an actual struct
   7:usb/pipe.h    **** typedef struct Pipe_data{
   8:usb/pipe.h    **** 	uint8_t* read_ptr;
   9:usb/pipe.h    **** 	uint8_t* write_ptr;
  10:usb/pipe.h    **** 	int8_t count; // available slots
  11:usb/pipe.h    **** } Pipe_data;
  12:usb/pipe.h    **** 
  13:usb/pipe.h    **** // Immutable part, constant-folded at compile time
  14:usb/pipe.h    **** typedef struct Pipe{
  15:usb/pipe.h    **** 	Pipe_data* data;
  16:usb/pipe.h    **** 	uint8_t* buffer;
  17:usb/pipe.h    **** 	uint8_t  slots;         // Number of slots in the buffer
  18:usb/pipe.h    **** 	uint8_t reserve_read;  // Slots to prevent reading so they are available to writer
  19:usb/pipe.h    **** 	uint8_t reserve_write; // Slots to prevent writing so they are available to reader
  20:usb/pipe.h    **** 	uint16_t size;          // Size of a buffer slot in bytes
  21:usb/pipe.h    **** } Pipe;
  22:usb/pipe.h    **** 
  23:usb/pipe.h    **** #define PIPE_H(NAME, SLOTS, SIZE, RESERVE_READ, RESERVE_WRITE)       \
  24:usb/pipe.h    **** 	extern Pipe_data NAME##_data;         \
  25:usb/pipe.h    **** 	extern uint8_t NAME##_buffer[(SLOTS)*(SIZE)]; \
  26:usb/pipe.h    **** 	const static Pipe NAME = {            \
  27:usb/pipe.h    **** 		.data = &(NAME##_data),           \
  28:usb/pipe.h    **** 		.buffer = &((NAME##_buffer)[0]),  \
  29:usb/pipe.h    **** 		.slots = (SLOTS),                 \
  30:usb/pipe.h    **** 		.size = (SIZE),                   \
  31:usb/pipe.h    **** 		.reserve_read = (RESERVE_READ),   \
  32:usb/pipe.h    **** 		.reserve_write = (RESERVE_WRITE), \
  33:usb/pipe.h    **** 	};
  34:usb/pipe.h    **** 
  35:usb/pipe.h    **** 
  36:usb/pipe.h    **** #define PIPE_C(NAME, SLOTS, SIZE)                   \
  37:usb/pipe.h    **** 	uint8_t NAME##_buffer[(SLOTS)*(SIZE)];           \
  38:usb/pipe.h    **** 	Pipe_data NAME##_data = {                \
  39:usb/pipe.h    **** 		.count = 0,                          \
  40:usb/pipe.h    **** 		.read_ptr = &((NAME##_buffer)[0]),                       \
  41:usb/pipe.h    **** 		.write_ptr = &((NAME##_buffer)[0]),                      \
  42:usb/pipe.h    **** 	};
  43:usb/pipe.h    **** 
  44:usb/pipe.h    **** #define PIPE(NAME, SLOTS, SIZE, RESERVE_READ, RESERVE_WRITE) \
  45:usb/pipe.h    **** 	PIPE_H(NAME, SLOTS, SIZE, RESERVE_READ, RESERVE_WRITE)   \
  46:usb/pipe.h    **** 	PIPE_C(NAME, SLOTS, SIZE)
  47:usb/pipe.h    **** 
  48:usb/pipe.h    **** // Number of slots available to read
  49:usb/pipe.h    **** static inline int8_t pipe_can_read(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  50:usb/pipe.h    **** static inline int8_t pipe_can_read(const Pipe* pipe){
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
  52:usb/pipe.h    **** }
  53:usb/pipe.h    **** 
  54:usb/pipe.h    **** // Number of slots available to write
  55:usb/pipe.h    **** static inline int8_t pipe_can_write(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  56:usb/pipe.h    **** static inline int8_t pipe_can_write(const Pipe* pipe){
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
  58:usb/pipe.h    **** }
  59:usb/pipe.h    **** 
  60:usb/pipe.h    **** static inline uint8_t* pipe_read_ptr(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  61:usb/pipe.h    **** static inline uint8_t* pipe_read_ptr(const Pipe* pipe){
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
  63:usb/pipe.h    **** }
  64:usb/pipe.h    **** 
  65:usb/pipe.h    **** static inline uint8_t* pipe_write_ptr(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  66:usb/pipe.h    **** static inline uint8_t* pipe_write_ptr(const Pipe* pipe){
  67:usb/pipe.h    **** 	return pipe->data->write_ptr;
  68:usb/pipe.h    **** }
  69:usb/pipe.h    **** 
  70:usb/pipe.h    **** static inline void pipe_done_read(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  71:usb/pipe.h    **** static inline void pipe_done_read(const Pipe* pipe){
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
  74:usb/pipe.h    **** 	// Assumes buffer_size % slot_size == 0 and all accesses aligned
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
  77:usb/pipe.h    **** }
  78:usb/pipe.h    **** 
  79:usb/pipe.h    **** static inline void pipe_done_write(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  80:usb/pipe.h    **** static inline void pipe_done_write(const Pipe* pipe){
  81:usb/pipe.h    **** 	pipe->data->count += 1;
  82:usb/pipe.h    **** 	pipe->data->write_ptr += pipe->size;
  83:usb/pipe.h    **** 	// Assumes buffer_size % slot_size == 0 and all accesses aligned
  84:usb/pipe.h    **** 	if (pipe->data->write_ptr == &pipe->buffer[pipe->slots*pipe->size])
  85:usb/pipe.h    **** 		pipe->data->write_ptr = &pipe->buffer[0];
  86:usb/pipe.h    **** }
  87:usb/pipe.h    **** 
  88:usb/pipe.h    **** static inline void pipe_reset(const Pipe* pipe) ATTR_ALWAYS_INLINE;
  89:usb/pipe.h    **** static inline void pipe_reset(const Pipe* pipe){
  90:usb/pipe.h    **** 	pipe->data->count = 0;
  46               		.loc 4 90 0
  47 0004 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
  91:usb/pipe.h    **** 	pipe->data->read_ptr = pipe->data->write_ptr = pipe->buffer;
  48               		.loc 4 91 0
  49 0008 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
  50 000a 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
  51               	.LVL3:
  52 000c 8093 0000 		sts ep_in_pipe_data+2,r24
  53 0010 9093 0000 		sts ep_in_pipe_data+2+1,r25
  54 0014 8093 0000 		sts ep_in_pipe_data,r24
  55 0018 9093 0000 		sts ep_in_pipe_data+1,r25
  56               	.LVL4:
  57               	.LBE415:
  58               	.LBE414:
  59               	.LBB416:
  60               	.LBB417:
  61               	.LBB418:
  62               		.file 5 "usb/usb.h"
   1:usb/usb.h     **** // Minimal USB Stack for ATxmega32a4u and related
   2:usb/usb.h     **** // http://nonolithlabs.com
   3:usb/usb.h     **** // (C) 2011 Kevin Mehall (Nonolith Labs) <km@kevinmehall.net>
   4:usb/usb.h     **** //
   5:usb/usb.h     **** // Heavily borrows from LUFA
   6:usb/usb.h     **** // Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
   7:usb/usb.h     **** //
   8:usb/usb.h     **** // Licensed under the terms of the GNU GPLv3+
   9:usb/usb.h     **** 
  10:usb/usb.h     **** #pragma once
  11:usb/usb.h     **** 
  12:usb/usb.h     **** #include <avr/io.h>
  13:usb/usb.h     **** 
  14:usb/usb.h     **** #define CPU_TO_LE16(x) x
  15:usb/usb.h     **** 
  16:usb/usb.h     **** struct USB_Request_Header;
  17:usb/usb.h     **** typedef struct USB_Request_Header USB_Requst_Header_t;
  18:usb/usb.h     **** 
  19:usb/usb.h     **** #include "StdDescriptors.h"
  20:usb/usb.h     **** #include "StdRequestType.h"
  21:usb/usb.h     **** #include "Events.h"
  22:usb/usb.h     **** 
  23:usb/usb.h     **** #ifndef USB_MAXEP
  24:usb/usb.h     **** 	#define USB_MAXEP 1
  25:usb/usb.h     **** #endif
  26:usb/usb.h     **** 
  27:usb/usb.h     **** #ifndef USB_EP0SIZE
  28:usb/usb.h     **** 	#define EP0SIZE 64
  29:usb/usb.h     **** #endif
  30:usb/usb.h     **** 
  31:usb/usb.h     **** typedef union USB_EP_pair{
  32:usb/usb.h     **** 	union{
  33:usb/usb.h     **** 		struct{
  34:usb/usb.h     **** 			USB_EP_t out;
  35:usb/usb.h     **** 			USB_EP_t in;
  36:usb/usb.h     **** 		};
  37:usb/usb.h     **** 		USB_EP_t ep[2];
  38:usb/usb.h     **** 	};
  39:usb/usb.h     **** } ATTR_PACKED USB_EP_pair_t;
  40:usb/usb.h     **** 
  41:usb/usb.h     **** extern uint8_t ep0_buf_in[USB_EP0SIZE];
  42:usb/usb.h     **** extern uint8_t ep0_buf_out[USB_EP0SIZE];
  43:usb/usb.h     **** extern USB_EP_pair_t endpoints[USB_MAXEP+1];
  44:usb/usb.h     **** 
  45:usb/usb.h     **** /** String descriptor index for the device's unique serial number string descriptor within the devi
  46:usb/usb.h     ****  *  This unique serial number is used by the host to associate resources to the device (such as dri
  47:usb/usb.h     ****  *  number allocations) to a device regardless of the port it is plugged in to on the host. Some mi
  48:usb/usb.h     ****  *  a unique serial number internally, and setting the device descriptors serial number string inde
  49:usb/usb.h     ****  *  will cause it to use the internal serial number.
  50:usb/usb.h     ****  *
  51:usb/usb.h     ****  *  On unsupported devices, this will evaluate to \ref NO_DESCRIPTOR and so will force the host to 
  52:usb/usb.h     ****  *  number for the device.
  53:usb/usb.h     ****  */
  54:usb/usb.h     **** #define USE_INTERNAL_SERIAL            0xDC
  55:usb/usb.h     **** 
  56:usb/usb.h     **** /** Length of the device's unique internal serial number, in bits, if present on the selected micro
  57:usb/usb.h     ****  *  model.
  58:usb/usb.h     ****  */
  59:usb/usb.h     **** #define INTERNAL_SERIAL_LENGTH_BITS    (8 * (1 + (offsetof(NVM_PROD_SIGNATURES_t, COORDY1) - offset
  60:usb/usb.h     **** 
  61:usb/usb.h     **** /** Start address of the internal serial number, in the appropriate address space, if present on th
  62:usb/usb.h     ****  *  model.
  63:usb/usb.h     ****  */
  64:usb/usb.h     **** #define INTERNAL_SERIAL_START_ADDRESS  offsetof(NVM_PROD_SIGNATURES_t, LOTNUM0)
  65:usb/usb.h     **** 
  66:usb/usb.h     **** /* Enums: */
  67:usb/usb.h     **** 	/** Enum for the various states of the USB Device state machine. Only some states are
  68:usb/usb.h     **** 	 *  implemented in the LUFA library - other states are left to the user to implement.
  69:usb/usb.h     **** 	 *
  70:usb/usb.h     **** 	 *  For information on each possible USB device state, refer to the USB 2.0 specification.
  71:usb/usb.h     **** 	 *
  72:usb/usb.h     **** 	 *  \see \ref USB_DeviceState, which stores the current device state machine state.
  73:usb/usb.h     **** 	 */
  74:usb/usb.h     **** 	enum USB_Device_States_t
  75:usb/usb.h     **** 	{
  76:usb/usb.h     **** 		DEVICE_STATE_Unattached                   = 0, /**< Internally implemented by the library. This s
  77:usb/usb.h     **** 		                                                *   that the device is not currently connected to
  78:usb/usb.h     **** 		                                                */
  79:usb/usb.h     **** 		DEVICE_STATE_Powered                      = 1, /**< Internally implemented by the library. This s
  80:usb/usb.h     **** 		                                                *   that the device is connected to a host, but e
  81:usb/usb.h     **** 		                                                *   yet begun.
  82:usb/usb.h     **** 		                                                */
  83:usb/usb.h     **** 		DEVICE_STATE_Default                      = 2, /**< Internally implemented by the library. This s
  84:usb/usb.h     **** 		                                                *   that the device's USB bus has been reset by t
  85:usb/usb.h     **** 		                                                *   now waiting for the host to begin the enumera
  86:usb/usb.h     **** 		                                                */
  87:usb/usb.h     **** 		DEVICE_STATE_Addressed                    = 3, /**< Internally implemented by the library. This s
  88:usb/usb.h     **** 		                                                *   that the device has been addressed by the USB
  89:usb/usb.h     **** 		                                                *   yet configured.
  90:usb/usb.h     **** 		                                                */
  91:usb/usb.h     **** 		DEVICE_STATE_Configured                   = 4, /**< May be implemented by the user project. This 
  92:usb/usb.h     **** 		                                                *   that the device has been enumerated by the ho
  93:usb/usb.h     **** 		                                                *   for USB communications to begin.
  94:usb/usb.h     **** 		                                                */
  95:usb/usb.h     **** 		DEVICE_STATE_Suspended                    = 5, /**< May be implemented by the user project. This 
  96:usb/usb.h     **** 		                                                *   that the USB bus has been suspended by the ho
  97:usb/usb.h     **** 		                                                *   should power down to a minimal power level un
  98:usb/usb.h     **** 		                                                *   resumed.
  99:usb/usb.h     **** 		                                                */
 100:usb/usb.h     **** 	};
 101:usb/usb.h     **** 
 102:usb/usb.h     **** #define USB_EP_size_to_gc(x)  ((x <= 8   )?USB_EP_BUFSIZE_8_gc:\
 103:usb/usb.h     ****                                (x <= 16  )?USB_EP_BUFSIZE_16_gc:\
 104:usb/usb.h     ****                                (x <= 32  )?USB_EP_BUFSIZE_32_gc:\
 105:usb/usb.h     ****                                (x <= 64  )?USB_EP_BUFSIZE_64_gc:\
 106:usb/usb.h     ****                                (x <= 128 )?USB_EP_BUFSIZE_128_gc:\
 107:usb/usb.h     ****                                (x <= 256 )?USB_EP_BUFSIZE_256_gc:\
 108:usb/usb.h     ****                                (x <= 512 )?USB_EP_BUFSIZE_512_gc:\
 109:usb/usb.h     ****                                            USB_EP_BUFSIZE_1023_gc)
 110:usb/usb.h     **** 
 111:usb/usb.h     **** #define USB_EP_IN 0x80
 112:usb/usb.h     **** 
 113:usb/usb.h     **** // Flag in the endpoint address to indicate that the endpoint should use
 114:usb/usb.h     **** // PingPong (double buffer) mode. This is not actually part of the endpoint
 115:usb/usb.h     **** // address as seen by the host. If PP is enabled, this flag needs to be part
 116:usb/usb.h     **** // of the address passed to all USB_EP_* functions.
 117:usb/usb.h     **** #define USB_EP_PP 0x40
 118:usb/usb.h     **** 	
 119:usb/usb.h     **** extern volatile uint8_t USB_DeviceState;
 120:usb/usb.h     **** extern volatile uint8_t USB_Device_ConfigurationNumber;
 121:usb/usb.h     **** 
 122:usb/usb.h     **** /** Configure the XMEGA's clock for use with USB.  */
 123:usb/usb.h     **** void USB_ConfigureClock(void);
 124:usb/usb.h     **** 
 125:usb/usb.h     **** /** Initialize USB functionality */
 126:usb/usb.h     **** void USB_Init(void);
 127:usb/usb.h     **** void USB_ResetInterface(void);
 128:usb/usb.h     **** 
 129:usb/usb.h     **** #define _USB_EP(epaddr) \
 130:usb/usb.h     **** 	USB_EP_pair_t* pair = &endpoints[(epaddr & 0x3F)]; \
 131:usb/usb.h     **** 	USB_EP_t* e __attribute__ ((unused)) = &pair->ep[!!(epaddr&0x80)]; \
 132:usb/usb.h     **** 	
 133:usb/usb.h     **** #define _USB_EP_OTHER(epaddr) \
 134:usb/usb.h     **** 	USB_EP_t* other = &pair->ep[!(epaddr&0x80)]
 135:usb/usb.h     **** 	
 136:usb/usb.h     **** #define _USB_EP_BANK(epaddr, bank) \
 137:usb/usb.h     **** 	USB_EP_t* b = &pair->ep[!!(epaddr&0x80) != bank]
 138:usb/usb.h     **** 
 139:usb/usb.h     **** inline void USB_ep_init(uint8_t ep, uint8_t type, uint16_t bufsize) ATTR_ALWAYS_INLINE;
 140:usb/usb.h     **** inline void USB_ep_init(uint8_t ep, uint8_t type, uint16_t bufsize){
 141:usb/usb.h     **** 	_USB_EP(ep);
 142:usb/usb.h     **** 	if (ep & USB_EP_PP){
 143:usb/usb.h     **** 		_USB_EP_OTHER(ep);
 144:usb/usb.h     **** 		e->STATUS = USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm;
  63               		.loc 5 144 0
  64 001c 80E0      		ldi r24,lo8(endpoints+24)
  65 001e 90E0      		ldi r25,hi8(endpoints+24)
  66 0020 36E0      		ldi r19,lo8(6)
  67 0022 3093 0000 		sts endpoints+24,r19
 145:usb/usb.h     **** 		e->CTRL = type | USB_EP_size_to_gc(bufsize) | USB_EP_PINGPONG_bm;
  68               		.loc 5 145 0
  69 0026 33E9      		ldi r19,lo8(-109)
  70 0028 3093 0000 		sts endpoints+25,r19
 146:usb/usb.h     **** 		other->CTRL = 0;
  71               		.loc 5 146 0
  72 002c FC01      		movw r30,r24
  73 002e 3797      		sbiw r30,7
  74 0030 1082      		st Z,__zero_reg__
 147:usb/usb.h     **** 		other->STATUS = USB_EP_BUSNACK0_bm;
  75               		.loc 5 147 0
  76 0032 0897      		sbiw r24,8
  77 0034 32E0      		ldi r19,lo8(2)
  78 0036 FC01      		movw r30,r24
  79 0038 3083      		st Z,r19
  80               	.LBE418:
  81               	.LBE417:
  82               	.LBE416:
  45:usb/usb_pipe.h **** 		pipe_reset(p->pipe);
  46:usb/usb_pipe.h **** 		USB_ep_init(p->ep, p->type, p->pipe->size);
  47:usb/usb_pipe.h **** 		p->data->bank = 0;
  83               		.loc 2 47 0
  84 003a 1092 0000 		sts ep_in_data,__zero_reg__
  48:usb/usb_pipe.h **** 		p->data->flush = 0;
  85               		.loc 2 48 0
  86 003e 1092 0000 		sts ep_in_data+1,__zero_reg__
  49:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
  87               		.loc 2 49 0
  88 0042 1092 0000 		sts ep_in_data+2,__zero_reg__
  89 0046 1092 0000 		sts ep_in_data+2+1,__zero_reg__
  90               	.LVL5:
  91               	.LBB419:
  92               	.LBB420:
  51:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     return 1;
  52:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** }
  53:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  54:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
  55:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  56:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     sei();
  57:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  58:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     (void)__s;
  59:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** }
  60:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  61:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ void __iCliParam(const uint8_t *__s)
  62:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  63:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
  64:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  65:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     (void)__s;
  66:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** }
  67:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** 
  68:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** static __inline__ void __iRestore(const  uint8_t *__s)
  69:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h **** {
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
  93               		.loc 3 70 0
  94 004a 2FBF      		out __SREG__,r18
  71:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  95               		.loc 3 71 0
  96               	/* epilogue start */
  97               	.LBE420:
  98               	.LBE419:
  99               	.LBE411:
 100               	.LBE410:
  37:Framework.h   **** 	usb_pipe_init(&ep_in);
  38:Framework.h   **** }
 101               		.loc 1 38 0
 102 004c 0895      		ret
 103               		.cfi_endproc
 104               	.LFE57:
 106               	.global	__vector_125
 108               	__vector_125:
 109               	.LFB58:
  39:Framework.h   **** 
  40:Framework.h   **** ISR(USB_BUSEVENT_vect){
 110               		.loc 1 40 0
 111               		.cfi_startproc
 112 004e 1F92      		push r1
 113               	.LCFI0:
 114               		.cfi_def_cfa_offset 3
 115               		.cfi_offset 1, -2
 116 0050 0F92      		push r0
 117               	.LCFI1:
 118               		.cfi_def_cfa_offset 4
 119               		.cfi_offset 0, -3
 120 0052 0FB6      		in r0,__SREG__
 121 0054 0F92      		push r0
 122 0056 1124      		clr __zero_reg__
 123 0058 2F93      		push r18
 124               	.LCFI2:
 125               		.cfi_def_cfa_offset 5
 126               		.cfi_offset 18, -4
 127 005a 3F93      		push r19
 128               	.LCFI3:
 129               		.cfi_def_cfa_offset 6
 130               		.cfi_offset 19, -5
 131 005c 4F93      		push r20
 132               	.LCFI4:
 133               		.cfi_def_cfa_offset 7
 134               		.cfi_offset 20, -6
 135 005e 5F93      		push r21
 136               	.LCFI5:
 137               		.cfi_def_cfa_offset 8
 138               		.cfi_offset 21, -7
 139 0060 6F93      		push r22
 140               	.LCFI6:
 141               		.cfi_def_cfa_offset 9
 142               		.cfi_offset 22, -8
 143 0062 7F93      		push r23
 144               	.LCFI7:
 145               		.cfi_def_cfa_offset 10
 146               		.cfi_offset 23, -9
 147 0064 8F93      		push r24
 148               	.LCFI8:
 149               		.cfi_def_cfa_offset 11
 150               		.cfi_offset 24, -10
 151 0066 9F93      		push r25
 152               	.LCFI9:
 153               		.cfi_def_cfa_offset 12
 154               		.cfi_offset 25, -11
 155 0068 AF93      		push r26
 156               	.LCFI10:
 157               		.cfi_def_cfa_offset 13
 158               		.cfi_offset 26, -12
 159 006a BF93      		push r27
 160               	.LCFI11:
 161               		.cfi_def_cfa_offset 14
 162               		.cfi_offset 27, -13
 163 006c EF93      		push r30
 164               	.LCFI12:
 165               		.cfi_def_cfa_offset 15
 166               		.cfi_offset 30, -14
 167 006e FF93      		push r31
 168               	.LCFI13:
 169               		.cfi_def_cfa_offset 16
 170               		.cfi_offset 31, -15
 171               	/* prologue: Signal */
 172               	/* frame size = 0 */
 173               	/* stack size = 15 */
 174               	.L__stack_usage = 15
  41:Framework.h   **** 	if (USB.INTFLAGSACLR & USB_SOFIF_bm){
 175               		.loc 1 41 0
 176 0070 E0EC      		ldi r30,lo8(1216)
 177 0072 F4E0      		ldi r31,hi8(1216)
 178 0074 8091 CA04 		lds r24,1226
 179 0078 87FD      		sbrc r24,7
 180 007a 00C0      		rjmp .L8
  42:Framework.h   **** 		USB.INTFLAGSACLR = USB_SOFIF_bm;
  43:Framework.h   **** 	}else if (USB.INTFLAGSACLR & (USB_CRCIF_bm | USB_UNFIF_bm | USB_OVFIF_bm)){
 181               		.loc 1 43 0
 182 007c 8091 CA04 		lds r24,1226
 183 0080 8E70      		andi r24,lo8(14)
 184 0082 01F4      		brne .L9
  44:Framework.h   **** 		USB.INTFLAGSACLR = (USB_CRCIF_bm | USB_UNFIF_bm | USB_OVFIF_bm);
  45:Framework.h   **** 	}else if (USB.INTFLAGSACLR & USB_STALLIF_bm){
 185               		.loc 1 45 0
 186 0084 8091 CA04 		lds r24,1226
 187 0088 80FD      		sbrc r24,0
 188 008a 00C0      		rjmp .L10
  46:Framework.h   **** 		USB.INTFLAGSACLR = USB_STALLIF_bm;
  47:Framework.h   **** 	}else{
  48:Framework.h   **** 		USB.INTFLAGSACLR = USB_SUSPENDIF_bm | USB_RESUMEIF_bm | USB_RSTIF_bm;
 189               		.loc 1 48 0
 190 008c 80E7      		ldi r24,lo8(112)
 191 008e 8287      		std Z+10,r24
 192               	.LBB421:
 193               	.LBB422:
 148:usb/usb.h     **** 	}else{
 149:usb/usb.h     **** 		e->STATUS = USB_EP_BUSNACK0_bm;
 150:usb/usb.h     **** 		e->CTRL = type | USB_EP_size_to_gc(bufsize);
 151:usb/usb.h     **** 	}
 152:usb/usb.h     **** }
 153:usb/usb.h     **** 
 154:usb/usb.h     **** inline void USB_ep_cancel(uint8_t ep) ATTR_ALWAYS_INLINE;
 155:usb/usb.h     **** inline void USB_ep_cancel(uint8_t ep){
 156:usb/usb.h     **** 	_USB_EP(ep);
 157:usb/usb.h     **** 	if (ep & USB_EP_PP){
 158:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 159:usb/usb.h     **** 		LACR16(&e->STATUS, USB_EP_BANK_bm);
 160:usb/usb.h     **** 	}else{
 161:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm);
 162:usb/usb.h     **** 	}
 163:usb/usb.h     **** }
 164:usb/usb.h     **** 
 165:usb/usb.h     **** inline void USB_ep_start_bank(uint8_t ep, uint8_t bank, uint8_t* addr, uint16_t size){
 166:usb/usb.h     **** 	_USB_EP(ep);
 167:usb/usb.h     **** 	_USB_EP_BANK(ep, bank);
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 170:usb/usb.h     **** 	
 171:usb/usb.h     **** 	//TODO: the OVF, STALL, and TRNCOMPL flags are in b->STATUS. Clear them if anyone cares.
 172:usb/usb.h     **** 
 173:usb/usb.h     **** 	if (bank==0){
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 175:usb/usb.h     **** 	}else{
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 177:usb/usb.h     **** 	}
 178:usb/usb.h     **** }
 179:usb/usb.h     **** 
 180:usb/usb.h     **** inline void USB_ep_out_start(uint8_t ep, uint8_t* addr) ATTR_ALWAYS_INLINE;
 181:usb/usb.h     **** inline void USB_ep_out_start(uint8_t ep, uint8_t* addr){
 182:usb/usb.h     **** 	USB_ep_start_bank(ep, 0, addr, 0);
 183:usb/usb.h     **** }
 184:usb/usb.h     **** 
 185:usb/usb.h     **** inline void USB_ep_in_start(uint8_t ep, uint8_t* addr, uint16_t size) ATTR_ALWAYS_INLINE;
 186:usb/usb.h     **** inline void USB_ep_in_start(uint8_t ep, uint8_t* addr, uint16_t size){
 187:usb/usb.h     **** 	USB_ep_start_bank(ep, 0, addr, size);
 188:usb/usb.h     **** }
 189:usb/usb.h     **** 
 190:usb/usb.h     **** inline bool USB_ep_done_bank(uint8_t ep, uint8_t bank){
 191:usb/usb.h     **** 	_USB_EP(ep);
 192:usb/usb.h     **** 	return e->STATUS & (bank?USB_EP_TRNCOMPL1_bm:USB_EP_TRNCOMPL0_bm);
 193:usb/usb.h     **** }
 194:usb/usb.h     **** 
 195:usb/usb.h     **** inline bool USB_ep_done(uint8_t ep) ATTR_ALWAYS_INLINE;
 196:usb/usb.h     **** inline bool USB_ep_done(uint8_t ep){
 197:usb/usb.h     **** 	_USB_EP(ep);
 198:usb/usb.h     **** 	if (ep & USB_EP_PP){
 199:usb/usb.h     **** 		return e->STATUS & (USB_EP_TRNCOMPL0_bm|USB_EP_TRNCOMPL1_bm);
 200:usb/usb.h     **** 	}else{
 201:usb/usb.h     **** 		// Because for ep0, TRNCOMPL1 is SETUP
 202:usb/usb.h     **** 		return e->STATUS & USB_EP_TRNCOMPL0_bm;
 203:usb/usb.h     **** 	}
 204:usb/usb.h     **** }
 205:usb/usb.h     **** 
 206:usb/usb.h     **** inline void USB_ep_clear_done(uint8_t ep) ATTR_ALWAYS_INLINE;
 207:usb/usb.h     **** inline void USB_ep_clear_done(uint8_t ep){
 208:usb/usb.h     **** 	_USB_EP(ep);
 209:usb/usb.h     **** 	if (ep & USB_EP_PP){
 210:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_TRNCOMPL0_bm|USB_EP_TRNCOMPL1_bm);
 211:usb/usb.h     **** 	}else{
 212:usb/usb.h     **** 		// Because for ep0, TRNCOMPL1 is SETUP
 213:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_TRNCOMPL0_bm);
 214:usb/usb.h     **** 	}
 215:usb/usb.h     **** }
 216:usb/usb.h     **** 
 217:usb/usb.h     **** inline bool USB_ep_ready(uint8_t ep) ATTR_ALWAYS_INLINE;
 218:usb/usb.h     **** inline bool USB_ep_ready(uint8_t ep){
 219:usb/usb.h     **** 	_USB_EP(ep);
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 221:usb/usb.h     **** }
 222:usb/usb.h     **** 
 223:usb/usb.h     **** inline bool USB_ep_empty(uint8_t ep) ATTR_ALWAYS_INLINE;
 224:usb/usb.h     **** inline bool USB_ep_empty(uint8_t ep){
 225:usb/usb.h     **** 	_USB_EP(ep);
 226:usb/usb.h     **** 	if (ep & USB_EP_PP){
 227:usb/usb.h     **** 		const uint8_t mask = (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 229:usb/usb.h     **** 	}else{
 230:usb/usb.h     **** 		return e->STATUS & USB_EP_BUSNACK0_bm;
 231:usb/usb.h     **** 	}
 232:usb/usb.h     **** }
 233:usb/usb.h     **** 
 234:usb/usb.h     **** inline uint16_t USB_ep_count_bank(uint8_t ep, uint8_t bank) ATTR_ALWAYS_INLINE;
 235:usb/usb.h     **** inline uint16_t USB_ep_count_bank(uint8_t ep, uint8_t bank){
 236:usb/usb.h     **** 	_USB_EP(ep);
 237:usb/usb.h     **** 	_USB_EP_BANK(ep, bank);
 238:usb/usb.h     **** 	return b->CNT;
 239:usb/usb.h     **** }
 240:usb/usb.h     **** 
 241:usb/usb.h     **** inline uint16_t USB_ep_count(uint8_t ep) ATTR_ALWAYS_INLINE;
 242:usb/usb.h     **** inline uint16_t USB_ep_count(uint8_t ep){
 243:usb/usb.h     **** 	return USB_ep_count_bank(ep, 0);
 244:usb/usb.h     **** }
 245:usb/usb.h     **** 
 246:usb/usb.h     **** inline void USB_ep0_send(uint8_t size){
 247:usb/usb.h     **** 	USB_ep_in_start(0x80, ep0_buf_in, size);
 248:usb/usb.h     **** }
 249:usb/usb.h     **** void USB_ep0_send_progmem(const uint8_t* addr, uint16_t size);
 250:usb/usb.h     **** 
 251:usb/usb.h     **** inline void USB_ep_wait(uint8_t ep) ATTR_ALWAYS_INLINE;
 252:usb/usb.h     **** inline void USB_ep_wait(uint8_t ep){
 253:usb/usb.h     **** 	while (!USB_ep_done(ep)){};
 254:usb/usb.h     **** }
 255:usb/usb.h     **** 
 256:usb/usb.h     **** /// Select a certain bank of an endpoint for the next transfer
 257:usb/usb.h     **** inline void USB_ep_set_bank(uint8_t ep, uint8_t bank) ATTR_ALWAYS_INLINE;
 258:usb/usb.h     **** inline void USB_ep_set_bank(uint8_t ep, uint8_t bank){
 259:usb/usb.h     **** 	_USB_EP(ep);
 260:usb/usb.h     **** 	if (bank){
 261:usb/usb.h     **** 		LASR16(&(e->STATUS), USB_EP_BANK_bm);
 262:usb/usb.h     **** 	}else{
 263:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BANK_bm);
 264:usb/usb.h     **** 	}
 265:usb/usb.h     **** }
 266:usb/usb.h     **** 
 267:usb/usb.h     **** /// Get the bank 0/1 which will handle the next request on this endpoint
 268:usb/usb.h     **** inline uint8_t USB_ep_get_bank(uint8_t ep) ATTR_ALWAYS_INLINE;
 269:usb/usb.h     **** inline uint8_t USB_ep_get_bank(uint8_t ep){
 270:usb/usb.h     **** 	_USB_EP(ep);
 271:usb/usb.h     **** 	return !!(e->STATUS & USB_EP_BANK_bm);
 272:usb/usb.h     **** }
 273:usb/usb.h     **** 
 274:usb/usb.h     **** 
 275:usb/usb.h     **** // Enable the OUT stage on the default control pipe. This happens automatically
 276:usb/usb.h     **** // upon the return of HandleSetup, but use this function if it needs to happen
 277:usb/usb.h     **** // before returning (e.g. with USB_ep_wait()).
 278:usb/usb.h     **** inline void USB_ep0_enableOut(void) ATTR_ALWAYS_INLINE;
 279:usb/usb.h     **** inline void USB_ep0_enableOut(void){
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 281:usb/usb.h     **** }
 282:usb/usb.h     **** 
 283:usb/usb.h     **** bool USB_HandleSetup(void);
 284:usb/usb.h     **** 
 285:usb/usb.h     **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 286:usb/usb.h     ****                                     const uint8_t wIndex,
 287:usb/usb.h     ****                                     const void** const DescriptorAddress);
 288:usb/usb.h     **** 
 289:usb/usb.h     **** /** Detaches the device from the USB bus. This has the effect of removing the device from any
 290:usb/usb.h     ****  *  attached host, ceasing USB communications. If no host is present, this prevents any host from
 291:usb/usb.h     ****  *  enumerating the device once attached until \ref USB_Attach() is called.
 292:usb/usb.h     ****  */
 293:usb/usb.h     **** static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
 294:usb/usb.h     **** static inline void USB_Detach(void)
 295:usb/usb.h     **** {
 296:usb/usb.h     **** 	USB.CTRLB &= ~USB_ATTACH_bm;
 297:usb/usb.h     **** }
 298:usb/usb.h     **** 
 299:usb/usb.h     **** /** Attaches the device to the USB bus. This announces the device's presence to any attached
 300:usb/usb.h     ****  *  USB host, starting the enumeration process. If no host is present, attaching the device
 301:usb/usb.h     ****  *  will allow for enumeration once a host is connected to the device.
 302:usb/usb.h     ****  */
 303:usb/usb.h     **** static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
 304:usb/usb.h     **** static inline void USB_Attach(void)
 305:usb/usb.h     **** {
 306:usb/usb.h     **** 	USB.CTRLB |= USB_ATTACH_bm;
 307:usb/usb.h     **** }
 308:usb/usb.h     **** 
 309:usb/usb.h     **** inline void USB_Evt_Task(void) ATTR_ALWAYS_INLINE;
 310:usb/usb.h     **** inline void USB_Evt_Task(void){
 311:usb/usb.h     **** 	if (USB.STATUS & USB_BUSRST_bm){
 194               		.loc 5 311 0
 195 0090 8091 C204 		lds r24,1218
 196 0094 80FF      		sbrs r24,0
 197 0096 00C0      		rjmp .L2
 312:usb/usb.h     **** 		USB.STATUS &= ~USB_BUSRST_bm;
 198               		.loc 5 312 0
 199 0098 8091 C204 		lds r24,1218
 200 009c 8E7F      		andi r24,lo8(-2)
 201 009e 8283      		std Z+2,r24
 313:usb/usb.h     **** 		USB_Init();
 202               		.loc 5 313 0
 203 00a0 0E94 0000 		call USB_Init
 204 00a4 00C0      		rjmp .L2
 205               	.L9:
 206               	.LBE422:
 207               	.LBE421:
  44:Framework.h   **** 		USB.INTFLAGSACLR = (USB_CRCIF_bm | USB_UNFIF_bm | USB_OVFIF_bm);
 208               		.loc 1 44 0
 209 00a6 8EE0      		ldi r24,lo8(14)
 210 00a8 8287      		std Z+10,r24
 211               	.L2:
 212               	/* epilogue start */
  49:Framework.h   **** 		USB_Evt_Task();
  50:Framework.h   **** 	}
  51:Framework.h   **** }
 213               		.loc 1 51 0
 214 00aa FF91      		pop r31
 215 00ac EF91      		pop r30
 216 00ae BF91      		pop r27
 217 00b0 AF91      		pop r26
 218 00b2 9F91      		pop r25
 219 00b4 8F91      		pop r24
 220 00b6 7F91      		pop r23
 221 00b8 6F91      		pop r22
 222 00ba 5F91      		pop r21
 223 00bc 4F91      		pop r20
 224 00be 3F91      		pop r19
 225 00c0 2F91      		pop r18
 226 00c2 0F90      		pop r0
 227 00c4 0FBE      		out __SREG__,r0
 228 00c6 0F90      		pop r0
 229 00c8 1F90      		pop r1
 230 00ca 1895      		reti
 231               	.L10:
  46:Framework.h   **** 		USB.INTFLAGSACLR = USB_STALLIF_bm;
 232               		.loc 1 46 0
 233 00cc 81E0      		ldi r24,lo8(1)
 234 00ce 8287      		std Z+10,r24
 235 00d0 00C0      		rjmp .L2
 236               	.L8:
  42:Framework.h   **** 		USB.INTFLAGSACLR = USB_SOFIF_bm;
 237               		.loc 1 42 0
 238 00d2 80E8      		ldi r24,lo8(-128)
 239 00d4 8287      		std Z+10,r24
 240 00d6 00C0      		rjmp .L2
 241               		.cfi_endproc
 242               	.LFE58:
 244               	.global	__vector_126
 246               	__vector_126:
 247               	.LFB59:
  52:Framework.h   **** 
  53:Framework.h   **** ISR(USB_TRNCOMPL_vect){
 248               		.loc 1 53 0
 249               		.cfi_startproc
 250 00d8 1F92      		push r1
 251               	.LCFI14:
 252               		.cfi_def_cfa_offset 3
 253               		.cfi_offset 1, -2
 254 00da 0F92      		push r0
 255               	.LCFI15:
 256               		.cfi_def_cfa_offset 4
 257               		.cfi_offset 0, -3
 258 00dc 0FB6      		in r0,__SREG__
 259 00de 0F92      		push r0
 260 00e0 1124      		clr __zero_reg__
 261 00e2 0F93      		push r16
 262               	.LCFI16:
 263               		.cfi_def_cfa_offset 5
 264               		.cfi_offset 16, -4
 265 00e4 2F93      		push r18
 266               	.LCFI17:
 267               		.cfi_def_cfa_offset 6
 268               		.cfi_offset 18, -5
 269 00e6 3F93      		push r19
 270               	.LCFI18:
 271               		.cfi_def_cfa_offset 7
 272               		.cfi_offset 19, -6
 273 00e8 4F93      		push r20
 274               	.LCFI19:
 275               		.cfi_def_cfa_offset 8
 276               		.cfi_offset 20, -7
 277 00ea 5F93      		push r21
 278               	.LCFI20:
 279               		.cfi_def_cfa_offset 9
 280               		.cfi_offset 21, -8
 281 00ec 6F93      		push r22
 282               	.LCFI21:
 283               		.cfi_def_cfa_offset 10
 284               		.cfi_offset 22, -9
 285 00ee 7F93      		push r23
 286               	.LCFI22:
 287               		.cfi_def_cfa_offset 11
 288               		.cfi_offset 23, -10
 289 00f0 8F93      		push r24
 290               	.LCFI23:
 291               		.cfi_def_cfa_offset 12
 292               		.cfi_offset 24, -11
 293 00f2 9F93      		push r25
 294               	.LCFI24:
 295               		.cfi_def_cfa_offset 13
 296               		.cfi_offset 25, -12
 297 00f4 AF93      		push r26
 298               	.LCFI25:
 299               		.cfi_def_cfa_offset 14
 300               		.cfi_offset 26, -13
 301 00f6 BF93      		push r27
 302               	.LCFI26:
 303               		.cfi_def_cfa_offset 15
 304               		.cfi_offset 27, -14
 305 00f8 EF93      		push r30
 306               	.LCFI27:
 307               		.cfi_def_cfa_offset 16
 308               		.cfi_offset 30, -15
 309 00fa FF93      		push r31
 310               	.LCFI28:
 311               		.cfi_def_cfa_offset 17
 312               		.cfi_offset 31, -16
 313               	/* prologue: Signal */
 314               	/* frame size = 0 */
 315               	/* stack size = 16 */
 316               	.L__stack_usage = 16
  54:Framework.h   **** 	USB.FIFOWP = 0;
 317               		.loc 1 54 0
 318 00fc E0EC      		ldi r30,lo8(1216)
 319 00fe F4E0      		ldi r31,hi8(1216)
 320 0100 1482      		std Z+4,__zero_reg__
  55:Framework.h   **** 	USB.INTFLAGSBCLR = USB_SETUPIF_bm | USB_TRNIF_bm;
 321               		.loc 1 55 0
 322 0102 83E0      		ldi r24,lo8(3)
 323 0104 8487      		std Z+12,r24
 324               	.LVL6:
 325               	.LBB479:
 326               	.LBB480:
 327               	.LBB481:
  50:usb/usb_pipe.h **** 	}
  51:usb/usb_pipe.h **** }
  52:usb/usb_pipe.h **** 
  53:usb/usb_pipe.h **** static inline void usb_pipe_reset(const USB_Pipe* p){
  54:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
  55:usb/usb_pipe.h **** 		pipe_reset(p->pipe);
  56:usb/usb_pipe.h **** 		USB_ep_cancel(p->ep);
  57:usb/usb_pipe.h **** 		p->data->flush = 0;
  58:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
  59:usb/usb_pipe.h **** 		p->data->bank = 0;
  60:usb/usb_pipe.h **** 	}
  61:usb/usb_pipe.h **** }
  62:usb/usb_pipe.h **** 
  63:usb/usb_pipe.h **** static inline void _usb_pipe_ep_start(const USB_Pipe* p, uint8_t* data, uint16_t size) ATTR_ALWAYS_
  64:usb/usb_pipe.h **** static inline void _usb_pipe_ep_start(const USB_Pipe* p, uint8_t* data, uint16_t size){
  65:usb/usb_pipe.h **** 	bool bank = 0;
  66:usb/usb_pipe.h **** 
  67:usb/usb_pipe.h **** 	if (p->ep & USB_EP_PP){
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
  70:usb/usb_pipe.h **** 	}
  71:usb/usb_pipe.h **** 
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
  73:usb/usb_pipe.h **** 		USB_ep_start_bank(p->ep, 0, data, size);
  74:usb/usb_pipe.h **** 	}else{
  75:usb/usb_pipe.h **** 		USB_ep_start_bank(p->ep, 1, data, size);
  76:usb/usb_pipe.h **** 	}
  77:usb/usb_pipe.h **** }
  78:usb/usb_pipe.h **** 
  79:usb/usb_pipe.h **** static inline void usb_pipe_handle(const USB_Pipe* p){
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 328               		.loc 2 80 0
 329 0106 2FB7      		in r18,__SREG__
 330               	.LVL7:
 331               	.LBB482:
 332               	.LBB483:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 333               		.loc 3 50 0
 334               	/* #APP */
 335               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 336 0108 F894      		cli
 337               	 ;  0 "" 2
 338               	.LVL8:
 339               	/* #NOAPP */
 340               	.LBE483:
 341               	.LBE482:
 342               	.LBB484:
 343               	.LBB485:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 344               		.loc 5 220 0
 345 010a 8091 0000 		lds r24,endpoints+24
 346 010e 8670      		andi r24,lo8(6)
 347               	.LBE485:
 348               	.LBE484:
  81:usb/usb_pipe.h **** 		if (p->ep & USB_EP_IN){
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 349               		.loc 2 82 0
 350 0110 01F4      		brne .L26
 351               	.LVL9:
 352               	.L12:
 353               	.LBB486:
 354               	.LBB487:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 355               		.loc 3 70 0
 356 0112 2FBF      		out __SREG__,r18
 357               		.loc 3 71 0
 358               	.LBE487:
 359               	.LBE486:
 360               	.LBE481:
 361               	.LBE480:
 362               	.LBE479:
 363               	.LBB525:
 364               	.LBB526:
 314:usb/usb.h     **** 	}
 315:usb/usb.h     **** }
 316:usb/usb.h     **** 
 317:usb/usb.h     **** inline void USB_Task(void) ATTR_ALWAYS_INLINE;
 318:usb/usb.h     **** inline void USB_Task(void){
 319:usb/usb.h     **** 	// Read once to prevent race condition where SETUP packet is interpreted as OUT
 320:usb/usb.h     **** 	uint8_t status = endpoints[0].out.STATUS;
 365               		.loc 5 320 0
 366 0114 8091 0000 		lds r24,endpoints
 367               	.LVL10:
 321:usb/usb.h     **** 
 322:usb/usb.h     **** 	if (status & USB_EP_SETUP_bm){
 368               		.loc 5 322 0
 369 0118 84FD      		sbrc r24,4
 370 011a 00C0      		rjmp .L27
 371               	.L21:
 323:usb/usb.h     **** 		if (!USB_HandleSetup()){
 324:usb/usb.h     **** 			endpoints[0].out.CTRL |= USB_EP_STALL_bm;
 325:usb/usb.h     **** 			endpoints[0].in.CTRL |= USB_EP_STALL_bm; 
 326:usb/usb.h     **** 		}
 327:usb/usb.h     **** 		USB_ep0_enableOut();
 328:usb/usb.h     **** 	}else if(status & USB_EP_TRNCOMPL0_bm){
 372               		.loc 5 328 0
 373 011c 85FD      		sbrc r24,5
 374 011e 00C0      		rjmp .L28
 375               	.LVL11:
 376               	.L11:
 377               	/* epilogue start */
 378               	.LBE526:
 379               	.LBE525:
  56:Framework.h   **** 	usb_pipe_handle(&ep_in);
  57:Framework.h   **** 	USB_Task();
  58:Framework.h   **** }
 380               		.loc 1 58 0
 381 0120 FF91      		pop r31
 382 0122 EF91      		pop r30
 383 0124 BF91      		pop r27
 384 0126 AF91      		pop r26
 385 0128 9F91      		pop r25
 386 012a 8F91      		pop r24
 387 012c 7F91      		pop r23
 388 012e 6F91      		pop r22
 389 0130 5F91      		pop r21
 390 0132 4F91      		pop r20
 391 0134 3F91      		pop r19
 392 0136 2F91      		pop r18
 393 0138 0F91      		pop r16
 394 013a 0F90      		pop r0
 395 013c 0FBE      		out __SREG__,r0
 396 013e 0F90      		pop r0
 397 0140 1F90      		pop r1
 398 0142 1895      		reti
 399               	.LVL12:
 400               	.L26:
 401               	.LBB535:
 402               	.LBB522:
 403               	.LBB519:
 404               	.LBB489:
 405               	.LBB490:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 406               		.loc 4 51 0
 407 0144 3091 0000 		lds r19,ep_in_pipe_data+4
 408               	.LBE490:
 409               	.LBE489:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 410               		.loc 2 83 0
 411 0148 1316      		cp __zero_reg__,r19
 412 014a 04F0      		brlt .+2
 413 014c 00C0      		rjmp .L13
 414               	.LBB491:
 415               	.LBB492:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 416               		.loc 4 62 0
 417 014e 8091 0000 		lds r24,ep_in_pipe_data
 418 0152 9091 0000 		lds r25,ep_in_pipe_data+1
 419               	.LVL13:
 420               	.LBE492:
 421               	.LBE491:
 422               	.LBB493:
 423               	.LBB494:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 424               		.loc 2 68 0
 425 0156 4091 0000 		lds r20,ep_in_data
 426               	.LVL14:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 427               		.loc 2 69 0
 428 015a 51E0      		ldi r21,lo8(1)
 429 015c 4130      		cpi r20,lo8(1)
 430 015e 01F4      		brne .+2
 431 0160 00C0      		rjmp .L29
 432 0162 5093 0000 		sts ep_in_data,r21
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 433               		.loc 2 72 0
 434 0166 4423      		tst r20
 435 0168 01F4      		brne .+2
 436 016a 00C0      		rjmp .L30
 437               	.L15:
 438               	.LVL15:
 439               	.LBB495:
 440               	.LBB496:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 441               		.loc 5 168 0
 442 016c 8093 0000 		sts endpoints+20,r24
 443 0170 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 444               		.loc 5 169 0
 445 0174 40E4      		ldi r20,lo8(64)
 446 0176 50E0      		ldi r21,hi8(64)
 447 0178 4093 0000 		sts endpoints+18,r20
 448 017c 5093 0000 		sts endpoints+18+1,r21
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 449               		.loc 5 176 0
 450 0180 E0E0      		ldi r30,lo8(endpoints+24)
 451 0182 F0E0      		ldi r31,hi8(endpoints+24)
 452               	/* #APP */
 453               	 ;  176 "usb/usb.h" 1
 454 0184 04E1      		ldi r16, 20
 455 0186 0693      		.dc.w 0x9306
 456               		
 457               	 ;  0 "" 2
 458               	.LVL16:
 459               	/* #NOAPP */
 460               	.L16:
 461               	.LBE496:
 462               	.LBE495:
 463               	.LBE494:
 464               	.LBE493:
 465               	.LBB500:
 466               	.LBB501:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 467               		.loc 4 72 0
 468 0188 3150      		subi r19,lo8(-(-1))
 469 018a 3093 0000 		sts ep_in_pipe_data+4,r19
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 470               		.loc 4 73 0
 471 018e 805C      		subi r24,lo8(-(64))
 472 0190 9F4F      		sbci r25,hi8(-(64))
 473 0192 8093 0000 		sts ep_in_pipe_data,r24
 474 0196 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 475               		.loc 4 75 0
 476 019a 30E0      		ldi r19,hi8(ep_in_pipe_buffer+512)
 477 019c 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 478 019e 9307      		cpc r25,r19
 479 01a0 01F0      		breq .+2
 480 01a2 00C0      		rjmp .L12
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
 481               		.loc 4 76 0
 482 01a4 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 483 01a6 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 484 01a8 8093 0000 		sts ep_in_pipe_data,r24
 485 01ac 9093 0000 		sts ep_in_pipe_data+1,r25
 486               	.LBE501:
 487               	.LBE500:
 488               	.LBB502:
 489               	.LBB488:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 490               		.loc 3 70 0
 491 01b0 2FBF      		out __SREG__,r18
 492               		.loc 3 71 0
 493               	.LBE488:
 494               	.LBE502:
 495               	.LBE519:
 496               	.LBE522:
 497               	.LBE535:
 498               	.LBB536:
 499               	.LBB533:
 320:usb/usb.h     **** 	uint8_t status = endpoints[0].out.STATUS;
 500               		.loc 5 320 0
 501 01b2 8091 0000 		lds r24,endpoints
 502               	.LVL17:
 322:usb/usb.h     **** 	if (status & USB_EP_SETUP_bm){
 503               		.loc 5 322 0
 504 01b6 84FF      		sbrs r24,4
 505 01b8 00C0      		rjmp .L21
 506               	.LVL18:
 507               	.L27:
 323:usb/usb.h     **** 		if (!USB_HandleSetup()){
 508               		.loc 5 323 0
 509 01ba 0E94 0000 		call USB_HandleSetup
 510               	.LVL19:
 511 01be 8823      		tst r24
 512 01c0 01F4      		brne .L24
 324:usb/usb.h     **** 			endpoints[0].out.CTRL |= USB_EP_STALL_bm;
 513               		.loc 5 324 0
 514 01c2 8091 0000 		lds r24,endpoints+1
 515 01c6 8460      		ori r24,lo8(4)
 516 01c8 8093 0000 		sts endpoints+1,r24
 325:usb/usb.h     **** 			endpoints[0].in.CTRL |= USB_EP_STALL_bm; 
 517               		.loc 5 325 0
 518 01cc 8091 0000 		lds r24,endpoints+9
 519 01d0 8460      		ori r24,lo8(4)
 520 01d2 8093 0000 		sts endpoints+9,r24
 521               	.L24:
 522               	.LBB527:
 523               	.LBB528:
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 524               		.loc 5 280 0
 525 01d6 E0E0      		ldi r30,lo8(endpoints)
 526 01d8 F0E0      		ldi r31,hi8(endpoints)
 527               	/* #APP */
 528               	 ;  280 "usb/usb.h" 1
 529 01da 02E7      		ldi r16, 114
 530 01dc 0693      		.dc.w 0x9306
 531               		
 532               	 ;  0 "" 2
 533               	/* #NOAPP */
 534 01de 00C0      		rjmp .L11
 535               	.LVL20:
 536               	.L29:
 537               	.LBE528:
 538               	.LBE527:
 539               	.LBE533:
 540               	.LBE536:
 541               	.LBB537:
 542               	.LBB523:
 543               	.LBB520:
 544               	.LBB503:
 545               	.LBB499:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 546               		.loc 2 69 0
 547 01e0 50E0      		ldi r21,lo8(0)
 548 01e2 5093 0000 		sts ep_in_data,r21
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 549               		.loc 2 72 0
 550 01e6 4423      		tst r20
 551 01e8 01F0      		breq .+2
 552 01ea 00C0      		rjmp .L15
 553               	.L30:
 554               	.LVL21:
 555               	.LBB497:
 556               	.LBB498:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 557               		.loc 5 168 0
 558 01ec 8093 0000 		sts endpoints+28,r24
 559 01f0 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 560               		.loc 5 169 0
 561 01f4 40E4      		ldi r20,lo8(64)
 562 01f6 50E0      		ldi r21,hi8(64)
 563               	.LVL22:
 564 01f8 4093 0000 		sts endpoints+26,r20
 565 01fc 5093 0000 		sts endpoints+26+1,r21
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 566               		.loc 5 174 0
 567 0200 E0E0      		ldi r30,lo8(endpoints+24)
 568 0202 F0E0      		ldi r31,hi8(endpoints+24)
 569               	.LVL23:
 570               	/* #APP */
 571               	 ;  174 "usb/usb.h" 1
 572 0204 02E2      		ldi r16, 34
 573 0206 0693      		.dc.w 0x9306
 574               		
 575               	 ;  0 "" 2
 576               	/* #NOAPP */
 577 0208 00C0      		rjmp .L16
 578               	.LVL24:
 579               	.L28:
 580               	.LBE498:
 581               	.LBE497:
 582               	.LBE499:
 583               	.LBE503:
 584               	.LBE520:
 585               	.LBE523:
 586               	.LBE537:
 587               	.LBB538:
 588               	.LBB534:
 329:usb/usb.h     **** 		EVENT_USB_Device_ControlOUT((uint8_t *) ep0_buf_out, endpoints[0].out.CNT);
 589               		.loc 5 329 0
 590 020a 4091 0000 		lds r20,endpoints+2
 591 020e 5091 0000 		lds r21,endpoints+2+1
 592               	.LVL25:
 593               	.LBB530:
 594               	.LBB531:
 595               		.file 6 "main.c"
   1:main.c        **** #include "Framework.h"
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <inttypes.h>
   4:main.c        **** #include <stdio.h> 
   5:main.c        **** #include <stdlib.h>
   6:main.c        **** #include <util/delay.h>
   7:main.c        **** #include <string.h> 
   8:main.c        **** #include <math.h>
   9:main.c        **** #include "utils/utils.h"
  10:main.c        **** #include "nmea/nmea.h"
  11:main.c        **** #include "uart/uart.h"
  12:main.c        **** #include "gps/gps.h"
  13:main.c        **** #include "gprs/gprs.h"
  14:main.c        **** #include "sms/sms.h"
  15:main.c        **** 
  16:main.c        **** #define HIGH_FREQ 1
  17:main.c        **** #define LOW_FREQ 0
  18:main.c        **** 
  19:main.c        **** const uint16_t low_freq = 1000*30;
  20:main.c        **** const uint16_t high_freq = 1000*30;
  21:main.c        **** uint8_t freq = 0; // 0 --> low_freq, 1 --> high_freq
  22:main.c        **** char* phonenumber = "+18572080246";
  23:main.c        **** char* twilio_number = "+13042493059";
  24:main.c        **** char *message;
  25:main.c        **** bool updating = false;
  26:main.c        **** uint8_t count;
  27:main.c        **** latlng gps;
  28:main.c        **** 
  29:main.c        **** int main(void){
  30:main.c        **** 
  31:main.c        ****   //usb configuration
  32:main.c        **** 	USB_ConfigureClock();
  33:main.c        **** 	USB_Init();
  34:main.c        **** 	USB.INTCTRLA = USB_BUSEVIE_bm | USB_INTLVL_MED_gc;
  35:main.c        **** 	USB.INTCTRLB = USB_TRNIE_bm | USB_SETUPIE_bm;
  36:main.c        **** 	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
  37:main.c        **** 	sei();
  38:main.c        **** 
  39:main.c        ****   if (true) {
  40:main.c        ****   	//USART, PORT, TXPIN_bm
  41:main.c        ****     gprs_init(&USARTC0, &PORTC, PIN3_bm);
  42:main.c        ****   }
  43:main.c        ****   
  44:main.c        ****   //uart init code -- change condition to true when we're ready to communicate with the gps
  45:main.c        **** 	if (true) {
  46:main.c        **** 		//USART, PORT, POWERPIN_bm, TXPIN_bm, RESETPIN_bm
  47:main.c        **** 		gps_init(&USARTD0, &PORTD, PIN0_bm, PIN3_bm, PIN4_bm);
  48:main.c        **** 	}
  49:main.c        **** 
  50:main.c        **** 
  51:main.c        ****   //call break and flush to make sure the buffer is cleared
  52:main.c        **** 	// break_and_flush();
  53:main.c        **** 
  54:main.c        ****   // parse nmea string and send result over usb
  55:main.c        ****   // char* text_message = parse_nmea();
  56:main.c        **** 	// char* text_message = "Whatsup?";
  57:main.c        ****   // send_message(phonenumber, text_message, &USARTC0);
  58:main.c        ****   // send_message(twilio_number, text_message, &USARTD0);
  59:main.c        ****   // SimpleReceive(&USARTD0);
  60:main.c        **** 
  61:main.c        **** 	for (;;){
  62:main.c        ****     gps_receive(&USARTD0, &gps);
  63:main.c        ****     if (gps.valid) {
  64:main.c        ****     	if (gps.roaming) {
  65:main.c        **** 		  	send_message(phonenumber, gps.sms, &USARTC0);
  66:main.c        ****       	send_message(twilio_number, gps.sms, &USARTC0);
  67:main.c        ****       	freq = HIGH_FREQ;
  68:main.c        ****     	} else {
  69:main.c        ****     		freq = LOW_FREQ;
  70:main.c        ****     	}
  71:main.c        ****     }
  72:main.c        ****     if (freq == HIGH_FREQ) {
  73:main.c        ****     	_delay_ms(high_freq);
  74:main.c        ****     } else {
  75:main.c        ****     	_delay_ms(low_freq);
  76:main.c        ****     }
  77:main.c        **** 	}
  78:main.c        **** }
  79:main.c        **** 
  80:main.c        **** #define stringify(s) #s
  81:main.c        **** 
  82:main.c        **** const char PROGMEM hwversion[] = stringify(HW_VERSION);
  83:main.c        **** const char PROGMEM fwversion[] = stringify(FW_VERSION);
  84:main.c        **** 
  85:main.c        **** uint8_t usb_cmd = 0;
  86:main.c        **** uint8_t cmd_data = 0;
  87:main.c        **** 
  88:main.c        **** // void send_usb_data(char *message) {
  89:main.c        **** // 	for (uint8_t = 0; i < 64; i++) ep0_buf_in[i] = 0;
  90:main.c        **** // 	int l = strlen(message);
  91:main.c        **** // 	for (int i=0; i<l; i++) {
  92:main.c        **** // 		ep0_buf_in[i] = message[i];
  93:main.c        **** // 	}
  94:main.c        **** // }
  95:main.c        **** 
  96:main.c        **** /** Event handler for the library USB Control Request reception event. */
  97:main.c        **** bool EVENT_USB_Device_ControlRequest(USB_Request_Header_t* req){
  98:main.c        **** 	// zero out ep0_buf_in
  99:main.c        **** 	for (uint8_t i = 0; i < 64; i++) ep0_buf_in[i] = 0;
 100:main.c        **** 	usb_cmd = 0;
 101:main.c        **** 	if ((req->bmRequestType & CONTROL_REQTYPE_TYPE) == REQTYPE_VENDOR){
 102:main.c        **** 		switch(req->bRequest){
 103:main.c        **** 			case 0x00: // Info
 104:main.c        **** 				if (req->wIndex == 0){
 105:main.c        **** 					USB_ep0_send_progmem((uint8_t*)hwversion, sizeof(hwversion));
 106:main.c        **** 				}else if (req->wIndex == 1){
 107:main.c        **** 					USB_ep0_send_progmem((uint8_t*)fwversion, sizeof(fwversion));
 108:main.c        **** 				}
 109:main.c        **** 				return true;
 110:main.c        **** 			case 0x02:
 111:main.c        **** 				{
 112:main.c        **** 					int l = strlen(message);
 113:main.c        **** 					for (uint8_t i=0; i<64; i++) {
 114:main.c        **** 						ep0_buf_in[i] = message[i];
 115:main.c        **** 					}
 116:main.c        **** 					USB_ep0_send(l);
 117:main.c        **** 					return true;
 118:main.c        **** 				}
 119:main.c        **** 			case 0x08:
 120:main.c        **** 				* ((uint8_t *) req->wIndex) = req->wValue;
 121:main.c        **** 				USB_ep0_send(0);
 122:main.c        **** 				return true;
 123:main.c        **** 			case 0x09:
 124:main.c        **** 				ep0_buf_in[0] = * ((uint8_t *) req->wIndex);
 125:main.c        **** 				USB_ep0_send(1);
 126:main.c        **** 				return true;
 127:main.c        **** 			case 0x16:
 128:main.c        **** 				* ((uint16_t *) req->wIndex) = req->wValue;
 129:main.c        **** 				USB_ep0_send(0);
 130:main.c        **** 				return true;
 131:main.c        **** 			case 0x17:{
 132:main.c        **** 				uint16_t *addr;
 133:main.c        **** 				addr = (uint16_t *) req->wIndex;
 134:main.c        **** 				ep0_buf_in[0] = *addr & 0xFF;
 135:main.c        **** 				ep0_buf_in[1] = *addr >> 8;
 136:main.c        **** 				USB_ep0_send(2);}
 137:main.c        **** 				return true;
 138:main.c        **** 			// read EEPROM	
 139:main.c        **** 			case 0xE0: 
 140:main.c        **** 				eeprom_read_block(ep0_buf_in, (void*)(req->wIndex*64), 64);
 141:main.c        **** 				USB_ep0_send(64);
 142:main.c        **** 				return true;
 143:main.c        **** 
 144:main.c        **** 			// write EEPROM	
 145:main.c        **** 			case 0xE1: 
 146:main.c        **** 				usb_cmd = req->bRequest;
 147:main.c        **** 				cmd_data = req->wIndex;
 148:main.c        **** 				USB_ep0_send(0);
 149:main.c        **** 				return true; // Wait for OUT data (expecting an OUT transfer)
 150:main.c        **** 
 151:main.c        **** 			// disconnect from USB, jump to bootloader	
 152:main.c        **** 			case 0xBB: 
 153:main.c        **** 				USB_enter_bootloader();
 154:main.c        **** 				return true;
 155:main.c        **** 		}
 156:main.c        **** 	}
 157:main.c        **** 	return false;
 158:main.c        **** }
 159:main.c        **** 
 160:main.c        **** void EVENT_USB_Device_ControlOUT(uint8_t* buf, uint8_t count){
 161:main.c        **** 	switch (usb_cmd){
 596               		.loc 6 161 0
 597 0212 8091 0000 		lds r24,usb_cmd
 598               	.LVL26:
 599 0216 813E      		cpi r24,lo8(-31)
 600 0218 01F4      		brne .L24
 162:main.c        **** 		case 0xE1: // Write EEPROM
 163:main.c        **** 			eeprom_update_block(buf, (void*)(cmd_data*64), count);
 601               		.loc 6 163 0
 602 021a 6091 0000 		lds r22,cmd_data
 603 021e 70E0      		ldi r23,lo8(0)
 604 0220 0024      		clr __tmp_reg__
 605 0222 7695      		lsr r23
 606 0224 6795      		ror r22
 607 0226 0794      		ror __tmp_reg__
 608 0228 7695      		lsr r23
 609 022a 6795      		ror r22
 610 022c 0794      		ror __tmp_reg__
 611 022e 762F      		mov r23,r22
 612 0230 602D      		mov r22,__tmp_reg__
 613 0232 80E0      		ldi r24,lo8(ep0_buf_out)
 614 0234 90E0      		ldi r25,hi8(ep0_buf_out)
 615 0236 50E0      		ldi r21,lo8(0)
 616 0238 0E94 0000 		call __eeupd_block_x32a4u
 617               	.LVL27:
 618               	.LBE531:
 619               	.LBE530:
 620               	.LBB532:
 621               	.LBB529:
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 622               		.loc 5 280 0
 623 023c E0E0      		ldi r30,lo8(endpoints)
 624 023e F0E0      		ldi r31,hi8(endpoints)
 625               	/* #APP */
 626               	 ;  280 "usb/usb.h" 1
 627 0240 02E7      		ldi r16, 114
 628 0242 0693      		.dc.w 0x9306
 629               		
 630               	 ;  0 "" 2
 631               	/* #NOAPP */
 632 0244 00C0      		rjmp .L11
 633               	.LVL28:
 634               	.L13:
 635               	.LBE529:
 636               	.LBE532:
 637               	.LBE534:
 638               	.LBE538:
 639               	.LBB539:
 640               	.LBB524:
 641               	.LBB521:
  84:usb/usb_pipe.h **** 					_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->pipe->size);
  85:usb/usb_pipe.h **** 					pipe_done_read(p->pipe);
  86:usb/usb_pipe.h **** 				}else if (p->features & PIPE_ENABLE_FLUSH){
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 642               		.loc 2 87 0
 643 0246 8091 0000 		lds r24,ep_in_data+1
 644 024a 8130      		cpi r24,lo8(1)
 645 024c 01F0      		breq .L31
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
  89:usb/usb_pipe.h **** 						// Send short packet
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 646               		.loc 2 91 0
 647 024e 8230      		cpi r24,lo8(2)
 648 0250 01F0      		breq .+2
 649 0252 00C0      		rjmp .L12
 650               	.LVL29:
 651               	.LBB504:
 652               	.LBB505:
 653               	.LBB506:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 654               		.loc 5 228 0
 655 0254 8091 0000 		lds r24,endpoints+24
 656 0258 8670      		andi r24,lo8(6)
 657               	.LBE506:
 658               	.LBE505:
 659               	.LBE504:
 660               		.loc 2 91 0
 661 025a 8630      		cpi r24,lo8(6)
 662 025c 01F0      		breq .+2
 663 025e 00C0      		rjmp .L12
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 664               		.loc 2 92 0
 665 0260 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 666               		.loc 2 93 0
 667 0264 1092 0000 		sts ep_in_data+2,__zero_reg__
 668 0268 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 669               	.LBB507:
 670               	.LBB508:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 671               		.loc 4 90 0
 672 026c 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 673               		.loc 4 91 0
 674 0270 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 675 0272 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 676 0274 8093 0000 		sts ep_in_pipe_data+2,r24
 677 0278 9093 0000 		sts ep_in_pipe_data+2+1,r25
 678 027c 8093 0000 		sts ep_in_pipe_data,r24
 679 0280 9093 0000 		sts ep_in_pipe_data+1,r25
 680               	.LVL30:
 681 0284 00C0      		rjmp .L12
 682               	.LVL31:
 683               	.L31:
 684               	.LBE508:
 685               	.LBE507:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 686               		.loc 2 88 0
 687 0286 82E0      		ldi r24,lo8(2)
 688 0288 8093 0000 		sts ep_in_data+1,r24
 689               	.LBB509:
 690               	.LBB510:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 691               		.loc 4 62 0
 692 028c 7091 0000 		lds r23,ep_in_pipe_data
 693 0290 6091 0000 		lds r22,ep_in_pipe_data+1
 694               	.LBE510:
 695               	.LBE509:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 696               		.loc 2 90 0
 697 0294 8091 0000 		lds r24,ep_in_data+2
 698 0298 9091 0000 		lds r25,ep_in_data+2+1
 699               	.LVL32:
 700               	.LBB511:
 701               	.LBB512:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 702               		.loc 2 68 0
 703 029c 3091 0000 		lds r19,ep_in_data
 704               	.LVL33:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 705               		.loc 2 69 0
 706 02a0 41E0      		ldi r20,lo8(1)
 707 02a2 3130      		cpi r19,lo8(1)
 708 02a4 01F0      		breq .L32
 709               	.L19:
 710 02a6 4093 0000 		sts ep_in_data,r20
 711               	.LBB513:
 712               	.LBB514:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 713               		.loc 5 168 0
 714 02aa 472F      		mov r20,r23
 715 02ac 562F      		mov r21,r22
 716               	.LBE514:
 717               	.LBE513:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 718               		.loc 2 72 0
 719 02ae 3323      		tst r19
 720 02b0 01F4      		brne .L20
 721               	.LVL34:
 722               	.LBB516:
 723               	.LBB515:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 724               		.loc 5 168 0
 725 02b2 4093 0000 		sts endpoints+28,r20
 726 02b6 5093 0000 		sts endpoints+28+1,r21
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 727               		.loc 5 169 0
 728 02ba 8093 0000 		sts endpoints+26,r24
 729 02be 9093 0000 		sts endpoints+26+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 730               		.loc 5 174 0
 731 02c2 E0E0      		ldi r30,lo8(endpoints+24)
 732 02c4 F0E0      		ldi r31,hi8(endpoints+24)
 733               	.LVL35:
 734               	/* #APP */
 735               	 ;  174 "usb/usb.h" 1
 736 02c6 02E2      		ldi r16, 34
 737 02c8 0693      		.dc.w 0x9306
 738               		
 739               	 ;  0 "" 2
 740               	/* #NOAPP */
 741 02ca 00C0      		rjmp .L12
 742               	.LVL36:
 743               	.L20:
 744               	.LBE515:
 745               	.LBE516:
 746               	.LBB517:
 747               	.LBB518:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 748               		.loc 5 168 0
 749 02cc 4093 0000 		sts endpoints+20,r20
 750 02d0 5093 0000 		sts endpoints+20+1,r21
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 751               		.loc 5 169 0
 752 02d4 8093 0000 		sts endpoints+18,r24
 753 02d8 9093 0000 		sts endpoints+18+1,r25
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 754               		.loc 5 176 0
 755 02dc E0E0      		ldi r30,lo8(endpoints+24)
 756 02de F0E0      		ldi r31,hi8(endpoints+24)
 757               	/* #APP */
 758               	 ;  176 "usb/usb.h" 1
 759 02e0 04E1      		ldi r16, 20
 760 02e2 0693      		.dc.w 0x9306
 761               		
 762               	 ;  0 "" 2
 763               	/* #NOAPP */
 764 02e4 00C0      		rjmp .L12
 765               	.LVL37:
 766               	.L32:
 767               	.LBE518:
 768               	.LBE517:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 769               		.loc 2 69 0
 770 02e6 40E0      		ldi r20,lo8(0)
 771 02e8 00C0      		rjmp .L19
 772               	.LBE512:
 773               	.LBE511:
 774               	.LBE521:
 775               	.LBE524:
 776               	.LBE539:
 777               		.cfi_endproc
 778               	.LFE59:
 780               	.global	send_string
 782               	send_string:
 783               	.LFB61:
 784               		.file 7 "utils/utils.h"
   1:utils/utils.h **** void send_string(char* s);
   2:utils/utils.h **** char* concat(char*, char*);
   3:utils/utils.h **** 
   4:utils/utils.h **** void send_string(char* s) {
 785               		.loc 7 4 0
 786               		.cfi_startproc
 787               	.LVL38:
 788 02ea AF92      		push r10
 789               	.LCFI29:
 790               		.cfi_def_cfa_offset 3
 791               		.cfi_offset 10, -2
 792 02ec BF92      		push r11
 793               	.LCFI30:
 794               		.cfi_def_cfa_offset 4
 795               		.cfi_offset 11, -3
 796 02ee CF92      		push r12
 797               	.LCFI31:
 798               		.cfi_def_cfa_offset 5
 799               		.cfi_offset 12, -4
 800 02f0 DF92      		push r13
 801               	.LCFI32:
 802               		.cfi_def_cfa_offset 6
 803               		.cfi_offset 13, -5
 804 02f2 EF92      		push r14
 805               	.LCFI33:
 806               		.cfi_def_cfa_offset 7
 807               		.cfi_offset 14, -6
 808 02f4 FF92      		push r15
 809               	.LCFI34:
 810               		.cfi_def_cfa_offset 8
 811               		.cfi_offset 15, -7
 812 02f6 0F93      		push r16
 813               	.LCFI35:
 814               		.cfi_def_cfa_offset 9
 815               		.cfi_offset 16, -8
 816 02f8 1F93      		push r17
 817               	.LCFI36:
 818               		.cfi_def_cfa_offset 10
 819               		.cfi_offset 17, -9
 820 02fa CF93      		push r28
 821               	.LCFI37:
 822               		.cfi_def_cfa_offset 11
 823               		.cfi_offset 28, -10
 824 02fc DF93      		push r29
 825               	.LCFI38:
 826               		.cfi_def_cfa_offset 12
 827               		.cfi_offset 29, -11
 828               	/* prologue: function */
 829               	/* frame size = 0 */
 830               	/* stack size = 10 */
 831               	.L__stack_usage = 10
   5:utils/utils.h ****   while (*s != '\0' && s != NULL) {  
 832               		.loc 7 5 0
 833 02fe FC01      		movw r30,r24
 834 0300 2081      		ld r18,Z
 835 0302 2223      		tst r18
 836 0304 01F4      		brne .+2
 837 0306 00C0      		rjmp .L34
 838 0308 0097      		sbiw r24,0
 839 030a 01F4      		brne .+2
 840 030c 00C0      		rjmp .L34
   4:utils/utils.h **** void send_string(char* s) {
 841               		.loc 7 4 0
 842 030e 6C01      		movw r12,r24
 843 0310 0894      		sec
 844 0312 C11C      		adc r12,__zero_reg__
 845 0314 D11C      		adc r13,__zero_reg__
 846               	.LBB705:
 847               	.LBB706:
 848               	.LBB707:
 849               	.LBB708:
 850               	.LBB709:
 851               	.LBB710:
 852               	.LBB711:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 853               		.loc 4 57 0
 854 0316 46E0      		ldi r20,lo8(6)
 855               	.LBE711:
 856               	.LBE710:
 857               	.LBE709:
 858               	.LBE708:
 859               	.LBE707:
 860               	.LBB724:
 861               	.LBB725:
 862               	.LBB726:
 863               	.LBB727:
 864               	.LBB728:
 865               	.LBB729:
 866               	.LBB730:
 867               	.LBB731:
 868               	.LBB732:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 869               		.loc 5 220 0
 870 0318 60E0      		ldi r22,lo8(endpoints+24)
 871 031a 70E0      		ldi r23,hi8(endpoints+24)
 872               	.LBE732:
 873               	.LBE731:
 874               	.LBB734:
 875               	.LBB735:
 876               		.loc 4 91 0
 877 031c 30E0      		ldi r19,lo8(ep_in_pipe_buffer)
 878 031e A32E      		mov r10,r19
 879 0320 30E0      		ldi r19,hi8(ep_in_pipe_buffer)
 880 0322 B32E      		mov r11,r19
 881               	.LBE735:
 882               	.LBE734:
 883               	.LBB738:
 884               	.LBB739:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 885               		.loc 2 69 0
 886 0324 C1E0      		ldi r28,lo8(1)
 887 0326 D0E0      		ldi r29,hi8(1)
 888               	.LBE739:
 889               	.LBE738:
 890               	.LBB748:
 891               	.LBB749:
 892               	.LBB750:
 893               	.LBB751:
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 894               		.loc 5 169 0
 895 0328 50E4      		ldi r21,lo8(64)
 896 032a E52E      		mov r14,r21
 897 032c F12C      		mov r15,__zero_reg__
 898               	.LVL39:
 899               	.L72:
 900               	.LBE751:
 901               	.LBE750:
 902               	.LBE749:
 903               	.LBE748:
 904               	.LBE730:
 905               	.LBE729:
 906               	.LBE728:
 907               	.LBE727:
 908               	.LBE726:
 909               	.LBE725:
 910               	.LBE724:
 911               	.LBB804:
 912               	.LBB722:
 913               	.LBB720:
  94:usb/usb_pipe.h **** 						pipe_reset(p->pipe);
  95:usb/usb_pipe.h **** 					}
  96:usb/usb_pipe.h **** 				}
  97:usb/usb_pipe.h **** 			}
  98:usb/usb_pipe.h **** 		}else{
  99:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep) && pipe_can_write(p->pipe) >= 1){
 100:usb/usb_pipe.h **** 				_usb_pipe_ep_start(p, pipe_write_ptr(p->pipe), p->pipe->size);
 101:usb/usb_pipe.h **** 				pipe_done_write(p->pipe);
 102:usb/usb_pipe.h **** 			}
 103:usb/usb_pipe.h **** 		}
 104:usb/usb_pipe.h **** 	}
 105:usb/usb_pipe.h **** }
 106:usb/usb_pipe.h **** 
 107:usb/usb_pipe.h **** static inline void usb_pipe_flush(const USB_Pipe* p) ATTR_ALWAYS_INLINE;
 108:usb/usb_pipe.h **** static inline void usb_pipe_flush(const USB_Pipe* p){
 109:usb/usb_pipe.h **** 	GCC_ASSERT(p->features&PIPE_ENABLE_FLUSH && p->ep&USB_EP_IN);
 110:usb/usb_pipe.h **** 	p->data->flush = 1;
 111:usb/usb_pipe.h **** 	usb_pipe_handle(p);
 112:usb/usb_pipe.h **** }
 113:usb/usb_pipe.h **** 
 114:usb/usb_pipe.h **** static inline bool usb_pipe_flush_done(const USB_Pipe* p) ATTR_ALWAYS_INLINE;
 115:usb/usb_pipe.h **** static inline bool usb_pipe_flush_done(const USB_Pipe* p){
 116:usb/usb_pipe.h **** 	GCC_ASSERT(p->features&PIPE_ENABLE_FLUSH);
 117:usb/usb_pipe.h **** 	return p->data->flush;
 118:usb/usb_pipe.h **** }
 119:usb/usb_pipe.h **** 
 120:usb/usb_pipe.h **** static inline bool usb_pipe_can_write(const USB_Pipe* p) ATTR_ALWAYS_INLINE;
 121:usb/usb_pipe.h **** static inline bool usb_pipe_can_write(const USB_Pipe* p){
 122:usb/usb_pipe.h **** 	bool r;
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 914               		.loc 2 123 0
 915 032e 9FB7      		in r25,__SREG__
 916               	.LVL40:
 917               	.LBB713:
 918               	.LBB714:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 919               		.loc 3 50 0
 920               	/* #APP */
 921               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 922 0330 F894      		cli
 923               	 ;  0 "" 2
 924               	.LVL41:
 925               	/* #NOAPP */
 926               	.LBE714:
 927               	.LBE713:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 928               		.loc 2 124 0
 929 0332 8091 0000 		lds r24,ep_in_data+1
 930 0336 8823      		tst r24
 931 0338 01F0      		breq .L74
 932               	.L64:
 125:usb/usb_pipe.h **** 			r = false;
 933               		.loc 2 125 0
 934 033a 80E0      		ldi r24,lo8(0)
 935               	.L35:
 936               	.LBB716:
 937               	.LBB717:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 938               		.loc 3 70 0
 939 033c 9FBF      		out __SREG__,r25
 940               		.loc 3 71 0
 941               	.LBE717:
 942               	.LBE716:
 943               	.LBE720:
 944               	.LBE722:
 945               	.LBE804:
  20:Framework.h   ****     while (!usb_pipe_can_write(&ep_in));
 946               		.loc 1 20 0
 947 033e 8823      		tst r24
 948 0340 01F0      		breq .L72
 949               	.LVL42:
 950               	.LBB805:
 951               	.LBB806:
 126:usb/usb_pipe.h **** 		}else{
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 128:usb/usb_pipe.h **** 		}
 129:usb/usb_pipe.h **** 	}
 130:usb/usb_pipe.h **** 	return r;
 131:usb/usb_pipe.h **** }
 132:usb/usb_pipe.h **** 
 133:usb/usb_pipe.h **** static inline uint8_t* usb_pipe_write_ptr(const USB_Pipe* p){
 134:usb/usb_pipe.h **** 	return pipe_write_ptr(p->pipe);
 135:usb/usb_pipe.h **** }
 136:usb/usb_pipe.h **** 
 137:usb/usb_pipe.h **** static inline void usb_pipe_done_write(const USB_Pipe* p){
 138:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 139:usb/usb_pipe.h **** 		pipe_done_write(p->pipe);
 140:usb/usb_pipe.h **** 	}
 141:usb/usb_pipe.h **** }
 142:usb/usb_pipe.h **** 
 143:usb/usb_pipe.h **** static inline bool usb_pipe_can_read(const USB_Pipe* p) ATTR_ALWAYS_INLINE;
 144:usb/usb_pipe.h **** static inline bool usb_pipe_can_read(const USB_Pipe* p){
 145:usb/usb_pipe.h **** 	bool r;
 146:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 147:usb/usb_pipe.h **** 		r = pipe_can_read(p->pipe) > 0;
 148:usb/usb_pipe.h **** 	}
 149:usb/usb_pipe.h **** 	return r;
 150:usb/usb_pipe.h **** }
 151:usb/usb_pipe.h **** 
 152:usb/usb_pipe.h **** static inline uint8_t* usb_pipe_read_ptr(const USB_Pipe* p){
 153:usb/usb_pipe.h **** 	return pipe_read_ptr(p->pipe);
 154:usb/usb_pipe.h **** }
 155:usb/usb_pipe.h **** 
 156:usb/usb_pipe.h **** static inline void usb_pipe_done_read(const USB_Pipe* p){
 157:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 158:usb/usb_pipe.h **** 		pipe_done_read(p->pipe);
 159:usb/usb_pipe.h **** 	}
 160:usb/usb_pipe.h **** }
 161:usb/usb_pipe.h **** 
 162:usb/usb_pipe.h **** static inline uint8_t usb_pipe_read_byte(const USB_Pipe* p){
 163:usb/usb_pipe.h **** 	uint8_t r = p->pipe->data->read_ptr[p->data->packet_offset++];
 164:usb/usb_pipe.h **** 	if (p->data->packet_offset == p->pipe->size){
 165:usb/usb_pipe.h **** 		ATOMIC_BLOCK(PIPE_ATOMIC){
 166:usb/usb_pipe.h **** 			p->data->packet_offset = 0;
 167:usb/usb_pipe.h **** 			pipe_done_read(p->pipe);
 168:usb/usb_pipe.h **** 			usb_pipe_handle(p);
 169:usb/usb_pipe.h **** 		}
 170:usb/usb_pipe.h **** 	}
 171:usb/usb_pipe.h **** 	return r;
 172:usb/usb_pipe.h **** }
 173:usb/usb_pipe.h **** 
 174:usb/usb_pipe.h **** static inline void usb_pipe_write_byte(const USB_Pipe* p, uint8_t v){
 175:usb/usb_pipe.h **** 	p->pipe->data->write_ptr[p->data->packet_offset++] = v;
 952               		.loc 2 175 0
 953 0342 8091 0000 		lds r24,ep_in_data+2
 954 0346 9091 0000 		lds r25,ep_in_data+2+1
 955 034a E091 0000 		lds r30,ep_in_pipe_data+2
 956 034e F091 0000 		lds r31,ep_in_pipe_data+2+1
 957 0352 E80F      		add r30,r24
 958 0354 F91F      		adc r31,r25
 959 0356 2083      		st Z,r18
 960 0358 0196      		adiw r24,1
 961 035a 8093 0000 		sts ep_in_data+2,r24
 962 035e 9093 0000 		sts ep_in_data+2+1,r25
 176:usb/usb_pipe.h **** 	if (p->data->packet_offset == p->pipe->size){
 963               		.loc 2 176 0
 964 0362 8034      		cpi r24,64
 965 0364 9105      		cpc r25,__zero_reg__
 966 0366 01F0      		breq .L75
 967               	.LBE806:
 968               	.LBE805:
 969               	.LBE706:
 970               	.LBE705:
 971               		.loc 7 5 0
 972 0368 F601      		movw r30,r12
 973 036a 2191      		ld r18,Z+
 974               	.LVL43:
 975 036c 2223      		tst r18
 976 036e 01F4      		brne .+2
 977 0370 00C0      		rjmp .L34
 978               	.LVL44:
 979               	.L77:
 980               		.loc 7 5 0 is_stmt 0 discriminator 2
 981 0372 C114      		cp r12,__zero_reg__
 982 0374 D104      		cpc r13,__zero_reg__
 983 0376 01F4      		brne .+2
 984 0378 00C0      		rjmp .L34
 985               		.loc 7 5 0
 986 037a 6F01      		movw r12,r30
 987               	.LBB814:
 988               	.LBB811:
 989               	.LBB807:
 990               	.LBB723:
 991               	.LBB721:
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 992               		.loc 2 123 0 is_stmt 1
 993 037c 9FB7      		in r25,__SREG__
 994               	.LVL45:
 995               	.LBB718:
 996               	.LBB715:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 997               		.loc 3 50 0
 998               	/* #APP */
 999               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 1000 037e F894      		cli
 1001               	 ;  0 "" 2
 1002               	/* #NOAPP */
 1003               	.LBE715:
 1004               	.LBE718:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 1005               		.loc 2 124 0
 1006 0380 8091 0000 		lds r24,ep_in_data+1
 1007 0384 8823      		tst r24
 1008 0386 01F4      		brne .L64
 1009               	.LVL46:
 1010               	.L74:
 1011               	.LBB719:
 1012               	.LBB712:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 1013               		.loc 4 57 0
 1014 0388 8091 0000 		lds r24,ep_in_pipe_data+4
 1015 038c 342F      		mov r19,r20
 1016 038e 381B      		sub r19,r24
 1017               	.LBE712:
 1018               	.LBE719:
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 1019               		.loc 2 127 0
 1020 0390 81E0      		ldi r24,lo8(1)
 1021 0392 1316      		cp __zero_reg__,r19
 1022 0394 04F0      		brlt .L35
 1023 0396 00C0      		rjmp .L64
 1024               	.LVL47:
 1025               	.L75:
 1026               	.LBE721:
 1027               	.LBE723:
 1028               	.LBE807:
 1029               	.LBB808:
 1030               	.LBB801:
 1031               	.LBB798:
 1032               	.LBB795:
 177:usb/usb_pipe.h **** 		ATOMIC_BLOCK(PIPE_ATOMIC){
 1033               		.loc 2 177 0
 1034 0398 BFB7      		in r27,__SREG__
 1035               	.LVL48:
 1036               	.LBB786:
 1037               	.LBB787:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 1038               		.loc 3 50 0
 1039               	/* #APP */
 1040               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 1041 039a F894      		cli
 1042               	 ;  0 "" 2
 1043               	.LVL49:
 1044               	/* #NOAPP */
 1045               	.LBE787:
 1046               	.LBE786:
 178:usb/usb_pipe.h **** 			p->data->packet_offset = 0;
 1047               		.loc 2 178 0
 1048 039c 1092 0000 		sts ep_in_data+2,__zero_reg__
 1049 03a0 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 1050               	.LVL50:
 1051               	.LBB788:
 1052               	.LBB789:
  81:usb/pipe.h    **** 	pipe->data->count += 1;
 1053               		.loc 4 81 0
 1054 03a4 8091 0000 		lds r24,ep_in_pipe_data+4
 1055 03a8 8F5F      		subi r24,lo8(-(1))
 1056 03aa 8093 0000 		sts ep_in_pipe_data+4,r24
  82:usb/pipe.h    **** 	pipe->data->write_ptr += pipe->size;
 1057               		.loc 4 82 0
 1058 03ae 8091 0000 		lds r24,ep_in_pipe_data+2
 1059 03b2 9091 0000 		lds r25,ep_in_pipe_data+2+1
 1060 03b6 805C      		subi r24,lo8(-(64))
 1061 03b8 9F4F      		sbci r25,hi8(-(64))
 1062 03ba 8093 0000 		sts ep_in_pipe_data+2,r24
 1063 03be 9093 0000 		sts ep_in_pipe_data+2+1,r25
  84:usb/pipe.h    **** 	if (pipe->data->write_ptr == &pipe->buffer[pipe->slots*pipe->size])
 1064               		.loc 4 84 0
 1065 03c2 F0E0      		ldi r31,hi8(ep_in_pipe_buffer+512)
 1066 03c4 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 1067 03c6 9F07      		cpc r25,r31
 1068 03c8 01F4      		brne .L39
  85:usb/pipe.h    **** 		pipe->data->write_ptr = &pipe->buffer[0];
 1069               		.loc 4 85 0
 1070 03ca A092 0000 		sts ep_in_pipe_data+2,r10
 1071 03ce B092 0000 		sts ep_in_pipe_data+2+1,r11
 1072               	.L39:
 1073               	.LVL51:
 1074               	.LBE789:
 1075               	.LBE788:
 1076               	.LBB790:
 1077               	.LBB783:
 1078               	.LBB780:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1079               		.loc 2 80 0
 1080 03d2 5FB7      		in r21,__SREG__
 1081               	.LVL52:
 1082               	.LBB758:
 1083               	.LBB759:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 1084               		.loc 3 50 0
 1085               	/* #APP */
 1086               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 1087 03d4 F894      		cli
 1088               	 ;  0 "" 2
 1089               	.LVL53:
 1090               	/* #NOAPP */
 1091               	.LBE759:
 1092               	.LBE758:
 1093               	.LBB760:
 1094               	.LBB733:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 1095               		.loc 5 220 0
 1096 03d6 8091 0000 		lds r24,endpoints+24
 1097 03da 8670      		andi r24,lo8(6)
 1098               	.LBE733:
 1099               	.LBE760:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 1100               		.loc 2 82 0
 1101 03dc 01F0      		breq .+2
 1102 03de 00C0      		rjmp .L76
 1103               	.LVL54:
 1104               	.L40:
 1105               	.LBB761:
 1106               	.LBB762:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 1107               		.loc 3 70 0
 1108 03e0 5FBF      		out __SREG__,r21
 1109               		.loc 3 71 0
 1110               	.LVL55:
 1111               	.LBE762:
 1112               	.LBE761:
 1113               	.LBE780:
 1114               	.LBE783:
 1115               	.LBE790:
 1116               	.LBB791:
 1117               	.LBB792:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 1118               		.loc 3 70 0
 1119 03e2 BFBF      		out __SREG__,r27
 1120               		.loc 3 71 0
 1121               	.LBE792:
 1122               	.LBE791:
 1123               	.LBE795:
 1124               	.LBE798:
 1125               	.LBE801:
 1126               	.LBE808:
 1127               	.LBE811:
 1128               	.LBE814:
 1129               		.loc 7 5 0
 1130 03e4 F601      		movw r30,r12
 1131 03e6 2191      		ld r18,Z+
 1132 03e8 2223      		tst r18
 1133 03ea 01F0      		breq .+2
 1134 03ec 00C0      		rjmp .L77
 1135               	.LVL56:
 1136               	.L34:
 1137               	.LBB815:
 1138               	.LBB816:
 1139               	.LBB817:
 1140               	.LBB818:
 110:usb/usb_pipe.h **** 	p->data->flush = 1;
 1141               		.loc 2 110 0
 1142 03ee 81E0      		ldi r24,lo8(1)
 1143 03f0 8093 0000 		sts ep_in_data+1,r24
 1144               	.LVL57:
 1145               	.LBB819:
 1146               	.LBB820:
 1147               	.LBB821:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1148               		.loc 2 80 0
 1149 03f4 2FB7      		in r18,__SREG__
 1150               	.LVL58:
 1151               	.LBB822:
 1152               	.LBB823:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 1153               		.loc 3 50 0
 1154               	/* #APP */
 1155               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 1156 03f6 F894      		cli
 1157               	 ;  0 "" 2
 1158               	.LVL59:
 1159               	/* #NOAPP */
 1160               	.LBE823:
 1161               	.LBE822:
 1162               	.LBB824:
 1163               	.LBB825:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 1164               		.loc 5 220 0
 1165 03f8 8091 0000 		lds r24,endpoints+24
 1166 03fc 8670      		andi r24,lo8(6)
 1167               	.LBE825:
 1168               	.LBE824:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 1169               		.loc 2 82 0
 1170 03fe 01F0      		breq .+2
 1171 0400 00C0      		rjmp .L78
 1172               	.LVL60:
 1173               	.L50:
 1174               	.LBB826:
 1175               	.LBB827:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 1176               		.loc 3 70 0
 1177 0402 2FBF      		out __SREG__,r18
 1178               		.loc 3 71 0
 1179               	.LBE827:
 1180               	.LBE826:
 1181               	.LBE821:
 1182               	.LBE820:
 1183               	.LBE819:
 1184               	.LBE818:
 1185               	.LBE817:
  27:Framework.h   ****     USB.INTFLAGSBSET = USB_TRNIF_bm;
 1186               		.loc 1 27 0
 1187 0404 82E0      		ldi r24,lo8(2)
 1188 0406 E0EC      		ldi r30,lo8(1216)
 1189 0408 F4E0      		ldi r31,hi8(1216)
 1190 040a 8587      		std Z+13,r24
 1191               	.LBB863:
 1192               	.LBB864:
 1193               	.LBB865:
 1194               	.LBB866:
 1195               	.LBB867:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 1196               		.loc 4 57 0
 1197 040c 36E0      		ldi r19,lo8(6)
 1198               	.LVL61:
 1199               	.L59:
 1200               	.LBE867:
 1201               	.LBE866:
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1202               		.loc 2 123 0
 1203 040e 9FB7      		in r25,__SREG__
 1204               	.LVL62:
 1205               	.LBB869:
 1206               	.LBB870:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 1207               		.loc 3 50 0
 1208               	/* #APP */
 1209               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 1210 0410 F894      		cli
 1211               	 ;  0 "" 2
 1212               	.LVL63:
 1213               	/* #NOAPP */
 1214               	.LBE870:
 1215               	.LBE869:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 1216               		.loc 2 124 0
 1217 0412 8091 0000 		lds r24,ep_in_data+1
 1218 0416 8823      		tst r24
 1219 0418 01F4      		brne .+2
 1220 041a 00C0      		rjmp .L79
 1221               	.L66:
 125:usb/usb_pipe.h **** 			r = false;
 1222               		.loc 2 125 0
 1223 041c 80E0      		ldi r24,lo8(0)
 1224               	.L61:
 1225               	.LBB871:
 1226               	.LBB872:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 1227               		.loc 3 70 0
 1228 041e 9FBF      		out __SREG__,r25
 1229               		.loc 3 71 0
 1230               	.LBE872:
 1231               	.LBE871:
 1232               	.LBE865:
 1233               	.LBE864:
 1234               	.LBE863:
  28:Framework.h   ****     while (!usb_pipe_can_write(&ep_in)){
 1235               		.loc 1 28 0
 1236 0420 8823      		tst r24
 1237 0422 01F4      		brne .L33
  29:Framework.h   ****         if (timeout_or_sampling_no_longer_enabled){
 1238               		.loc 1 29 0
 1239 0424 8091 0000 		lds r24,timeout_or_sampling_no_longer_enabled
 1240 0428 8823      		tst r24
 1241 042a 01F0      		breq .L59
 1242               	.LVL64:
 1243               	.LBB876:
 1244               	.LBB877:
 1245               	.LBB878:
  54:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 1246               		.loc 2 54 0
 1247 042c 2FB7      		in r18,__SREG__
 1248               	.LVL65:
 1249               	.LBB879:
 1250               	.LBB880:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 1251               		.loc 3 50 0
 1252               	/* #APP */
 1253               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 1254 042e F894      		cli
 1255               	 ;  0 "" 2
 1256               	.LVL66:
 1257               	/* #NOAPP */
 1258               	.LBE880:
 1259               	.LBE879:
 1260               	.LBB881:
 1261               	.LBB882:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 1262               		.loc 4 90 0
 1263 0430 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 1264               		.loc 4 91 0
 1265 0434 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 1266 0436 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 1267 0438 8093 0000 		sts ep_in_pipe_data+2,r24
 1268 043c 9093 0000 		sts ep_in_pipe_data+2+1,r25
 1269 0440 8093 0000 		sts ep_in_pipe_data,r24
 1270 0444 9093 0000 		sts ep_in_pipe_data+1,r25
 1271               	.LVL67:
 1272               	.LBE882:
 1273               	.LBE881:
 1274               	.LBB883:
 1275               	.LBB884:
 158:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 1276               		.loc 5 158 0
 1277 0448 E0E0      		ldi r30,lo8(endpoints+24)
 1278 044a F0E0      		ldi r31,hi8(endpoints+24)
 1279               	/* #APP */
 1280               	 ;  158 "usb/usb.h" 1
 1281 044c 06E0      		ldi r16, 6
 1282 044e 0593      		.dc.w 0x9305
 1283               		
 1284               	 ;  0 "" 2
 159:usb/usb.h     **** 		LACR16(&e->STATUS, USB_EP_BANK_bm);
 1285               		.loc 5 159 0
 1286               	 ;  159 "usb/usb.h" 1
 1287 0450 08E0      		ldi r16, 8
 1288 0452 0693      		.dc.w 0x9306
 1289               		
 1290               	 ;  0 "" 2
 1291               	/* #NOAPP */
 1292               	.LBE884:
 1293               	.LBE883:
  57:usb/usb_pipe.h **** 		p->data->flush = 0;
 1294               		.loc 2 57 0
 1295 0454 1092 0000 		sts ep_in_data+1,__zero_reg__
  58:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
 1296               		.loc 2 58 0
 1297 0458 1092 0000 		sts ep_in_data+2,__zero_reg__
 1298 045c 1092 0000 		sts ep_in_data+2+1,__zero_reg__
  59:usb/usb_pipe.h **** 		p->data->bank = 0;
 1299               		.loc 2 59 0
 1300 0460 1092 0000 		sts ep_in_data,__zero_reg__
 1301               	.LVL68:
 1302               	.LBB885:
 1303               	.LBB886:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 1304               		.loc 3 70 0
 1305 0464 2FBF      		out __SREG__,r18
 1306               		.loc 3 71 0
 1307               	.LVL69:
 1308               	.L33:
 1309               	/* epilogue start */
 1310               	.LBE886:
 1311               	.LBE885:
 1312               	.LBE878:
 1313               	.LBE877:
 1314               	.LBE876:
 1315               	.LBE816:
 1316               	.LBE815:
   6:utils/utils.h ****     send_byte(*s);
   7:utils/utils.h ****     s++;
   8:utils/utils.h ****   }
   9:utils/utils.h ****   break_and_flush();
  10:utils/utils.h ****   s = NULL;
  11:utils/utils.h **** }
 1317               		.loc 7 11 0
 1318 0466 DF91      		pop r29
 1319 0468 CF91      		pop r28
 1320 046a 1F91      		pop r17
 1321 046c 0F91      		pop r16
 1322 046e FF90      		pop r15
 1323 0470 EF90      		pop r14
 1324 0472 DF90      		pop r13
 1325 0474 CF90      		pop r12
 1326 0476 BF90      		pop r11
 1327 0478 AF90      		pop r10
 1328 047a 0895      		ret
 1329               	.LVL70:
 1330               	.L76:
 1331               	.LBB892:
 1332               	.LBB812:
 1333               	.LBB809:
 1334               	.LBB802:
 1335               	.LBB799:
 1336               	.LBB796:
 1337               	.LBB793:
 1338               	.LBB784:
 1339               	.LBB781:
 1340               	.LBB763:
 1341               	.LBB764:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 1342               		.loc 4 51 0
 1343 047c A091 0000 		lds r26,ep_in_pipe_data+4
 1344               	.LBE764:
 1345               	.LBE763:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 1346               		.loc 2 83 0
 1347 0480 1A16      		cp __zero_reg__,r26
 1348 0482 04F0      		brlt .+2
 1349 0484 00C0      		rjmp .L41
 1350               	.LBB765:
 1351               	.LBB766:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 1352               		.loc 4 62 0
 1353 0486 2091 0000 		lds r18,ep_in_pipe_data
 1354 048a 3091 0000 		lds r19,ep_in_pipe_data+1
 1355               	.LVL71:
 1356               	.LBE766:
 1357               	.LBE765:
 1358               	.LBB767:
 1359               	.LBB756:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 1360               		.loc 2 68 0
 1361 048e E091 0000 		lds r30,ep_in_data
 1362               	.LVL72:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 1363               		.loc 2 69 0
 1364 0492 8E2F      		mov r24,r30
 1365 0494 90E0      		ldi r25,lo8(0)
 1366               	.LVL73:
 1367 0496 F1E0      		ldi r31,lo8(1)
 1368 0498 8C17      		cp r24,r28
 1369 049a 9D07      		cpc r25,r29
 1370 049c 01F4      		brne .L42
 1371 049e F0E0      		ldi r31,lo8(0)
 1372               	.L42:
 1373 04a0 F093 0000 		sts ep_in_data,r31
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 1374               		.loc 2 72 0
 1375 04a4 EE23      		tst r30
 1376 04a6 01F4      		brne .L43
 1377               	.LVL74:
 1378               	.LBB753:
 1379               	.LBB754:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1380               		.loc 5 168 0
 1381 04a8 2093 0000 		sts endpoints+28,r18
 1382 04ac 3093 0000 		sts endpoints+28+1,r19
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1383               		.loc 5 169 0
 1384 04b0 E092 0000 		sts endpoints+26,r14
 1385 04b4 F092 0000 		sts endpoints+26+1,r15
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1386               		.loc 5 174 0
 1387 04b8 FB01      		movw r30,r22
 1388               	/* #APP */
 1389               	 ;  174 "usb/usb.h" 1
 1390 04ba 02E2      		ldi r16, 34
 1391 04bc 0693      		.dc.w 0x9306
 1392               		
 1393               	 ;  0 "" 2
 1394               	.LVL75:
 1395               	/* #NOAPP */
 1396               	.L44:
 1397               	.LBE754:
 1398               	.LBE753:
 1399               	.LBE756:
 1400               	.LBE767:
 1401               	.LBB768:
 1402               	.LBB769:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 1403               		.loc 4 72 0
 1404 04be A150      		subi r26,lo8(-(-1))
 1405 04c0 A093 0000 		sts ep_in_pipe_data+4,r26
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 1406               		.loc 4 73 0
 1407 04c4 C901      		movw r24,r18
 1408 04c6 805C      		subi r24,lo8(-(64))
 1409 04c8 9F4F      		sbci r25,hi8(-(64))
 1410 04ca 8093 0000 		sts ep_in_pipe_data,r24
 1411 04ce 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 1412               		.loc 4 75 0
 1413 04d2 F0E0      		ldi r31,hi8(ep_in_pipe_buffer+512)
 1414 04d4 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 1415 04d6 9F07      		cpc r25,r31
 1416 04d8 01F0      		breq .+2
 1417 04da 00C0      		rjmp .L40
 1418               	.LBE769:
 1419               	.LBE768:
 1420               	.LBB770:
 1421               	.LBB736:
 1422               		.loc 4 91 0
 1423 04dc A092 0000 		sts ep_in_pipe_data,r10
 1424 04e0 B092 0000 		sts ep_in_pipe_data+1,r11
 1425               	.LVL76:
 1426 04e4 00C0      		rjmp .L40
 1427               	.LVL77:
 1428               	.L43:
 1429               	.LBE736:
 1430               	.LBE770:
 1431               	.LBB771:
 1432               	.LBB757:
 1433               	.LBB755:
 1434               	.LBB752:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1435               		.loc 5 168 0
 1436 04e6 2093 0000 		sts endpoints+20,r18
 1437 04ea 3093 0000 		sts endpoints+20+1,r19
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1438               		.loc 5 169 0
 1439 04ee E092 0000 		sts endpoints+18,r14
 1440 04f2 F092 0000 		sts endpoints+18+1,r15
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 1441               		.loc 5 176 0
 1442 04f6 FB01      		movw r30,r22
 1443               	/* #APP */
 1444               	 ;  176 "usb/usb.h" 1
 1445 04f8 04E1      		ldi r16, 20
 1446 04fa 0693      		.dc.w 0x9306
 1447               		
 1448               	 ;  0 "" 2
 1449               	/* #NOAPP */
 1450 04fc 00C0      		rjmp .L44
 1451               	.LVL78:
 1452               	.L41:
 1453               	.LBE752:
 1454               	.LBE755:
 1455               	.LBE757:
 1456               	.LBE771:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 1457               		.loc 2 87 0
 1458 04fe 8091 0000 		lds r24,ep_in_data+1
 1459 0502 8130      		cpi r24,lo8(1)
 1460 0504 01F0      		breq .L80
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 1461               		.loc 2 91 0
 1462 0506 8230      		cpi r24,lo8(2)
 1463 0508 01F0      		breq .+2
 1464 050a 00C0      		rjmp .L40
 1465               	.LVL79:
 1466               	.LBB772:
 1467               	.LBB773:
 1468               	.LBB774:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 1469               		.loc 5 228 0
 1470 050c 8091 0000 		lds r24,endpoints+24
 1471 0510 8670      		andi r24,lo8(6)
 1472               	.LBE774:
 1473               	.LBE773:
 1474               	.LBE772:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 1475               		.loc 2 91 0
 1476 0512 8630      		cpi r24,lo8(6)
 1477 0514 01F0      		breq .+2
 1478 0516 00C0      		rjmp .L40
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 1479               		.loc 2 92 0
 1480 0518 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 1481               		.loc 2 93 0
 1482 051c 1092 0000 		sts ep_in_data+2,__zero_reg__
 1483 0520 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 1484               	.LBB775:
 1485               	.LBB737:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 1486               		.loc 4 90 0
 1487 0524 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 1488               		.loc 4 91 0
 1489 0528 A092 0000 		sts ep_in_pipe_data+2,r10
 1490 052c B092 0000 		sts ep_in_pipe_data+2+1,r11
 1491 0530 A092 0000 		sts ep_in_pipe_data,r10
 1492 0534 B092 0000 		sts ep_in_pipe_data+1,r11
 1493               	.LVL80:
 1494 0538 00C0      		rjmp .L40
 1495               	.LVL81:
 1496               	.L80:
 1497               	.LBE737:
 1498               	.LBE775:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 1499               		.loc 2 88 0
 1500 053a 22E0      		ldi r18,lo8(2)
 1501               	.LVL82:
 1502 053c 2093 0000 		sts ep_in_data+1,r18
 1503               	.LBB776:
 1504               	.LBB777:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 1505               		.loc 4 62 0
 1506 0540 A091 0000 		lds r26,ep_in_pipe_data
 1507 0544 1091 0000 		lds r17,ep_in_pipe_data+1
 1508               	.LBE777:
 1509               	.LBE776:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 1510               		.loc 2 90 0
 1511 0548 2091 0000 		lds r18,ep_in_data+2
 1512 054c 3091 0000 		lds r19,ep_in_data+2+1
 1513               	.LVL83:
 1514               	.LBB778:
 1515               	.LBB746:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 1516               		.loc 2 68 0
 1517 0550 F091 0000 		lds r31,ep_in_data
 1518               	.LVL84:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 1519               		.loc 2 69 0
 1520 0554 8F2F      		mov r24,r31
 1521 0556 90E0      		ldi r25,lo8(0)
 1522 0558 E1E0      		ldi r30,lo8(1)
 1523               	.LVL85:
 1524 055a 8C17      		cp r24,r28
 1525 055c 9D07      		cpc r25,r29
 1526 055e 01F4      		brne .L47
 1527 0560 E0E0      		ldi r30,lo8(0)
 1528               	.L47:
 1529 0562 E093 0000 		sts ep_in_data,r30
 1530               	.LBB740:
 1531               	.LBB741:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1532               		.loc 5 168 0
 1533 0566 8A2F      		mov r24,r26
 1534 0568 912F      		mov r25,r17
 1535               	.LBE741:
 1536               	.LBE740:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 1537               		.loc 2 72 0
 1538 056a FF23      		tst r31
 1539 056c 01F0      		breq .+2
 1540 056e 00C0      		rjmp .L48
 1541               	.LVL86:
 1542               	.LBB743:
 1543               	.LBB742:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1544               		.loc 5 168 0
 1545 0570 8093 0000 		sts endpoints+28,r24
 1546 0574 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1547               		.loc 5 169 0
 1548 0578 2093 0000 		sts endpoints+26,r18
 1549 057c 3093 0000 		sts endpoints+26+1,r19
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1550               		.loc 5 174 0
 1551 0580 FB01      		movw r30,r22
 1552               	/* #APP */
 1553               	 ;  174 "usb/usb.h" 1
 1554 0582 02E2      		ldi r16, 34
 1555 0584 0693      		.dc.w 0x9306
 1556               		
 1557               	 ;  0 "" 2
 1558               	/* #NOAPP */
 1559 0586 00C0      		rjmp .L40
 1560               	.LVL87:
 1561               	.L79:
 1562               	.LBE742:
 1563               	.LBE743:
 1564               	.LBE746:
 1565               	.LBE778:
 1566               	.LBE781:
 1567               	.LBE784:
 1568               	.LBE793:
 1569               	.LBE796:
 1570               	.LBE799:
 1571               	.LBE802:
 1572               	.LBE809:
 1573               	.LBE812:
 1574               	.LBE892:
 1575               	.LBB893:
 1576               	.LBB890:
 1577               	.LBB887:
 1578               	.LBB875:
 1579               	.LBB874:
 1580               	.LBB873:
 1581               	.LBB868:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 1582               		.loc 4 57 0
 1583 0588 8091 0000 		lds r24,ep_in_pipe_data+4
 1584 058c 232F      		mov r18,r19
 1585 058e 281B      		sub r18,r24
 1586               	.LBE868:
 1587               	.LBE873:
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 1588               		.loc 2 127 0
 1589 0590 81E0      		ldi r24,lo8(1)
 1590 0592 1216      		cp __zero_reg__,r18
 1591 0594 04F4      		brge .+2
 1592 0596 00C0      		rjmp .L61
 1593 0598 00C0      		rjmp .L66
 1594               	.LVL88:
 1595               	.L78:
 1596               	.LBE874:
 1597               	.LBE875:
 1598               	.LBE887:
 1599               	.LBB888:
 1600               	.LBB861:
 1601               	.LBB859:
 1602               	.LBB857:
 1603               	.LBB855:
 1604               	.LBB828:
 1605               	.LBB829:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 1606               		.loc 4 51 0
 1607 059a 3091 0000 		lds r19,ep_in_pipe_data+4
 1608               	.LBE829:
 1609               	.LBE828:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 1610               		.loc 2 83 0
 1611 059e 1316      		cp __zero_reg__,r19
 1612 05a0 04F0      		brlt .+2
 1613 05a2 00C0      		rjmp .L51
 1614               	.LBB830:
 1615               	.LBB831:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 1616               		.loc 4 62 0
 1617 05a4 8091 0000 		lds r24,ep_in_pipe_data
 1618 05a8 9091 0000 		lds r25,ep_in_pipe_data+1
 1619               	.LVL89:
 1620               	.LBE831:
 1621               	.LBE830:
 1622               	.LBB832:
 1623               	.LBB833:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 1624               		.loc 2 68 0
 1625 05ac 4091 0000 		lds r20,ep_in_data
 1626               	.LVL90:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 1627               		.loc 2 69 0
 1628 05b0 51E0      		ldi r21,lo8(1)
 1629 05b2 4130      		cpi r20,lo8(1)
 1630 05b4 01F4      		brne .L52
 1631 05b6 50E0      		ldi r21,lo8(0)
 1632               	.L52:
 1633 05b8 5093 0000 		sts ep_in_data,r21
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 1634               		.loc 2 72 0
 1635 05bc 4423      		tst r20
 1636 05be 01F4      		brne .L53
 1637               	.LVL91:
 1638               	.LBB834:
 1639               	.LBB835:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1640               		.loc 5 168 0
 1641 05c0 8093 0000 		sts endpoints+28,r24
 1642 05c4 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1643               		.loc 5 169 0
 1644 05c8 40E4      		ldi r20,lo8(64)
 1645 05ca 50E0      		ldi r21,hi8(64)
 1646 05cc 4093 0000 		sts endpoints+26,r20
 1647 05d0 5093 0000 		sts endpoints+26+1,r21
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1648               		.loc 5 174 0
 1649 05d4 E0E0      		ldi r30,lo8(endpoints+24)
 1650 05d6 F0E0      		ldi r31,hi8(endpoints+24)
 1651               	.LVL92:
 1652               	/* #APP */
 1653               	 ;  174 "usb/usb.h" 1
 1654 05d8 02E2      		ldi r16, 34
 1655 05da 0693      		.dc.w 0x9306
 1656               		
 1657               	 ;  0 "" 2
 1658               	.LVL93:
 1659               	/* #NOAPP */
 1660               	.L54:
 1661               	.LBE835:
 1662               	.LBE834:
 1663               	.LBE833:
 1664               	.LBE832:
 1665               	.LBB839:
 1666               	.LBB840:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 1667               		.loc 4 72 0
 1668 05dc 3150      		subi r19,lo8(-(-1))
 1669 05de 3093 0000 		sts ep_in_pipe_data+4,r19
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 1670               		.loc 4 73 0
 1671 05e2 805C      		subi r24,lo8(-(64))
 1672 05e4 9F4F      		sbci r25,hi8(-(64))
 1673 05e6 8093 0000 		sts ep_in_pipe_data,r24
 1674 05ea 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 1675               		.loc 4 75 0
 1676 05ee F0E0      		ldi r31,hi8(ep_in_pipe_buffer+512)
 1677 05f0 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 1678 05f2 9F07      		cpc r25,r31
 1679 05f4 01F0      		breq .+2
 1680 05f6 00C0      		rjmp .L50
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
 1681               		.loc 4 76 0
 1682 05f8 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 1683 05fa 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 1684 05fc 8093 0000 		sts ep_in_pipe_data,r24
 1685 0600 9093 0000 		sts ep_in_pipe_data+1,r25
 1686 0604 00C0      		rjmp .L50
 1687               	.LVL94:
 1688               	.L48:
 1689               	.LBE840:
 1690               	.LBE839:
 1691               	.LBE855:
 1692               	.LBE857:
 1693               	.LBE859:
 1694               	.LBE861:
 1695               	.LBE888:
 1696               	.LBE890:
 1697               	.LBE893:
 1698               	.LBB894:
 1699               	.LBB813:
 1700               	.LBB810:
 1701               	.LBB803:
 1702               	.LBB800:
 1703               	.LBB797:
 1704               	.LBB794:
 1705               	.LBB785:
 1706               	.LBB782:
 1707               	.LBB779:
 1708               	.LBB747:
 1709               	.LBB744:
 1710               	.LBB745:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1711               		.loc 5 168 0
 1712 0606 8093 0000 		sts endpoints+20,r24
 1713 060a 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1714               		.loc 5 169 0
 1715 060e 2093 0000 		sts endpoints+18,r18
 1716 0612 3093 0000 		sts endpoints+18+1,r19
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 1717               		.loc 5 176 0
 1718 0616 FB01      		movw r30,r22
 1719               	/* #APP */
 1720               	 ;  176 "usb/usb.h" 1
 1721 0618 04E1      		ldi r16, 20
 1722 061a 0693      		.dc.w 0x9306
 1723               		
 1724               	 ;  0 "" 2
 1725               	/* #NOAPP */
 1726 061c 00C0      		rjmp .L40
 1727               	.LVL95:
 1728               	.L53:
 1729               	.LBE745:
 1730               	.LBE744:
 1731               	.LBE747:
 1732               	.LBE779:
 1733               	.LBE782:
 1734               	.LBE785:
 1735               	.LBE794:
 1736               	.LBE797:
 1737               	.LBE800:
 1738               	.LBE803:
 1739               	.LBE810:
 1740               	.LBE813:
 1741               	.LBE894:
 1742               	.LBB895:
 1743               	.LBB891:
 1744               	.LBB889:
 1745               	.LBB862:
 1746               	.LBB860:
 1747               	.LBB858:
 1748               	.LBB856:
 1749               	.LBB841:
 1750               	.LBB838:
 1751               	.LBB836:
 1752               	.LBB837:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1753               		.loc 5 168 0
 1754 061e 8093 0000 		sts endpoints+20,r24
 1755 0622 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1756               		.loc 5 169 0
 1757 0626 40E4      		ldi r20,lo8(64)
 1758 0628 50E0      		ldi r21,hi8(64)
 1759               	.LVL96:
 1760 062a 4093 0000 		sts endpoints+18,r20
 1761 062e 5093 0000 		sts endpoints+18+1,r21
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 1762               		.loc 5 176 0
 1763 0632 E0E0      		ldi r30,lo8(endpoints+24)
 1764 0634 F0E0      		ldi r31,hi8(endpoints+24)
 1765               	/* #APP */
 1766               	 ;  176 "usb/usb.h" 1
 1767 0636 04E1      		ldi r16, 20
 1768 0638 0693      		.dc.w 0x9306
 1769               		
 1770               	 ;  0 "" 2
 1771               	/* #NOAPP */
 1772 063a 00C0      		rjmp .L54
 1773               	.LVL97:
 1774               	.L51:
 1775               	.LBE837:
 1776               	.LBE836:
 1777               	.LBE838:
 1778               	.LBE841:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 1779               		.loc 2 87 0
 1780 063c 8091 0000 		lds r24,ep_in_data+1
 1781 0640 8130      		cpi r24,lo8(1)
 1782 0642 01F0      		breq .L81
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 1783               		.loc 2 91 0
 1784 0644 8230      		cpi r24,lo8(2)
 1785 0646 01F0      		breq .+2
 1786 0648 00C0      		rjmp .L50
 1787               	.LVL98:
 1788               	.LBB842:
 1789               	.LBB843:
 1790               	.LBB844:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 1791               		.loc 5 228 0
 1792 064a 8091 0000 		lds r24,endpoints+24
 1793 064e 8670      		andi r24,lo8(6)
 1794               	.LBE844:
 1795               	.LBE843:
 1796               	.LBE842:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 1797               		.loc 2 91 0
 1798 0650 8630      		cpi r24,lo8(6)
 1799 0652 01F0      		breq .+2
 1800 0654 00C0      		rjmp .L50
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 1801               		.loc 2 92 0
 1802 0656 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 1803               		.loc 2 93 0
 1804 065a 1092 0000 		sts ep_in_data+2,__zero_reg__
 1805 065e 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 1806               	.LBB845:
 1807               	.LBB846:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 1808               		.loc 4 90 0
 1809 0662 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 1810               		.loc 4 91 0
 1811 0666 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 1812 0668 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 1813 066a 8093 0000 		sts ep_in_pipe_data+2,r24
 1814 066e 9093 0000 		sts ep_in_pipe_data+2+1,r25
 1815 0672 8093 0000 		sts ep_in_pipe_data,r24
 1816 0676 9093 0000 		sts ep_in_pipe_data+1,r25
 1817               	.LVL99:
 1818 067a 00C0      		rjmp .L50
 1819               	.LVL100:
 1820               	.L81:
 1821               	.LBE846:
 1822               	.LBE845:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 1823               		.loc 2 88 0
 1824 067c 82E0      		ldi r24,lo8(2)
 1825 067e 8093 0000 		sts ep_in_data+1,r24
 1826               	.LBB847:
 1827               	.LBB848:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 1828               		.loc 4 62 0
 1829 0682 6091 0000 		lds r22,ep_in_pipe_data
 1830 0686 3091 0000 		lds r19,ep_in_pipe_data+1
 1831               	.LBE848:
 1832               	.LBE847:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 1833               		.loc 2 90 0
 1834 068a 4091 0000 		lds r20,ep_in_data+2
 1835 068e 5091 0000 		lds r21,ep_in_data+2+1
 1836               	.LVL101:
 1837               	.LBB849:
 1838               	.LBB850:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 1839               		.loc 2 68 0
 1840 0692 8091 0000 		lds r24,ep_in_data
 1841               	.LVL102:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 1842               		.loc 2 69 0
 1843 0696 91E0      		ldi r25,lo8(1)
 1844 0698 8130      		cpi r24,lo8(1)
 1845 069a 01F4      		brne .L57
 1846 069c 90E0      		ldi r25,lo8(0)
 1847               	.L57:
 1848 069e 9093 0000 		sts ep_in_data,r25
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 1849               		.loc 2 72 0
 1850 06a2 8823      		tst r24
 1851 06a4 01F4      		brne .L58
 1852               	.LVL103:
 1853               	.LBB851:
 1854               	.LBB852:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1855               		.loc 5 168 0
 1856 06a6 862F      		mov r24,r22
 1857 06a8 932F      		mov r25,r19
 1858 06aa 8093 0000 		sts endpoints+28,r24
 1859 06ae 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1860               		.loc 5 169 0
 1861 06b2 4093 0000 		sts endpoints+26,r20
 1862 06b6 5093 0000 		sts endpoints+26+1,r21
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 1863               		.loc 5 174 0
 1864 06ba E0E0      		ldi r30,lo8(endpoints+24)
 1865 06bc F0E0      		ldi r31,hi8(endpoints+24)
 1866               	.LVL104:
 1867               	/* #APP */
 1868               	 ;  174 "usb/usb.h" 1
 1869 06be 02E2      		ldi r16, 34
 1870 06c0 0693      		.dc.w 0x9306
 1871               		
 1872               	 ;  0 "" 2
 1873               	/* #NOAPP */
 1874 06c2 00C0      		rjmp .L50
 1875               	.LVL105:
 1876               	.L58:
 1877               	.LBE852:
 1878               	.LBE851:
 1879               	.LBB853:
 1880               	.LBB854:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 1881               		.loc 5 168 0
 1882 06c4 862F      		mov r24,r22
 1883 06c6 932F      		mov r25,r19
 1884 06c8 8093 0000 		sts endpoints+20,r24
 1885 06cc 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 1886               		.loc 5 169 0
 1887 06d0 4093 0000 		sts endpoints+18,r20
 1888 06d4 5093 0000 		sts endpoints+18+1,r21
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 1889               		.loc 5 176 0
 1890 06d8 E0E0      		ldi r30,lo8(endpoints+24)
 1891 06da F0E0      		ldi r31,hi8(endpoints+24)
 1892               	/* #APP */
 1893               	 ;  176 "usb/usb.h" 1
 1894 06dc 04E1      		ldi r16, 20
 1895 06de 0693      		.dc.w 0x9306
 1896               		
 1897               	 ;  0 "" 2
 1898               	/* #NOAPP */
 1899 06e0 00C0      		rjmp .L50
 1900               	.LBE854:
 1901               	.LBE853:
 1902               	.LBE850:
 1903               	.LBE849:
 1904               	.LBE856:
 1905               	.LBE858:
 1906               	.LBE860:
 1907               	.LBE862:
 1908               	.LBE889:
 1909               	.LBE891:
 1910               	.LBE895:
 1911               		.cfi_endproc
 1912               	.LFE61:
 1914               	.global	concat
 1916               	concat:
 1917               	.LFB62:
  12:utils/utils.h **** 
  13:utils/utils.h **** char* concat(char *s1, char *s2)
  14:utils/utils.h **** {
 1918               		.loc 7 14 0
 1919               		.cfi_startproc
 1920               	.LVL106:
 1921 06e2 EF92      		push r14
 1922               	.LCFI39:
 1923               		.cfi_def_cfa_offset 3
 1924               		.cfi_offset 14, -2
 1925 06e4 FF92      		push r15
 1926               	.LCFI40:
 1927               		.cfi_def_cfa_offset 4
 1928               		.cfi_offset 15, -3
 1929 06e6 0F93      		push r16
 1930               	.LCFI41:
 1931               		.cfi_def_cfa_offset 5
 1932               		.cfi_offset 16, -4
 1933 06e8 1F93      		push r17
 1934               	.LCFI42:
 1935               		.cfi_def_cfa_offset 6
 1936               		.cfi_offset 17, -5
 1937 06ea CF93      		push r28
 1938               	.LCFI43:
 1939               		.cfi_def_cfa_offset 7
 1940               		.cfi_offset 28, -6
 1941 06ec DF93      		push r29
 1942               	.LCFI44:
 1943               		.cfi_def_cfa_offset 8
 1944               		.cfi_offset 29, -7
 1945               	/* prologue: function */
 1946               	/* frame size = 0 */
 1947               	/* stack size = 6 */
 1948               	.L__stack_usage = 6
 1949 06ee F82E      		mov r15,r24
 1950 06f0 E92E      		mov r14,r25
 1951 06f2 162F      		mov r17,r22
 1952 06f4 072F      		mov r16,r23
  15:utils/utils.h ****     //string concatenation -- not needed now, but might prove useful later
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 1953               		.loc 7 16 0
 1954 06f6 A82F      		mov r26,r24
 1955 06f8 B92F      		mov r27,r25
 1956 06fa ED01      		movw r28,r26
 1957 06fc 0990      		ld __tmp_reg__,Y+
 1958 06fe 0020      		tst __tmp_reg__
 1959 0700 01F4      		brne .-6
 1960 0702 9E01      		movw r18,r28
 1961 0704 E62F      		mov r30,r22
 1962 0706 F72F      		mov r31,r23
 1963 0708 EF01      		movw r28,r30
 1964 070a 0990      		ld __tmp_reg__,Y+
 1965 070c 0020      		tst __tmp_reg__
 1966 070e 01F4      		brne .-6
 1967 0710 CE01      		movw r24,r28
 1968               	.LVL107:
 1969 0712 0197      		sbiw r24,1
 1970 0714 8E1B      		sub r24,r30
 1971 0716 9F0B      		sbc r25,r31
 1972 0718 8A1B      		sub r24,r26
 1973 071a 9B0B      		sbc r25,r27
 1974 071c 820F      		add r24,r18
 1975 071e 931F      		adc r25,r19
 1976 0720 0E94 0000 		call malloc
 1977               	.LVL108:
 1978 0724 D82F      		mov r29,r24
 1979 0726 C92F      		mov r28,r25
 1980               	.LVL109:
  17:utils/utils.h ****     //should also check for memory allocation errors here
  18:utils/utils.h ****     strcpy(result, s1);
 1981               		.loc 7 18 0
 1982 0728 6F2D      		mov r22,r15
 1983 072a 7E2D      		mov r23,r14
 1984 072c 0E94 0000 		call strcpy
 1985               	.LVL110:
  19:utils/utils.h ****     strcat(result, s2);
 1986               		.loc 7 19 0
 1987 0730 8D2F      		mov r24,r29
 1988 0732 9C2F      		mov r25,r28
 1989 0734 612F      		mov r22,r17
 1990 0736 702F      		mov r23,r16
 1991 0738 0E94 0000 		call strcat
  20:utils/utils.h ****     return result;
  21:utils/utils.h **** }
 1992               		.loc 7 21 0
 1993 073c 8D2F      		mov r24,r29
 1994 073e 9C2F      		mov r25,r28
 1995               	/* epilogue start */
 1996 0740 DF91      		pop r29
 1997               	.LVL111:
 1998 0742 CF91      		pop r28
 1999               	.LVL112:
 2000 0744 1F91      		pop r17
 2001 0746 0F91      		pop r16
 2002 0748 FF90      		pop r15
 2003 074a EF90      		pop r14
 2004 074c 0895      		ret
 2005               		.cfi_endproc
 2006               	.LFE62:
 2008               	.global	distance
 2010               	distance:
 2011               	.LFB63:
 2012               		.file 8 "nmea/nmea.h"
   1:nmea/nmea.h   **** #include <avr/io.h>
   2:nmea/nmea.h   **** #include <stdlib.h>
   3:nmea/nmea.h   **** #include <string.h>
   4:nmea/nmea.h   **** 
   5:nmea/nmea.h   **** //sample nmea strings for testing parser
   6:nmea/nmea.h   **** // double lat = 42.292747;
   7:nmea/nmea.h   **** // double lng = -71.264622;
   8:nmea/nmea.h   **** double lat = 43.0;
   9:nmea/nmea.h   **** double lng = -73.0;
  10:nmea/nmea.h   **** double max_dist = .200;
  11:nmea/nmea.h   **** 
  12:nmea/nmea.h   **** typedef struct _latlng {
  13:nmea/nmea.h   ****   double lat;
  14:nmea/nmea.h   ****   double lng;
  15:nmea/nmea.h   ****   double dist;
  16:nmea/nmea.h   ****   uint8_t valid;
  17:nmea/nmea.h   ****   uint8_t roaming;
  18:nmea/nmea.h   ****   char* sms;
  19:nmea/nmea.h   **** } latlng;
  20:nmea/nmea.h   **** 
  21:nmea/nmea.h   **** void parse_nmea(char* buff, latlng* gps);
  22:nmea/nmea.h   **** extern void parse_nmea_string(char *s, latlng *gps);
  23:nmea/nmea.h   **** double distance(double gpslat, double gpslng);
  24:nmea/nmea.h   **** 
  25:nmea/nmea.h   **** #define d2r (M_PI / 180.0)
  26:nmea/nmea.h   **** 
  27:nmea/nmea.h   **** //calculate distance, assuming earth is spherical
  28:nmea/nmea.h   **** double distance(double gpslat, double gpslng) {
 2013               		.loc 8 28 0
 2014               		.cfi_startproc
 2015               	.LVL113:
 2016 074e 2F92      		push r2
 2017               	.LCFI45:
 2018               		.cfi_def_cfa_offset 3
 2019               		.cfi_offset 2, -2
 2020 0750 3F92      		push r3
 2021               	.LCFI46:
 2022               		.cfi_def_cfa_offset 4
 2023               		.cfi_offset 3, -3
 2024 0752 4F92      		push r4
 2025               	.LCFI47:
 2026               		.cfi_def_cfa_offset 5
 2027               		.cfi_offset 4, -4
 2028 0754 5F92      		push r5
 2029               	.LCFI48:
 2030               		.cfi_def_cfa_offset 6
 2031               		.cfi_offset 5, -5
 2032 0756 6F92      		push r6
 2033               	.LCFI49:
 2034               		.cfi_def_cfa_offset 7
 2035               		.cfi_offset 6, -6
 2036 0758 7F92      		push r7
 2037               	.LCFI50:
 2038               		.cfi_def_cfa_offset 8
 2039               		.cfi_offset 7, -7
 2040 075a 8F92      		push r8
 2041               	.LCFI51:
 2042               		.cfi_def_cfa_offset 9
 2043               		.cfi_offset 8, -8
 2044 075c 9F92      		push r9
 2045               	.LCFI52:
 2046               		.cfi_def_cfa_offset 10
 2047               		.cfi_offset 9, -9
 2048 075e AF92      		push r10
 2049               	.LCFI53:
 2050               		.cfi_def_cfa_offset 11
 2051               		.cfi_offset 10, -10
 2052 0760 BF92      		push r11
 2053               	.LCFI54:
 2054               		.cfi_def_cfa_offset 12
 2055               		.cfi_offset 11, -11
 2056 0762 CF92      		push r12
 2057               	.LCFI55:
 2058               		.cfi_def_cfa_offset 13
 2059               		.cfi_offset 12, -12
 2060 0764 DF92      		push r13
 2061               	.LCFI56:
 2062               		.cfi_def_cfa_offset 14
 2063               		.cfi_offset 13, -13
 2064 0766 EF92      		push r14
 2065               	.LCFI57:
 2066               		.cfi_def_cfa_offset 15
 2067               		.cfi_offset 14, -14
 2068 0768 FF92      		push r15
 2069               	.LCFI58:
 2070               		.cfi_def_cfa_offset 16
 2071               		.cfi_offset 15, -15
 2072 076a 0F93      		push r16
 2073               	.LCFI59:
 2074               		.cfi_def_cfa_offset 17
 2075               		.cfi_offset 16, -16
 2076 076c 1F93      		push r17
 2077               	.LCFI60:
 2078               		.cfi_def_cfa_offset 18
 2079               		.cfi_offset 17, -17
 2080 076e CF93      		push r28
 2081               	.LCFI61:
 2082               		.cfi_def_cfa_offset 19
 2083               		.cfi_offset 28, -18
 2084 0770 DF93      		push r29
 2085               	.LCFI62:
 2086               		.cfi_def_cfa_offset 20
 2087               		.cfi_offset 29, -19
 2088 0772 CDB7      		in r28,__SP_L__
 2089 0774 DEB7      		in r29,__SP_H__
 2090 0776 2697      		sbiw r28,6
 2091               	.LCFI63:
 2092               		.cfi_def_cfa 28, 26
 2093 0778 CDBF      		out __SP_L__,r28
 2094 077a DEBF      		out __SP_H__,r29
 2095               	/* prologue: function */
 2096               	/* frame size = 6 */
 2097               	/* stack size = 24 */
 2098               	.L__stack_usage = 24
 2099 077c 4B01      		movw r8,r22
 2100 077e 5C01      		movw r10,r24
 2101 0780 2983      		std Y+1,r18
 2102 0782 3A83      		std Y+2,r19
 2103 0784 4B83      		std Y+3,r20
 2104 0786 5C83      		std Y+4,r21
 2105               	.LVL114:
  29:nmea/nmea.h   ****     double dlong = (gpslng - lng) * d2r;
  30:nmea/nmea.h   ****     double dlat = (gpslat - lat) * d2r;
 2106               		.loc 8 30 0
 2107 0788 C090 0000 		lds r12,lat
 2108 078c D090 0000 		lds r13,lat+1
 2109 0790 E090 0000 		lds r14,lat+2
 2110 0794 F090 0000 		lds r15,lat+3
 2111               	.LVL115:
 2112 0798 A701      		movw r20,r14
 2113 079a 9601      		movw r18,r12
 2114               	.LVL116:
 2115 079c 0E94 0000 		call __subsf3
 2116               	.LVL117:
 2117 07a0 25E3      		ldi r18,lo8(0x3c8efa35)
 2118 07a2 3AEF      		ldi r19,hi8(0x3c8efa35)
 2119 07a4 4EE8      		ldi r20,hlo8(0x3c8efa35)
 2120 07a6 5CE3      		ldi r21,hhi8(0x3c8efa35)
 2121 07a8 0E94 0000 		call __mulsf3
  31:nmea/nmea.h   ****     double a = pow(sin(dlat/2.0), 2) + cos(lat*d2r) * cos(gpslat*d2r) * pow(sin(dlong/2.0), 2);
 2122               		.loc 8 31 0
 2123 07ac 20E0      		ldi r18,lo8(0x3f000000)
 2124 07ae 30E0      		ldi r19,hi8(0x3f000000)
 2125 07b0 40E0      		ldi r20,hlo8(0x3f000000)
 2126 07b2 5FE3      		ldi r21,hhi8(0x3f000000)
 2127 07b4 0E94 0000 		call __mulsf3
 2128 07b8 0E94 0000 		call sin
 2129 07bc 9B01      		movw r18,r22
 2130 07be AC01      		movw r20,r24
 2131 07c0 0E94 0000 		call __mulsf3
 2132 07c4 362E      		mov r3,r22
 2133 07c6 272E      		mov r2,r23
 2134 07c8 8D83      		std Y+5,r24
 2135 07ca 9E83      		std Y+6,r25
 2136 07cc C701      		movw r24,r14
 2137 07ce B601      		movw r22,r12
 2138 07d0 25E3      		ldi r18,lo8(0x3c8efa35)
 2139 07d2 3AEF      		ldi r19,hi8(0x3c8efa35)
 2140 07d4 4EE8      		ldi r20,hlo8(0x3c8efa35)
 2141 07d6 5CE3      		ldi r21,hhi8(0x3c8efa35)
 2142 07d8 0E94 0000 		call __mulsf3
 2143 07dc 0E94 0000 		call cos
 2144 07e0 7B01      		movw r14,r22
 2145 07e2 8C01      		movw r16,r24
 2146 07e4 C501      		movw r24,r10
 2147 07e6 B401      		movw r22,r8
 2148 07e8 25E3      		ldi r18,lo8(0x3c8efa35)
 2149 07ea 3AEF      		ldi r19,hi8(0x3c8efa35)
 2150 07ec 4EE8      		ldi r20,hlo8(0x3c8efa35)
 2151 07ee 5CE3      		ldi r21,hhi8(0x3c8efa35)
 2152 07f0 0E94 0000 		call __mulsf3
 2153 07f4 0E94 0000 		call cos
 2154 07f8 2B01      		movw r4,r22
 2155 07fa 3C01      		movw r6,r24
  29:nmea/nmea.h   ****     double dlong = (gpslng - lng) * d2r;
 2156               		.loc 8 29 0
 2157 07fc 6981      		ldd r22,Y+1
 2158 07fe 7A81      		ldd r23,Y+2
 2159 0800 8B81      		ldd r24,Y+3
 2160 0802 9C81      		ldd r25,Y+4
 2161 0804 2091 0000 		lds r18,lng
 2162 0808 3091 0000 		lds r19,lng+1
 2163 080c 4091 0000 		lds r20,lng+2
 2164 0810 5091 0000 		lds r21,lng+3
 2165               	.LVL118:
 2166 0814 0E94 0000 		call __subsf3
 2167               	.LVL119:
 2168 0818 25E3      		ldi r18,lo8(0x3c8efa35)
 2169 081a 3AEF      		ldi r19,hi8(0x3c8efa35)
 2170 081c 4EE8      		ldi r20,hlo8(0x3c8efa35)
 2171 081e 5CE3      		ldi r21,hhi8(0x3c8efa35)
 2172 0820 0E94 0000 		call __mulsf3
 2173               		.loc 8 31 0
 2174 0824 20E0      		ldi r18,lo8(0x3f000000)
 2175 0826 30E0      		ldi r19,hi8(0x3f000000)
 2176 0828 40E0      		ldi r20,hlo8(0x3f000000)
 2177 082a 5FE3      		ldi r21,hhi8(0x3f000000)
 2178 082c 0E94 0000 		call __mulsf3
 2179 0830 0E94 0000 		call sin
 2180 0834 9B01      		movw r18,r22
 2181 0836 AC01      		movw r20,r24
 2182 0838 0E94 0000 		call __mulsf3
 2183 083c B62E      		mov r11,r22
 2184 083e D72E      		mov r13,r23
 2185 0840 882E      		mov r8,r24
 2186               	.LVL120:
 2187 0842 C92E      		mov r12,r25
 2188 0844 C801      		movw r24,r16
 2189 0846 B701      		movw r22,r14
 2190 0848 A301      		movw r20,r6
 2191 084a 9201      		movw r18,r4
 2192 084c 0E94 0000 		call __mulsf3
 2193 0850 0B2D      		mov r16,r11
 2194 0852 1D2D      		mov r17,r13
 2195 0854 282D      		mov r18,r8
 2196 0856 3C2D      		mov r19,r12
 2197 0858 A901      		movw r20,r18
 2198 085a 9801      		movw r18,r16
 2199 085c 0E94 0000 		call __mulsf3
 2200 0860 9B01      		movw r18,r22
 2201 0862 AC01      		movw r20,r24
 2202 0864 F101      		movw r30,r2
 2203 0866 7D81      		ldd r23,Y+5
 2204 0868 6E81      		ldd r22,Y+6
 2205 086a 8F2F      		mov r24,r31
 2206 086c 9E2F      		mov r25,r30
 2207 086e A72F      		mov r26,r23
 2208 0870 B62F      		mov r27,r22
 2209 0872 BC01      		movw r22,r24
 2210 0874 CD01      		movw r24,r26
 2211 0876 0E94 0000 		call __addsf3
 2212 087a 862E      		mov r8,r22
 2213 087c 072F      		mov r16,r23
 2214 087e 382E      		mov r3,r24
 2215 0880 492E      		mov r4,r25
 2216               	.LVL121:
  32:nmea/nmea.h   ****     double c = 2 * atan2(sqrt(a), sqrt(1-a));
 2217               		.loc 8 32 0
 2218 0882 982F      		mov r25,r24
 2219               	.LVL122:
 2220 0884 482D      		mov r20,r8
 2221 0886 502F      		mov r21,r16
 2222 0888 692F      		mov r22,r25
 2223               	.LVL123:
 2224 088a 742D      		mov r23,r4
 2225               	.LVL124:
 2226 088c CB01      		movw r24,r22
 2227 088e BA01      		movw r22,r20
 2228 0890 0E94 0000 		call sqrt
 2229               	.LVL125:
 2230 0894 6B01      		movw r12,r22
 2231 0896 7C01      		movw r14,r24
 2232 0898 60E0      		ldi r22,lo8(0x3f800000)
 2233 089a 70E0      		ldi r23,hi8(0x3f800000)
 2234 089c 80E8      		ldi r24,hlo8(0x3f800000)
 2235 089e 9FE3      		ldi r25,hhi8(0x3f800000)
 2236 08a0 E02F      		mov r30,r16
 2237 08a2 082D      		mov r16,r8
 2238               	.LVL126:
 2239 08a4 1E2F      		mov r17,r30
 2240 08a6 232D      		mov r18,r3
 2241 08a8 342D      		mov r19,r4
 2242 08aa A901      		movw r20,r18
 2243 08ac 9801      		movw r18,r16
 2244 08ae 0E94 0000 		call __subsf3
 2245               	.LVL127:
 2246 08b2 0E94 0000 		call sqrt
 2247 08b6 9B01      		movw r18,r22
 2248 08b8 AC01      		movw r20,r24
 2249 08ba C701      		movw r24,r14
 2250 08bc B601      		movw r22,r12
 2251 08be 0E94 0000 		call atan2
 2252 08c2 9B01      		movw r18,r22
 2253 08c4 AC01      		movw r20,r24
 2254               	.LVL128:
 2255 08c6 0E94 0000 		call __addsf3
 2256               	.LVL129:
  33:nmea/nmea.h   ****     double d = 6367 * c;
 2257               		.loc 8 33 0
 2258 08ca 20E0      		ldi r18,lo8(0x45c6f800)
 2259 08cc 38EF      		ldi r19,hi8(0x45c6f800)
 2260 08ce 46EC      		ldi r20,hlo8(0x45c6f800)
 2261 08d0 55E4      		ldi r21,hhi8(0x45c6f800)
 2262 08d2 0E94 0000 		call __mulsf3
  34:nmea/nmea.h   **** 
  35:nmea/nmea.h   ****     return d;
  36:nmea/nmea.h   **** }
 2263               		.loc 8 36 0
 2264 08d6 462F      		mov r20,r22
 2265 08d8 572F      		mov r21,r23
 2266 08da 682F      		mov r22,r24
 2267 08dc 792F      		mov r23,r25
 2268 08de CB01      		movw r24,r22
 2269 08e0 BA01      		movw r22,r20
 2270               	/* epilogue start */
 2271 08e2 2696      		adiw r28,6
 2272 08e4 CDBF      		out __SP_L__,r28
 2273 08e6 DEBF      		out __SP_H__,r29
 2274 08e8 DF91      		pop r29
 2275 08ea CF91      		pop r28
 2276 08ec 1F91      		pop r17
 2277               	.LVL130:
 2278 08ee 0F91      		pop r16
 2279 08f0 FF90      		pop r15
 2280 08f2 EF90      		pop r14
 2281 08f4 DF90      		pop r13
 2282 08f6 CF90      		pop r12
 2283 08f8 BF90      		pop r11
 2284 08fa AF90      		pop r10
 2285 08fc 9F90      		pop r9
 2286 08fe 8F90      		pop r8
 2287 0900 7F90      		pop r7
 2288 0902 6F90      		pop r6
 2289 0904 5F90      		pop r5
 2290 0906 4F90      		pop r4
 2291 0908 3F90      		pop r3
 2292 090a 2F90      		pop r2
 2293 090c 0895      		ret
 2294               		.cfi_endproc
 2295               	.LFE63:
 2297               		.data
 2298               	.LC0:
 2299 0000 2C00      		.string	","
 2300               		.text
 2301               	.global	parse_nmea_string
 2303               	parse_nmea_string:
 2304               	.LFB64:
  37:nmea/nmea.h   **** 
  38:nmea/nmea.h   **** 
  39:nmea/nmea.h   **** 
  40:nmea/nmea.h   **** void parse_nmea_string(char *s, latlng *gps)
  41:nmea/nmea.h   **** {
 2305               		.loc 8 41 0
 2306               		.cfi_startproc
 2307               	.LVL131:
 2308 090e DF92      		push r13
 2309               	.LCFI64:
 2310               		.cfi_def_cfa_offset 3
 2311               		.cfi_offset 13, -2
 2312 0910 EF92      		push r14
 2313               	.LCFI65:
 2314               		.cfi_def_cfa_offset 4
 2315               		.cfi_offset 14, -3
 2316 0912 FF92      		push r15
 2317               	.LCFI66:
 2318               		.cfi_def_cfa_offset 5
 2319               		.cfi_offset 15, -4
 2320 0914 0F93      		push r16
 2321               	.LCFI67:
 2322               		.cfi_def_cfa_offset 6
 2323               		.cfi_offset 16, -5
 2324 0916 1F93      		push r17
 2325               	.LCFI68:
 2326               		.cfi_def_cfa_offset 7
 2327               		.cfi_offset 17, -6
 2328 0918 CF93      		push r28
 2329               	.LCFI69:
 2330               		.cfi_def_cfa_offset 8
 2331               		.cfi_offset 28, -7
 2332 091a DF93      		push r29
 2333               	.LCFI70:
 2334               		.cfi_def_cfa_offset 9
 2335               		.cfi_offset 29, -8
 2336 091c CDB7      		in r28,__SP_L__
 2337 091e DEB7      		in r29,__SP_H__
 2338 0920 A897      		sbiw r28,40
 2339               	.LCFI71:
 2340               		.cfi_def_cfa 28, 49
 2341 0922 CDBF      		out __SP_L__,r28
 2342 0924 DEBF      		out __SP_H__,r29
 2343               	/* prologue: function */
 2344               	/* frame size = 40 */
 2345               	/* stack size = 47 */
 2346               	.L__stack_usage = 47
 2347 0926 7B01      		movw r14,r22
 2348               	.LVL132:
  42:nmea/nmea.h   ****   uint8_t i=0; // used to iterate through array
  43:nmea/nmea.h   ****   char *token[20]; //stores the chunks of string after splitting the string on commas
  44:nmea/nmea.h   **** 
  45:nmea/nmea.h   ****   token[0] = strtok(s, ","); //get pointer to first token found and store in
 2349               		.loc 8 45 0
 2350 0928 60E0      		ldi r22,lo8(.LC0)
 2351 092a 70E0      		ldi r23,hi8(.LC0)
 2352               	.LVL133:
 2353 092c 0E94 0000 		call strtok
 2354               	.LVL134:
  46:nmea/nmea.h   ****                              //first element of array
  47:nmea/nmea.h   ****   while(token[i] != NULL) {  //while commas continue to be found
 2355               		.loc 8 47 0
 2356 0930 0097      		sbiw r24,0
 2357 0932 01F0      		breq .L85
 2358 0934 10E0      		ldi r17,lo8(0)
 2359               	.LVL135:
 2360               	.L86:
  48:nmea/nmea.h   ****       i++;  
 2361               		.loc 8 48 0
 2362 0936 1F5F      		subi r17,lo8(-(1))
 2363               	.LVL136:
  49:nmea/nmea.h   ****       token[i] = strtok(NULL, ","); //continue to split the string
 2364               		.loc 8 49 0
 2365 0938 80E0      		ldi r24,lo8(0)
 2366 093a 90E0      		ldi r25,hi8(0)
 2367 093c 60E0      		ldi r22,lo8(.LC0)
 2368 093e 70E0      		ldi r23,hi8(.LC0)
 2369 0940 0E94 0000 		call strtok
 2370 0944 E12F      		mov r30,r17
 2371 0946 F0E0      		ldi r31,lo8(0)
 2372 0948 EE0F      		lsl r30
 2373 094a FF1F      		rol r31
 2374 094c 21E0      		ldi r18,lo8(1)
 2375 094e 30E0      		ldi r19,hi8(1)
 2376 0950 2C0F      		add r18,r28
 2377 0952 3D1F      		adc r19,r29
 2378 0954 E20F      		add r30,r18
 2379 0956 F31F      		adc r31,r19
 2380 0958 8083      		st Z,r24
 2381 095a 9183      		std Z+1,r25
  47:nmea/nmea.h   ****   while(token[i] != NULL) {  //while commas continue to be found
 2382               		.loc 8 47 0
 2383 095c 0097      		sbiw r24,0
 2384 095e 01F4      		brne .L86
 2385               	.LVL137:
 2386               	.L85:
  50:nmea/nmea.h   ****   }
  51:nmea/nmea.h   **** 
  52:nmea/nmea.h   ****   //Example: token = [], s = "a,b,c"
  53:nmea/nmea.h   ****   //Iteration 1
  54:nmea/nmea.h   ****   //token --> ["a"], s-->"b,c"
  55:nmea/nmea.h   ****   //token --> ["a", "b"], s-->"c"
  56:nmea/nmea.h   ****   //token --> ["a", "b", "c"], s-->""
  57:nmea/nmea.h   ****   //end
  58:nmea/nmea.h   **** 
  59:nmea/nmea.h   ****   //when parsing GPRMC data
  60:nmea/nmea.h   ****   //error char at index 1
  61:nmea/nmea.h   ****   //longitude should be stored at index 2
  62:nmea/nmea.h   ****   //latitude should be stord at index 4
  63:nmea/nmea.h   **** 
  64:nmea/nmea.h   ****   //indices will have to be changed if our gps module
  65:nmea/nmea.h   ****   //speaks a different dialog of NMEA
  66:nmea/nmea.h   **** 
  67:nmea/nmea.h   ****   char* valid = token[1]; //A --> Valid, V --> Invalid
 2387               		.loc 8 67 0
 2388 0960 EB81      		ldd r30,Y+3
 2389 0962 FC81      		ldd r31,Y+4
 2390               	.LVL138:
  68:nmea/nmea.h   ****   char* lat_str = token[2]; //longitude
 2391               		.loc 8 68 0
 2392 0964 8D81      		ldd r24,Y+5
 2393 0966 9E81      		ldd r25,Y+6
 2394               	.LVL139:
  69:nmea/nmea.h   ****   char* lng_str = token[4]; //latitude
 2395               		.loc 8 69 0
 2396 0968 0985      		ldd r16,Y+9
 2397 096a 1A85      		ldd r17,Y+10
 2398               	.LVL140:
  70:nmea/nmea.h   **** 
  71:nmea/nmea.h   ****   gps->valid = *valid;
 2399               		.loc 8 71 0
 2400 096c 2081      		ld r18,Z
 2401 096e D701      		movw r26,r14
 2402 0970 1C96      		adiw r26,12
 2403 0972 2C93      		st X,r18
 2404 0974 1C97      		sbiw r26,12
  72:nmea/nmea.h   **** 
  73:nmea/nmea.h   ****   if (*valid == 'A') {
 2405               		.loc 8 73 0
 2406 0976 2081      		ld r18,Z
 2407 0978 2134      		cpi r18,lo8(65)
 2408 097a 01F0      		breq .L94
  74:nmea/nmea.h   ****     gps->valid = 1;
  75:nmea/nmea.h   ****     // char* string_rep = concat(lat_str, concat(" ", lng_str));
  76:nmea/nmea.h   ****     // send_string(string_rep);
  77:nmea/nmea.h   ****     //converts string stored in gps->lat_str to double and stores in lat
  78:nmea/nmea.h   ****     gps->lat = atof(lat_str)/100.;
  79:nmea/nmea.h   **** 
  80:nmea/nmea.h   ****     //converts string stored in gps->lng_str to double and stores in lng
  81:nmea/nmea.h   ****     gps->lng = atof(lng_str)/100.;
  82:nmea/nmea.h   ****     gps->dist = distance(gps->lat, gps->lng);
  83:nmea/nmea.h   ****     if (gps->dist > max_dist) {
  84:nmea/nmea.h   ****       gps->roaming = 1;
  85:nmea/nmea.h   ****     } else {
  86:nmea/nmea.h   ****       gps->roaming = 0;
  87:nmea/nmea.h   ****     }
  88:nmea/nmea.h   ****   } else {
  89:nmea/nmea.h   ****     gps->valid = 0;
 2409               		.loc 8 89 0
 2410 097c F701      		movw r30,r14
 2411 097e 1486      		std Z+12,__zero_reg__
 2412               	.L84:
 2413               	/* epilogue start */
  90:nmea/nmea.h   ****     // send_string("No GPS Signal");
  91:nmea/nmea.h   ****   }
  92:nmea/nmea.h   **** 
  93:nmea/nmea.h   **** 
  94:nmea/nmea.h   **** }
 2414               		.loc 8 94 0
 2415 0980 A896      		adiw r28,40
 2416 0982 CDBF      		out __SP_L__,r28
 2417 0984 DEBF      		out __SP_H__,r29
 2418 0986 DF91      		pop r29
 2419 0988 CF91      		pop r28
 2420 098a 1F91      		pop r17
 2421 098c 0F91      		pop r16
 2422 098e FF90      		pop r15
 2423 0990 EF90      		pop r14
 2424               	.LVL141:
 2425 0992 DF90      		pop r13
 2426 0994 0895      		ret
 2427               	.LVL142:
 2428               	.L94:
  74:nmea/nmea.h   ****     gps->valid = 1;
 2429               		.loc 8 74 0
 2430 0996 DD24      		clr r13
 2431 0998 D394      		inc r13
 2432 099a 1C96      		adiw r26,12
 2433 099c DC92      		st X,r13
  78:nmea/nmea.h   ****     gps->lat = atof(lat_str)/100.;
 2434               		.loc 8 78 0
 2435 099e 0E94 0000 		call atof
 2436 09a2 20E0      		ldi r18,lo8(0x42c80000)
 2437 09a4 30E0      		ldi r19,hi8(0x42c80000)
 2438 09a6 48EC      		ldi r20,hlo8(0x42c80000)
 2439 09a8 52E4      		ldi r21,hhi8(0x42c80000)
 2440 09aa 0E94 0000 		call __divsf3
 2441 09ae DC01      		movw r26,r24
 2442 09b0 CB01      		movw r24,r22
 2443 09b2 F701      		movw r30,r14
 2444 09b4 8083      		st Z,r24
 2445 09b6 9183      		std Z+1,r25
 2446 09b8 A283      		std Z+2,r26
 2447 09ba B383      		std Z+3,r27
  81:nmea/nmea.h   ****     gps->lng = atof(lng_str)/100.;
 2448               		.loc 8 81 0
 2449 09bc C801      		movw r24,r16
 2450 09be 0E94 0000 		call atof
 2451 09c2 20E0      		ldi r18,lo8(0x42c80000)
 2452 09c4 30E0      		ldi r19,hi8(0x42c80000)
 2453 09c6 48EC      		ldi r20,hlo8(0x42c80000)
 2454 09c8 52E4      		ldi r21,hhi8(0x42c80000)
 2455 09ca 0E94 0000 		call __divsf3
 2456 09ce A62F      		mov r26,r22
 2457 09d0 172F      		mov r17,r23
 2458 09d2 382F      		mov r19,r24
 2459 09d4 292F      		mov r18,r25
 2460 09d6 C901      		movw r24,r18
 2461 09d8 4A2F      		mov r20,r26
 2462 09da 512F      		mov r21,r17
 2463 09dc 692F      		mov r22,r25
 2464 09de 782F      		mov r23,r24
 2465 09e0 F701      		movw r30,r14
 2466 09e2 4483      		std Z+4,r20
 2467 09e4 5583      		std Z+5,r21
 2468 09e6 6683      		std Z+6,r22
 2469 09e8 7783      		std Z+7,r23
  82:nmea/nmea.h   ****     gps->dist = distance(gps->lat, gps->lng);
 2470               		.loc 8 82 0
 2471 09ea 4081      		ld r20,Z
 2472 09ec 5181      		ldd r21,Z+1
 2473 09ee 6281      		ldd r22,Z+2
 2474 09f0 7381      		ldd r23,Z+3
 2475 09f2 CB01      		movw r24,r22
 2476 09f4 BA01      		movw r22,r20
 2477 09f6 A901      		movw r20,r18
 2478 09f8 0A2F      		mov r16,r26
 2479 09fa 252F      		mov r18,r21
 2480 09fc 342F      		mov r19,r20
 2481 09fe A901      		movw r20,r18
 2482 0a00 9801      		movw r18,r16
 2483 0a02 0E94 0000 		call distance
 2484 0a06 D701      		movw r26,r14
 2485 0a08 1896      		adiw r26,8
 2486 0a0a 6D93      		st X+,r22
 2487 0a0c 7D93      		st X+,r23
 2488 0a0e 8D93      		st X+,r24
 2489 0a10 9C93      		st X,r25
 2490 0a12 1B97      		sbiw r26,8+3
  83:nmea/nmea.h   ****     if (gps->dist > max_dist) {
 2491               		.loc 8 83 0
 2492 0a14 2091 0000 		lds r18,max_dist
 2493 0a18 3091 0000 		lds r19,max_dist+1
 2494 0a1c 4091 0000 		lds r20,max_dist+2
 2495 0a20 5091 0000 		lds r21,max_dist+3
 2496 0a24 0E94 0000 		call __gtsf2
 2497 0a28 1816      		cp __zero_reg__,r24
 2498 0a2a 04F4      		brge .L93
  84:nmea/nmea.h   ****       gps->roaming = 1;
 2499               		.loc 8 84 0
 2500 0a2c F701      		movw r30,r14
 2501 0a2e D586      		std Z+13,r13
 2502 0a30 00C0      		rjmp .L84
 2503               	.L93:
  86:nmea/nmea.h   ****       gps->roaming = 0;
 2504               		.loc 8 86 0
 2505 0a32 D701      		movw r26,r14
 2506 0a34 1D96      		adiw r26,13
 2507 0a36 1C92      		st X,__zero_reg__
 2508 0a38 1D97      		sbiw r26,13
 2509 0a3a 00C0      		rjmp .L84
 2510               		.cfi_endproc
 2511               	.LFE64:
 2513               		.data
 2514               	.LC1:
 2515 0002 2566 00   		.string	"%f"
 2516               		.text
 2517               	.global	parse_nmea
 2519               	parse_nmea:
 2520               	.LFB65:
  95:nmea/nmea.h   **** 
  96:nmea/nmea.h   **** 
  97:nmea/nmea.h   **** void parse_nmea(char* buff, latlng* gps) {
 2521               		.loc 8 97 0
 2522               		.cfi_startproc
 2523               	.LVL143:
 2524 0a3c 8F92      		push r8
 2525               	.LCFI72:
 2526               		.cfi_def_cfa_offset 3
 2527               		.cfi_offset 8, -2
 2528 0a3e 9F92      		push r9
 2529               	.LCFI73:
 2530               		.cfi_def_cfa_offset 4
 2531               		.cfi_offset 9, -3
 2532 0a40 AF92      		push r10
 2533               	.LCFI74:
 2534               		.cfi_def_cfa_offset 5
 2535               		.cfi_offset 10, -4
 2536 0a42 BF92      		push r11
 2537               	.LCFI75:
 2538               		.cfi_def_cfa_offset 6
 2539               		.cfi_offset 11, -5
 2540 0a44 CF92      		push r12
 2541               	.LCFI76:
 2542               		.cfi_def_cfa_offset 7
 2543               		.cfi_offset 12, -6
 2544 0a46 DF92      		push r13
 2545               	.LCFI77:
 2546               		.cfi_def_cfa_offset 8
 2547               		.cfi_offset 13, -7
 2548 0a48 EF92      		push r14
 2549               	.LCFI78:
 2550               		.cfi_def_cfa_offset 9
 2551               		.cfi_offset 14, -8
 2552 0a4a FF92      		push r15
 2553               	.LCFI79:
 2554               		.cfi_def_cfa_offset 10
 2555               		.cfi_offset 15, -9
 2556 0a4c 0F93      		push r16
 2557               	.LCFI80:
 2558               		.cfi_def_cfa_offset 11
 2559               		.cfi_offset 16, -10
 2560 0a4e 1F93      		push r17
 2561               	.LCFI81:
 2562               		.cfi_def_cfa_offset 12
 2563               		.cfi_offset 17, -11
 2564 0a50 CF93      		push r28
 2565               	.LCFI82:
 2566               		.cfi_def_cfa_offset 13
 2567               		.cfi_offset 28, -12
 2568 0a52 DF93      		push r29
 2569               	.LCFI83:
 2570               		.cfi_def_cfa_offset 14
 2571               		.cfi_offset 29, -13
 2572 0a54 CDB7      		in r28,__SP_L__
 2573 0a56 DEB7      		in r29,__SP_H__
 2574 0a58 C659      		subi r28,lo8(-(-150))
 2575 0a5a D040      		sbci r29,hi8(-(-150))
 2576               	.LCFI84:
 2577               		.cfi_def_cfa 28, 164
 2578 0a5c CDBF      		out __SP_L__,r28
 2579 0a5e DEBF      		out __SP_H__,r29
 2580               	/* prologue: function */
 2581               	/* frame size = 150 */
 2582               	/* stack size = 162 */
 2583               	.L__stack_usage = 162
 2584 0a60 7B01      		movw r14,r22
  98:nmea/nmea.h   **** 
  99:nmea/nmea.h   ****     //parse lat and lng out of raw nmea string
 100:nmea/nmea.h   ****     parse_nmea_string(buff, gps);
 2585               		.loc 8 100 0
 2586 0a62 0E94 0000 		call parse_nmea_string
 2587               	.LVL144:
 101:nmea/nmea.h   ****     // send_string("Parsed");
 102:nmea/nmea.h   **** 
 103:nmea/nmea.h   ****     if (gps->dist > max_dist) {
 2588               		.loc 8 103 0
 2589 0a66 D701      		movw r26,r14
 2590 0a68 1896      		adiw r26,8
 2591 0a6a 6D91      		ld r22,X+
 2592 0a6c 7D91      		ld r23,X+
 2593 0a6e 8D91      		ld r24,X+
 2594 0a70 9C91      		ld r25,X
 2595 0a72 1B97      		sbiw r26,8+3
 2596 0a74 2091 0000 		lds r18,max_dist
 2597 0a78 3091 0000 		lds r19,max_dist+1
 2598 0a7c 4091 0000 		lds r20,max_dist+2
 2599 0a80 5091 0000 		lds r21,max_dist+3
 2600 0a84 0E94 0000 		call __gtsf2
 2601 0a88 1816      		cp __zero_reg__,r24
 2602 0a8a 04F0      		brlt .+2
 2603 0a8c 00C0      		rjmp .L95
 2604               	.LBB902:
 104:nmea/nmea.h   **** 
 105:nmea/nmea.h   ****       char lat_buff[50];
 106:nmea/nmea.h   ****       char lng_buff[50];
 107:nmea/nmea.h   ****       char dist_buff[50];
 108:nmea/nmea.h   **** 
 109:nmea/nmea.h   ****       sprintf(lat_buff, "%f", gps->lat);
 2605               		.loc 8 109 0
 2606 0a8e EDB7      		in r30,__SP_L__
 2607 0a90 FEB7      		in r31,__SP_H__
 2608 0a92 3897      		sbiw r30,8
 2609 0a94 EDBF      		out __SP_L__,r30
 2610 0a96 FEBF      		out __SP_H__,r31
 2611 0a98 2DB7      		in r18,__SP_L__
 2612 0a9a 3EB7      		in r19,__SP_H__
 2613 0a9c 2F5F      		subi r18,lo8(-(1))
 2614 0a9e 3F4F      		sbci r19,hi8(-(1))
 2615 0aa0 B5E6      		ldi r27,lo8(101)
 2616 0aa2 AB2E      		mov r10,r27
 2617 0aa4 B12C      		mov r11,__zero_reg__
 2618 0aa6 AC0E      		add r10,r28
 2619 0aa8 BD1E      		adc r11,r29
 2620 0aaa A182      		std Z+1,r10
 2621 0aac B282      		std Z+2,r11
 2622 0aae 00E0      		ldi r16,lo8(.LC1)
 2623 0ab0 10E0      		ldi r17,hi8(.LC1)
 2624 0ab2 D901      		movw r26,r18
 2625 0ab4 1296      		adiw r26,2
 2626 0ab6 0D93      		st X+,r16
 2627 0ab8 1C93      		st X,r17
 2628 0aba 1397      		sbiw r26,2+1
 2629 0abc F701      		movw r30,r14
 2630 0abe 8081      		ld r24,Z
 2631 0ac0 9181      		ldd r25,Z+1
 2632 0ac2 A281      		ldd r26,Z+2
 2633 0ac4 B381      		ldd r27,Z+3
 2634 0ac6 F901      		movw r30,r18
 2635 0ac8 8483      		std Z+4,r24
 2636 0aca 9583      		std Z+5,r25
 2637 0acc A683      		std Z+6,r26
 2638 0ace B783      		std Z+7,r27
 2639               		.cfi_escape 0x2e,0x8
 2640 0ad0 0E94 0000 		call sprintf
 110:nmea/nmea.h   ****       sprintf(lng_buff, "%f", gps->lng);
 2641               		.loc 8 110 0
 2642 0ad4 2DB7      		in r18,__SP_L__
 2643 0ad6 3EB7      		in r19,__SP_H__
 2644 0ad8 2F5F      		subi r18,lo8(-(1))
 2645 0ada 3F4F      		sbci r19,hi8(-(1))
 2646 0adc 83E3      		ldi r24,lo8(51)
 2647 0ade 882E      		mov r8,r24
 2648 0ae0 912C      		mov r9,__zero_reg__
 2649 0ae2 8C0E      		add r8,r28
 2650 0ae4 9D1E      		adc r9,r29
 2651 0ae6 ADB7      		in r26,__SP_L__
 2652 0ae8 BEB7      		in r27,__SP_H__
 2653 0aea 1196      		adiw r26,1
 2654 0aec 8D92      		st X+,r8
 2655 0aee 9C92      		st X,r9
 2656 0af0 1297      		sbiw r26,1+1
 2657 0af2 F901      		movw r30,r18
 2658 0af4 0283      		std Z+2,r16
 2659 0af6 1383      		std Z+3,r17
 2660 0af8 F701      		movw r30,r14
 2661 0afa 8481      		ldd r24,Z+4
 2662 0afc 9581      		ldd r25,Z+5
 2663 0afe A681      		ldd r26,Z+6
 2664 0b00 B781      		ldd r27,Z+7
 2665 0b02 F901      		movw r30,r18
 2666 0b04 8483      		std Z+4,r24
 2667 0b06 9583      		std Z+5,r25
 2668 0b08 A683      		std Z+6,r26
 2669 0b0a B783      		std Z+7,r27
 2670 0b0c 0E94 0000 		call sprintf
 111:nmea/nmea.h   ****       sprintf(dist_buff, "%f", gps->dist);
 2671               		.loc 8 111 0
 2672 0b10 2DB7      		in r18,__SP_L__
 2673 0b12 3EB7      		in r19,__SP_H__
 2674 0b14 2F5F      		subi r18,lo8(-(1))
 2675 0b16 3F4F      		sbci r19,hi8(-(1))
 2676 0b18 CE01      		movw r24,r28
 2677 0b1a 0196      		adiw r24,1
 2678 0b1c ADB7      		in r26,__SP_L__
 2679 0b1e BEB7      		in r27,__SP_H__
 2680 0b20 1196      		adiw r26,1
 2681 0b22 8D93      		st X+,r24
 2682 0b24 9C93      		st X,r25
 2683 0b26 1297      		sbiw r26,1+1
 2684 0b28 F901      		movw r30,r18
 2685 0b2a 0283      		std Z+2,r16
 2686 0b2c 1383      		std Z+3,r17
 2687 0b2e F701      		movw r30,r14
 2688 0b30 8085      		ldd r24,Z+8
 2689 0b32 9185      		ldd r25,Z+9
 2690 0b34 A285      		ldd r26,Z+10
 2691 0b36 B385      		ldd r27,Z+11
 2692 0b38 F901      		movw r30,r18
 2693 0b3a 8483      		std Z+4,r24
 2694 0b3c 9583      		std Z+5,r25
 2695 0b3e A683      		std Z+6,r26
 2696 0b40 B783      		std Z+7,r27
 2697 0b42 0E94 0000 		call sprintf
 2698               	.LVL145:
 2699               	.LBB903:
 2700               	.LBB904:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 2701               		.loc 7 16 0
 2702 0b46 D501      		movw r26,r10
 2703 0b48 0D90      		ld __tmp_reg__,X+
 2704 0b4a 0020      		tst __tmp_reg__
 2705 0b4c 01F4      		brne .-6
 2706 0b4e CD01      		movw r24,r26
 2707 0b50 8A19      		sub r24,r10
 2708 0b52 9B09      		sbc r25,r11
 2709 0b54 EDB7      		in r30,__SP_L__
 2710 0b56 FEB7      		in r31,__SP_H__
 2711 0b58 3896      		adiw r30,8
 2712 0b5a EDBF      		out __SP_L__,r30
 2713 0b5c FEBF      		out __SP_H__,r31
 2714               	.LVL146:
 2715 0b5e 0196      		adiw r24,1
 2716               		.cfi_escape 0x2e,0
 2717 0b60 0E94 0000 		call malloc
 2718               	.LVL147:
 2719 0b64 192F      		mov r17,r25
 2720 0b66 C82E      		mov r12,r24
 2721 0b68 D92E      		mov r13,r25
 2722               	.LVL148:
  18:utils/utils.h ****     strcpy(result, s1);
 2723               		.loc 7 18 0
 2724 0b6a C601      		movw r24,r12
 2725 0b6c B501      		movw r22,r10
 2726 0b6e 0E94 0000 		call strcpy
  19:utils/utils.h ****     strcat(result, s2);
 2727               		.loc 7 19 0
 2728 0b72 EC2D      		mov r30,r12
 2729 0b74 F12F      		mov r31,r17
 2730 0b76 DF01      		movw r26,r30
 2731 0b78 0D90      		ld __tmp_reg__,X+
 2732 0b7a 0020      		tst __tmp_reg__
 2733 0b7c 01F4      		brne .-6
 2734 0b7e 1197      		sbiw r26,1
 2735 0b80 AE1B      		sub r26,r30
 2736 0b82 BF0B      		sbc r27,r31
 2737 0b84 AC0D      		add r26,r12
 2738 0b86 BD1D      		adc r27,r13
 2739 0b88 8CE2      		ldi r24,lo8(44)
 2740 0b8a 90E0      		ldi r25,hi8(44)
 2741 0b8c 8D93      		st X+,r24
 2742 0b8e 9C93      		st X,r25
 2743               	.LVL149:
 2744               	.LBE904:
 2745               	.LBE903:
 2746               	.LBB905:
 2747               	.LBB906:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 2748               		.loc 7 16 0
 2749 0b90 AC2D      		mov r26,r12
 2750 0b92 B12F      		mov r27,r17
 2751 0b94 FD01      		movw r30,r26
 2752 0b96 0190      		ld __tmp_reg__,Z+
 2753 0b98 0020      		tst __tmp_reg__
 2754 0b9a 01F4      		brne .-6
 2755 0b9c 9F01      		movw r18,r30
 2756 0b9e F401      		movw r30,r8
 2757 0ba0 0190      		ld __tmp_reg__,Z+
 2758 0ba2 0020      		tst __tmp_reg__
 2759 0ba4 01F4      		brne .-6
 2760 0ba6 CF01      		movw r24,r30
 2761 0ba8 0197      		sbiw r24,1
 2762 0baa 8819      		sub r24,r8
 2763 0bac 9909      		sbc r25,r9
 2764 0bae 8A1B      		sub r24,r26
 2765 0bb0 9B0B      		sbc r25,r27
 2766 0bb2 820F      		add r24,r18
 2767 0bb4 931F      		adc r25,r19
 2768 0bb6 0E94 0000 		call malloc
 2769 0bba 8C01      		movw r16,r24
 2770               	.LVL150:
  18:utils/utils.h ****     strcpy(result, s1);
 2771               		.loc 7 18 0
 2772 0bbc B601      		movw r22,r12
 2773 0bbe 0E94 0000 		call strcpy
 2774               	.LVL151:
  19:utils/utils.h ****     strcat(result, s2);
 2775               		.loc 7 19 0
 2776 0bc2 C801      		movw r24,r16
 2777 0bc4 B401      		movw r22,r8
 2778 0bc6 0E94 0000 		call strcat
 2779               	.LBE906:
 2780               	.LBE905:
 112:nmea/nmea.h   **** 
 113:nmea/nmea.h   ****       /* Debugging code */
 114:nmea/nmea.h   ****       //determine how many characters are in the gps latitude and longitude strings
 115:nmea/nmea.h   ****       // int len_lat = strlen(lat_buff);
 116:nmea/nmea.h   ****       // int len_lng = strlen(lng_buff);
 117:nmea/nmea.h   ****       // int len_dist = strlen(dist_buff);
 118:nmea/nmea.h   **** 
 119:nmea/nmea.h   ****       // //iterate over lat and lng strings, sending them char by char over usb
 120:nmea/nmea.h   ****       // for (int i=0; i<len_lat; i++) {
 121:nmea/nmea.h   ****       //   send_byte(lat_buff[i]);  
 122:nmea/nmea.h   ****       // }
 123:nmea/nmea.h   **** 
 124:nmea/nmea.h   ****       // //lat/lng seperator 
 125:nmea/nmea.h   ****       // send_byte(' ');  
 126:nmea/nmea.h   ****       // for (int j=0; j<len_lng; j++) {
 127:nmea/nmea.h   ****       //   send_byte(lng_buff[j]);  
 128:nmea/nmea.h   ****       // }
 129:nmea/nmea.h   **** 
 130:nmea/nmea.h   ****       //       //lat/lng seperator 
 131:nmea/nmea.h   ****       // send_byte(' ');  
 132:nmea/nmea.h   ****       // for (int k=0; k<len_dist; k++) {
 133:nmea/nmea.h   ****       //   send_byte(dist_buff[k]);  
 134:nmea/nmea.h   ****       // }
 135:nmea/nmea.h   **** 
 136:nmea/nmea.h   ****       char* lat_str = &lat_buff[0];
 137:nmea/nmea.h   ****       char* lng_str = &lng_buff[0];
 138:nmea/nmea.h   ****       gps->sms = concat(concat(lat_str, ","), lng_str);
 2781               		.loc 8 138 0
 2782 0bca D701      		movw r26,r14
 2783 0bcc 1E96      		adiw r26,14
 2784 0bce 0C93      		st X,r16
 2785 0bd0 1E97      		sbiw r26,14
 2786 0bd2 1F96      		adiw r26,15
 2787 0bd4 1C93      		st X,r17
 2788 0bd6 1F97      		sbiw r26,15
 2789               	.LVL152:
 2790               	.L95:
 2791               	/* epilogue start */
 2792               	.LBE902:
 139:nmea/nmea.h   ****       // send_string(gps->sms);
 140:nmea/nmea.h   ****     }
 141:nmea/nmea.h   **** 
 142:nmea/nmea.h   ****     //presumably has to do with memory management
 143:nmea/nmea.h   ****     //for now, just make sure to call it after you're done sending bytes over usb
 144:nmea/nmea.h   ****     // break_and_flush();
 145:nmea/nmea.h   **** }
 2793               		.loc 8 145 0
 2794 0bd8 CA56      		subi r28,lo8(-(150))
 2795 0bda DF4F      		sbci r29,hi8(-(150))
 2796 0bdc CDBF      		out __SP_L__,r28
 2797 0bde DEBF      		out __SP_H__,r29
 2798 0be0 DF91      		pop r29
 2799 0be2 CF91      		pop r28
 2800 0be4 1F91      		pop r17
 2801 0be6 0F91      		pop r16
 2802 0be8 FF90      		pop r15
 2803 0bea EF90      		pop r14
 2804               	.LVL153:
 2805 0bec DF90      		pop r13
 2806 0bee CF90      		pop r12
 2807 0bf0 BF90      		pop r11
 2808 0bf2 AF90      		pop r10
 2809 0bf4 9F90      		pop r9
 2810 0bf6 8F90      		pop r8
 2811 0bf8 0895      		ret
 2812               		.cfi_endproc
 2813               	.LFE65:
 2815               	.global	uart_putchar
 2817               	uart_putchar:
 2818               	.LFB66:
 2819               		.file 9 "uart/uart.h"
   1:uart/uart.h   **** #include "Framework.h"
   2:uart/uart.h   **** #include <stdio.h>
   3:uart/uart.h   **** #include <stdlib.h>
   4:uart/uart.h   **** #include <string.h>
   5:uart/uart.h   **** 
   6:uart/uart.h   **** uint8_t debug = 0;
   7:uart/uart.h   **** 
   8:uart/uart.h   **** int uart_putchar(char c, USART_t* USART); 
   9:uart/uart.h   **** char uart_getchar(USART_t* USART);
  10:uart/uart.h   **** void send_uart(char*, USART_t* USART);
  11:uart/uart.h   **** 
  12:uart/uart.h   **** // code for communicating with the gprs module via uart
  13:uart/uart.h   **** int uart_putchar (char c, USART_t* USART) { 
 2820               		.loc 9 13 0
 2821               		.cfi_startproc
 2822               	.LVL154:
 2823               	/* prologue: function */
 2824               	/* frame size = 0 */
 2825               	/* stack size = 0 */
 2826               	.L__stack_usage = 0
 2827 0bfa FB01      		movw r30,r22
  14:uart/uart.h   ****     if (c == '\n') 
 2828               		.loc 9 14 0
 2829 0bfc 8A30      		cpi r24,lo8(10)
 2830 0bfe 01F0      		breq .L104
 2831               	.L103:
  15:uart/uart.h   ****         uart_putchar('\r', USART); 
  16:uart/uart.h   **** 
  17:uart/uart.h   ****     // Wait for the transmit buffer to be empty 
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 2832               		.loc 9 18 0 discriminator 1
 2833 0c00 9181      		ldd r25,Z+1
 2834 0c02 95FF      		sbrs r25,5
 2835 0c04 00C0      		rjmp .L103
  19:uart/uart.h   **** 
  20:uart/uart.h   ****     // Put our character into the transmit buffer 
  21:uart/uart.h   ****     USART->DATA = c; 
 2836               		.loc 9 21 0
 2837 0c06 8083      		st Z,r24
  22:uart/uart.h   **** 
  23:uart/uart.h   ****     return 0; 
  24:uart/uart.h   **** } 
 2838               		.loc 9 24 0
 2839 0c08 80E0      		ldi r24,lo8(0)
 2840 0c0a 90E0      		ldi r25,hi8(0)
 2841               	.LVL155:
 2842               	/* epilogue start */
 2843 0c0c 0895      		ret
 2844               	.LVL156:
 2845               	.L104:
 2846               	.LBB923:
 2847               	.LBB924:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 2848               		.loc 9 18 0
 2849 0c0e 9181      		ldd r25,Z+1
 2850 0c10 95FF      		sbrs r25,5
 2851 0c12 00C0      		rjmp .L104
  21:uart/uart.h   ****     USART->DATA = c; 
 2852               		.loc 9 21 0
 2853 0c14 9DE0      		ldi r25,lo8(13)
 2854 0c16 9083      		st Z,r25
 2855 0c18 00C0      		rjmp .L103
 2856               	.LBE924:
 2857               	.LBE923:
 2858               		.cfi_endproc
 2859               	.LFE66:
 2861               	.global	uart_getchar
 2863               	uart_getchar:
 2864               	.LFB67:
  25:uart/uart.h   **** 
  26:uart/uart.h   **** // code for communicating with the gprs module via uart
  27:uart/uart.h   **** char uart_getchar (USART_t* USART) { 
 2865               		.loc 9 27 0
 2866               		.cfi_startproc
 2867               	.LVL157:
 2868               	/* prologue: function */
 2869               	/* frame size = 0 */
 2870               	/* stack size = 0 */
 2871               	.L__stack_usage = 0
 2872 0c1a FC01      		movw r30,r24
 2873               	.LVL158:
 2874               	.L108:
  28:uart/uart.h   **** 
  29:uart/uart.h   ****     // Wait for the receive buffer to be empty 
  30:uart/uart.h   ****     while ( !( USART->STATUS & USART_RXCIF_bm) ); 
 2875               		.loc 9 30 0 discriminator 1
 2876 0c1c 8181      		ldd r24,Z+1
 2877 0c1e 87FF      		sbrs r24,7
 2878 0c20 00C0      		rjmp .L108
  31:uart/uart.h   **** 
  32:uart/uart.h   ****     // Receive char from receive buffer 
  33:uart/uart.h   ****     return USART->DATA; 
 2879               		.loc 9 33 0
 2880 0c22 8081      		ld r24,Z
 2881               	/* epilogue start */
  34:uart/uart.h   **** } 
 2882               		.loc 9 34 0
 2883 0c24 0895      		ret
 2884               		.cfi_endproc
 2885               	.LFE67:
 2887               	.global	send_uart
 2889               	send_uart:
 2890               	.LFB68:
  35:uart/uart.h   **** 
  36:uart/uart.h   **** void send_uart(char* text, USART_t* USART) {
 2891               		.loc 9 36 0
 2892               		.cfi_startproc
 2893               	.LVL159:
 2894 0c26 4F92      		push r4
 2895               	.LCFI85:
 2896               		.cfi_def_cfa_offset 3
 2897               		.cfi_offset 4, -2
 2898 0c28 5F92      		push r5
 2899               	.LCFI86:
 2900               		.cfi_def_cfa_offset 4
 2901               		.cfi_offset 5, -3
 2902 0c2a 6F92      		push r6
 2903               	.LCFI87:
 2904               		.cfi_def_cfa_offset 5
 2905               		.cfi_offset 6, -4
 2906 0c2c 7F92      		push r7
 2907               	.LCFI88:
 2908               		.cfi_def_cfa_offset 6
 2909               		.cfi_offset 7, -5
 2910 0c2e 8F92      		push r8
 2911               	.LCFI89:
 2912               		.cfi_def_cfa_offset 7
 2913               		.cfi_offset 8, -6
 2914 0c30 9F92      		push r9
 2915               	.LCFI90:
 2916               		.cfi_def_cfa_offset 8
 2917               		.cfi_offset 9, -7
 2918 0c32 AF92      		push r10
 2919               	.LCFI91:
 2920               		.cfi_def_cfa_offset 9
 2921               		.cfi_offset 10, -8
 2922 0c34 BF92      		push r11
 2923               	.LCFI92:
 2924               		.cfi_def_cfa_offset 10
 2925               		.cfi_offset 11, -9
 2926 0c36 CF92      		push r12
 2927               	.LCFI93:
 2928               		.cfi_def_cfa_offset 11
 2929               		.cfi_offset 12, -10
 2930 0c38 DF92      		push r13
 2931               	.LCFI94:
 2932               		.cfi_def_cfa_offset 12
 2933               		.cfi_offset 13, -11
 2934 0c3a EF92      		push r14
 2935               	.LCFI95:
 2936               		.cfi_def_cfa_offset 13
 2937               		.cfi_offset 14, -12
 2938 0c3c FF92      		push r15
 2939               	.LCFI96:
 2940               		.cfi_def_cfa_offset 14
 2941               		.cfi_offset 15, -13
 2942 0c3e 0F93      		push r16
 2943               	.LCFI97:
 2944               		.cfi_def_cfa_offset 15
 2945               		.cfi_offset 16, -14
 2946 0c40 1F93      		push r17
 2947               	.LCFI98:
 2948               		.cfi_def_cfa_offset 16
 2949               		.cfi_offset 17, -15
 2950 0c42 CF93      		push r28
 2951               	.LCFI99:
 2952               		.cfi_def_cfa_offset 17
 2953               		.cfi_offset 28, -16
 2954 0c44 DF93      		push r29
 2955               	.LCFI100:
 2956               		.cfi_def_cfa_offset 18
 2957               		.cfi_offset 29, -17
 2958               	/* prologue: function */
 2959               	/* frame size = 0 */
 2960               	/* stack size = 16 */
 2961               	.L__stack_usage = 16
 2962 0c46 EC01      		movw r28,r24
 2963 0c48 7B01      		movw r14,r22
 2964               	.LVL160:
 2965               	.LBB1096:
 2966               	.LBB1097:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 2967               		.loc 7 16 0
 2968 0c4a DC01      		movw r26,r24
 2969 0c4c 0D90      		ld __tmp_reg__,X+
 2970 0c4e 0020      		tst __tmp_reg__
 2971 0c50 01F4      		brne .-6
 2972 0c52 CD01      		movw r24,r26
 2973               	.LVL161:
 2974 0c54 8C1B      		sub r24,r28
 2975 0c56 9D0B      		sbc r25,r29
 2976 0c58 0196      		adiw r24,1
 2977 0c5a 0E94 0000 		call malloc
 2978               	.LVL162:
 2979 0c5e A92E      		mov r10,r25
 2980 0c60 C82E      		mov r12,r24
 2981 0c62 D92E      		mov r13,r25
 2982               	.LVL163:
  18:utils/utils.h ****     strcpy(result, s1);
 2983               		.loc 7 18 0
 2984 0c64 C601      		movw r24,r12
 2985 0c66 BE01      		movw r22,r28
 2986 0c68 0E94 0000 		call strcpy
  19:utils/utils.h ****     strcat(result, s2);
 2987               		.loc 7 19 0
 2988 0c6c AC2D      		mov r26,r12
 2989 0c6e BA2D      		mov r27,r10
 2990 0c70 FD01      		movw r30,r26
 2991 0c72 0190      		ld __tmp_reg__,Z+
 2992 0c74 0020      		tst __tmp_reg__
 2993 0c76 01F4      		brne .-6
 2994 0c78 3197      		sbiw r30,1
 2995 0c7a EA1B      		sub r30,r26
 2996 0c7c FB0B      		sbc r31,r27
 2997 0c7e EC0D      		add r30,r12
 2998 0c80 FD1D      		adc r31,r13
 2999 0c82 8DE0      		ldi r24,lo8(13)
 3000 0c84 90E0      		ldi r25,hi8(13)
 3001 0c86 8083      		st Z,r24
 3002 0c88 9183      		std Z+1,r25
 3003               	.LBE1097:
 3004               	.LBE1096:
 3005               	.LBB1098:
 3006               	.LBB1099:
 3007               	.LBB1100:
 3008               	.LBB1101:
 3009               	.LBB1102:
 3010               	.LBB1103:
 3011               	.LBB1104:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 3012               		.loc 4 57 0
 3013 0c8a D6E0      		ldi r29,lo8(6)
 3014               	.LBE1104:
 3015               	.LBE1103:
 3016               	.LBE1102:
 3017               	.LBE1101:
 3018               	.LBE1100:
 3019               	.LBB1115:
 3020               	.LBB1116:
 3021               	.LBB1117:
 3022               	.LBB1118:
 3023               	.LBB1119:
 3024               	.LBB1120:
 3025               	.LBB1121:
 3026               	.LBB1122:
 3027               	.LBB1123:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 3028               		.loc 5 220 0
 3029 0c8c 20E0      		ldi r18,lo8(endpoints+24)
 3030 0c8e 622E      		mov r6,r18
 3031 0c90 20E0      		ldi r18,hi8(endpoints+24)
 3032 0c92 722E      		mov r7,r18
 3033               	.LBE1123:
 3034               	.LBE1122:
 3035               	.LBB1125:
 3036               	.LBB1126:
 3037               		.loc 4 91 0
 3038 0c94 30E0      		ldi r19,lo8(ep_in_pipe_buffer)
 3039 0c96 432E      		mov r4,r19
 3040 0c98 30E0      		ldi r19,hi8(ep_in_pipe_buffer)
 3041 0c9a 532E      		mov r5,r19
 3042               	.LBE1126:
 3043               	.LBE1125:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 3044               		.loc 2 88 0
 3045 0c9c 12E0      		ldi r17,lo8(2)
 3046               	.LBB1129:
 3047               	.LBB1130:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 3048               		.loc 2 69 0
 3049 0c9e 41E0      		ldi r20,lo8(1)
 3050 0ca0 A42E      		mov r10,r20
 3051 0ca2 B12C      		mov r11,__zero_reg__
 3052               	.LBE1130:
 3053               	.LBE1129:
 3054               	.LBB1140:
 3055               	.LBB1141:
 3056               	.LBB1142:
 3057               	.LBB1143:
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3058               		.loc 5 169 0
 3059 0ca4 50E4      		ldi r21,lo8(64)
 3060 0ca6 852E      		mov r8,r21
 3061 0ca8 912C      		mov r9,__zero_reg__
 3062               	.LVL164:
 3063               	.L154:
 3064               	.LBE1143:
 3065               	.LBE1142:
 3066               	.LBE1141:
 3067               	.LBE1140:
 3068               	.LBE1121:
 3069               	.LBE1120:
 3070               	.LBE1119:
 3071               	.LBE1118:
 3072               	.LBE1117:
 3073               	.LBE1116:
 3074               	.LBE1115:
 3075               	.LBE1099:
 3076               	.LBE1098:
  37:uart/uart.h   ****   char c;
  38:uart/uart.h   ****   char* new_text = concat(text, "\r");
  39:uart/uart.h   ****   while (*new_text != '\0') {  
 3077               		.loc 9 39 0 discriminator 1
 3078 0caa D601      		movw r26,r12
 3079 0cac CD91      		ld r28,X+
 3080 0cae 6D01      		movw r12,r26
 3081 0cb0 CC23      		tst r28
 3082 0cb2 01F4      		brne .+2
 3083 0cb4 00C0      		rjmp .L156
 3084               	.L129:
 3085               	.LVL165:
 3086               	.LBB1205:
 3087               	.LBB1206:
  14:uart/uart.h   ****     if (c == '\n') 
 3088               		.loc 9 14 0
 3089 0cb6 CA30      		cpi r28,lo8(10)
 3090 0cb8 01F4      		brne .+2
 3091 0cba 00C0      		rjmp .L157
 3092               	.L148:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 3093               		.loc 9 18 0
 3094 0cbc F701      		movw r30,r14
 3095 0cbe 8181      		ldd r24,Z+1
 3096 0cc0 85FF      		sbrs r24,5
 3097 0cc2 00C0      		rjmp .L148
  21:uart/uart.h   ****     USART->DATA = c; 
 3098               		.loc 9 21 0
 3099 0cc4 C083      		st Z,r28
 3100               	.LBE1206:
 3101               	.LBE1205:
  40:uart/uart.h   ****     uart_putchar(*new_text, USART);
  41:uart/uart.h   ****     new_text++;
  42:uart/uart.h   **** 
  43:uart/uart.h   ****     if (debug == 1) {
 3102               		.loc 9 43 0
 3103 0cc6 8091 0000 		lds r24,debug
 3104 0cca 8130      		cpi r24,lo8(1)
 3105 0ccc 01F4      		brne .L154
 3106               	.L147:
 3107               	.LBB1208:
 3108               	.LBB1209:
  30:uart/uart.h   ****     while ( !( USART->STATUS & USART_RXCIF_bm) ); 
 3109               		.loc 9 30 0
 3110 0cce D701      		movw r26,r14
 3111 0cd0 1196      		adiw r26,1
 3112 0cd2 8C91      		ld r24,X
 3113 0cd4 1197      		sbiw r26,1
 3114 0cd6 87FF      		sbrs r24,7
 3115 0cd8 00C0      		rjmp .L147
  33:uart/uart.h   ****     return USART->DATA; 
 3116               		.loc 9 33 0
 3117 0cda 2C91      		ld r18,X
 3118               	.LVL166:
 3119               	.L118:
 3120               	.LBE1209:
 3121               	.LBE1208:
 3122               	.LBB1210:
 3123               	.LBB1202:
 3124               	.LBB1195:
 3125               	.LBB1113:
 3126               	.LBB1111:
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 3127               		.loc 2 123 0
 3128 0cdc 9FB7      		in r25,__SREG__
 3129               	.LVL167:
 3130               	.LBB1106:
 3131               	.LBB1107:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 3132               		.loc 3 50 0
 3133               	/* #APP */
 3134               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 3135 0cde F894      		cli
 3136               	 ;  0 "" 2
 3137               	.LVL168:
 3138               	/* #NOAPP */
 3139               	.LBE1107:
 3140               	.LBE1106:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 3141               		.loc 2 124 0
 3142 0ce0 8091 0000 		lds r24,ep_in_data+1
 3143 0ce4 8823      		tst r24
 3144 0ce6 01F4      		brne .+2
 3145 0ce8 00C0      		rjmp .L158
 3146               	.L144:
 125:usb/usb_pipe.h **** 			r = false;
 3147               		.loc 2 125 0
 3148 0cea 80E0      		ldi r24,lo8(0)
 3149               	.L116:
 3150               	.LBB1108:
 3151               	.LBB1109:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 3152               		.loc 3 70 0
 3153 0cec 9FBF      		out __SREG__,r25
 3154               		.loc 3 71 0
 3155               	.LBE1109:
 3156               	.LBE1108:
 3157               	.LBE1111:
 3158               	.LBE1113:
 3159               	.LBE1195:
  20:Framework.h   ****     while (!usb_pipe_can_write(&ep_in));
 3160               		.loc 1 20 0
 3161 0cee 8823      		tst r24
 3162 0cf0 01F0      		breq .L118
 3163               	.LVL169:
 3164               	.LBB1196:
 3165               	.LBB1197:
 175:usb/usb_pipe.h **** 	p->pipe->data->write_ptr[p->data->packet_offset++] = v;
 3166               		.loc 2 175 0
 3167 0cf2 8091 0000 		lds r24,ep_in_data+2
 3168 0cf6 9091 0000 		lds r25,ep_in_data+2+1
 3169 0cfa E091 0000 		lds r30,ep_in_pipe_data+2
 3170 0cfe F091 0000 		lds r31,ep_in_pipe_data+2+1
 3171 0d02 E80F      		add r30,r24
 3172 0d04 F91F      		adc r31,r25
 3173 0d06 2083      		st Z,r18
 3174 0d08 0196      		adiw r24,1
 3175 0d0a 8093 0000 		sts ep_in_data+2,r24
 3176 0d0e 9093 0000 		sts ep_in_data+2+1,r25
 176:usb/usb_pipe.h **** 	if (p->data->packet_offset == p->pipe->size){
 3177               		.loc 2 176 0
 3178 0d12 8034      		cpi r24,64
 3179 0d14 9105      		cpc r25,__zero_reg__
 3180 0d16 01F4      		brne .L154
 3181               	.LBE1197:
 3182               	.LBE1196:
 3183               	.LBB1198:
 3184               	.LBB1192:
 3185               	.LBB1189:
 3186               	.LBB1186:
 177:usb/usb_pipe.h **** 		ATOMIC_BLOCK(PIPE_ATOMIC){
 3187               		.loc 2 177 0
 3188 0d18 AFB7      		in r26,__SREG__
 3189               	.LVL170:
 3190               	.LBB1177:
 3191               	.LBB1178:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 3192               		.loc 3 50 0
 3193               	/* #APP */
 3194               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 3195 0d1a F894      		cli
 3196               	 ;  0 "" 2
 3197               	.LVL171:
 3198               	/* #NOAPP */
 3199               	.LBE1178:
 3200               	.LBE1177:
 3201               		.loc 2 178 0
 3202 0d1c 1092 0000 		sts ep_in_data+2,__zero_reg__
 3203 0d20 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 3204               	.LVL172:
 3205               	.LBB1179:
 3206               	.LBB1180:
  81:usb/pipe.h    **** 	pipe->data->count += 1;
 3207               		.loc 4 81 0
 3208 0d24 8091 0000 		lds r24,ep_in_pipe_data+4
 3209 0d28 8F5F      		subi r24,lo8(-(1))
 3210 0d2a 8093 0000 		sts ep_in_pipe_data+4,r24
  82:usb/pipe.h    **** 	pipe->data->write_ptr += pipe->size;
 3211               		.loc 4 82 0
 3212 0d2e 8091 0000 		lds r24,ep_in_pipe_data+2
 3213 0d32 9091 0000 		lds r25,ep_in_pipe_data+2+1
 3214 0d36 805C      		subi r24,lo8(-(64))
 3215 0d38 9F4F      		sbci r25,hi8(-(64))
 3216 0d3a 8093 0000 		sts ep_in_pipe_data+2,r24
 3217 0d3e 9093 0000 		sts ep_in_pipe_data+2+1,r25
  84:usb/pipe.h    **** 	if (pipe->data->write_ptr == &pipe->buffer[pipe->slots*pipe->size])
 3218               		.loc 4 84 0
 3219 0d42 B0E0      		ldi r27,hi8(ep_in_pipe_buffer+512)
 3220 0d44 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 3221 0d46 9B07      		cpc r25,r27
 3222 0d48 01F4      		brne .L119
  85:usb/pipe.h    **** 		pipe->data->write_ptr = &pipe->buffer[0];
 3223               		.loc 4 85 0
 3224 0d4a 4092 0000 		sts ep_in_pipe_data+2,r4
 3225 0d4e 5092 0000 		sts ep_in_pipe_data+2+1,r5
 3226               	.L119:
 3227               	.LVL173:
 3228               	.LBE1180:
 3229               	.LBE1179:
 3230               	.LBB1181:
 3231               	.LBB1174:
 3232               	.LBB1171:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 3233               		.loc 2 80 0
 3234 0d52 5FB7      		in r21,__SREG__
 3235               	.LVL174:
 3236               	.LBB1150:
 3237               	.LBB1151:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 3238               		.loc 3 50 0
 3239               	/* #APP */
 3240               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 3241 0d54 F894      		cli
 3242               	 ;  0 "" 2
 3243               	.LVL175:
 3244               	/* #NOAPP */
 3245               	.LBE1151:
 3246               	.LBE1150:
 3247               	.LBB1152:
 3248               	.LBB1124:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 3249               		.loc 5 220 0
 3250 0d56 8091 0000 		lds r24,endpoints+24
 3251 0d5a 8670      		andi r24,lo8(6)
 3252               	.LBE1124:
 3253               	.LBE1152:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 3254               		.loc 2 82 0
 3255 0d5c 01F4      		brne .L159
 3256               	.LVL176:
 3257               	.L120:
 3258               	.LBB1153:
 3259               	.LBB1154:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 3260               		.loc 3 70 0
 3261 0d5e 5FBF      		out __SREG__,r21
 3262               		.loc 3 71 0
 3263               	.LVL177:
 3264               	.LBE1154:
 3265               	.LBE1153:
 3266               	.LBE1171:
 3267               	.LBE1174:
 3268               	.LBE1181:
 3269               	.LBB1182:
 3270               	.LBB1183:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 3271               		.loc 3 70 0
 3272 0d60 AFBF      		out __SREG__,r26
 3273               		.loc 3 71 0
 3274               	.LBE1183:
 3275               	.LBE1182:
 3276               	.LBE1186:
 3277               	.LBE1189:
 3278               	.LBE1192:
 3279               	.LBE1198:
 3280               	.LBE1202:
 3281               	.LBE1210:
  39:uart/uart.h   ****   while (*new_text != '\0') {  
 3282               		.loc 9 39 0
 3283 0d62 D601      		movw r26,r12
 3284               	.LVL178:
 3285 0d64 CD91      		ld r28,X+
 3286               	.LVL179:
 3287 0d66 6D01      		movw r12,r26
 3288 0d68 CC23      		tst r28
 3289 0d6a 01F0      		breq .+2
 3290 0d6c 00C0      		rjmp .L129
 3291               	.LVL180:
 3292               	.L156:
  44:uart/uart.h   ****       c = uart_getchar(USART);
  45:uart/uart.h   ****       send_byte(c);
  46:uart/uart.h   ****     }
  47:uart/uart.h   ****   }
  48:uart/uart.h   ****   if (debug == 1) {
 3293               		.loc 9 48 0
 3294 0d6e 8091 0000 		lds r24,debug
 3295 0d72 8130      		cpi r24,lo8(1)
 3296 0d74 01F4      		brne .+2
 3297 0d76 00C0      		rjmp .L160
 3298               	.L110:
 3299               	/* epilogue start */
  49:uart/uart.h   ****     break_and_flush();
  50:uart/uart.h   ****   }
  51:uart/uart.h   **** }
 3300               		.loc 9 51 0
 3301 0d78 DF91      		pop r29
 3302 0d7a CF91      		pop r28
 3303 0d7c 1F91      		pop r17
 3304 0d7e 0F91      		pop r16
 3305 0d80 FF90      		pop r15
 3306 0d82 EF90      		pop r14
 3307               	.LVL181:
 3308 0d84 DF90      		pop r13
 3309 0d86 CF90      		pop r12
 3310 0d88 BF90      		pop r11
 3311 0d8a AF90      		pop r10
 3312 0d8c 9F90      		pop r9
 3313 0d8e 8F90      		pop r8
 3314 0d90 7F90      		pop r7
 3315 0d92 6F90      		pop r6
 3316 0d94 5F90      		pop r5
 3317 0d96 4F90      		pop r4
 3318 0d98 0895      		ret
 3319               	.LVL182:
 3320               	.L158:
 3321               	.LBB1211:
 3322               	.LBB1203:
 3323               	.LBB1199:
 3324               	.LBB1114:
 3325               	.LBB1112:
 3326               	.LBB1110:
 3327               	.LBB1105:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 3328               		.loc 4 57 0
 3329 0d9a 8091 0000 		lds r24,ep_in_pipe_data+4
 3330 0d9e 3D2F      		mov r19,r29
 3331 0da0 381B      		sub r19,r24
 3332               	.LBE1105:
 3333               	.LBE1110:
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 3334               		.loc 2 127 0
 3335 0da2 81E0      		ldi r24,lo8(1)
 3336 0da4 1316      		cp __zero_reg__,r19
 3337 0da6 04F4      		brge .+2
 3338 0da8 00C0      		rjmp .L116
 3339 0daa 00C0      		rjmp .L144
 3340               	.LVL183:
 3341               	.L159:
 3342               	.LBE1112:
 3343               	.LBE1114:
 3344               	.LBE1199:
 3345               	.LBB1200:
 3346               	.LBB1193:
 3347               	.LBB1190:
 3348               	.LBB1187:
 3349               	.LBB1184:
 3350               	.LBB1175:
 3351               	.LBB1172:
 3352               	.LBB1155:
 3353               	.LBB1156:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 3354               		.loc 4 51 0
 3355 0dac 4091 0000 		lds r20,ep_in_pipe_data+4
 3356               	.LBE1156:
 3357               	.LBE1155:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 3358               		.loc 2 83 0
 3359 0db0 1416      		cp __zero_reg__,r20
 3360 0db2 04F0      		brlt .+2
 3361 0db4 00C0      		rjmp .L121
 3362               	.LBB1157:
 3363               	.LBB1158:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 3364               		.loc 4 62 0
 3365 0db6 2091 0000 		lds r18,ep_in_pipe_data
 3366 0dba 3091 0000 		lds r19,ep_in_pipe_data+1
 3367               	.LVL184:
 3368               	.LBE1158:
 3369               	.LBE1157:
 3370               	.LBB1159:
 3371               	.LBB1148:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 3372               		.loc 2 68 0
 3373 0dbe 6091 0000 		lds r22,ep_in_data
 3374               	.LVL185:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 3375               		.loc 2 69 0
 3376 0dc2 862F      		mov r24,r22
 3377 0dc4 90E0      		ldi r25,lo8(0)
 3378               	.LVL186:
 3379 0dc6 71E0      		ldi r23,lo8(1)
 3380 0dc8 8A15      		cp r24,r10
 3381 0dca 9B05      		cpc r25,r11
 3382 0dcc 01F4      		brne .L122
 3383 0dce 70E0      		ldi r23,lo8(0)
 3384               	.L122:
 3385 0dd0 7093 0000 		sts ep_in_data,r23
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 3386               		.loc 2 72 0
 3387 0dd4 6623      		tst r22
 3388 0dd6 01F4      		brne .L123
 3389               	.LVL187:
 3390               	.LBB1145:
 3391               	.LBB1146:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3392               		.loc 5 168 0
 3393 0dd8 2093 0000 		sts endpoints+28,r18
 3394 0ddc 3093 0000 		sts endpoints+28+1,r19
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3395               		.loc 5 169 0
 3396 0de0 8092 0000 		sts endpoints+26,r8
 3397 0de4 9092 0000 		sts endpoints+26+1,r9
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 3398               		.loc 5 174 0
 3399 0de8 F301      		movw r30,r6
 3400               	.LVL188:
 3401               	/* #APP */
 3402               	 ;  174 "usb/usb.h" 1
 3403 0dea 02E2      		ldi r16, 34
 3404 0dec 0693      		.dc.w 0x9306
 3405               		
 3406               	 ;  0 "" 2
 3407               	.LVL189:
 3408               	/* #NOAPP */
 3409               	.L124:
 3410               	.LBE1146:
 3411               	.LBE1145:
 3412               	.LBE1148:
 3413               	.LBE1159:
 3414               	.LBB1160:
 3415               	.LBB1161:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 3416               		.loc 4 72 0
 3417 0dee 4150      		subi r20,lo8(-(-1))
 3418 0df0 4093 0000 		sts ep_in_pipe_data+4,r20
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 3419               		.loc 4 73 0
 3420 0df4 C901      		movw r24,r18
 3421 0df6 805C      		subi r24,lo8(-(64))
 3422 0df8 9F4F      		sbci r25,hi8(-(64))
 3423 0dfa 8093 0000 		sts ep_in_pipe_data,r24
 3424 0dfe 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 3425               		.loc 4 75 0
 3426 0e02 F0E0      		ldi r31,hi8(ep_in_pipe_buffer+512)
 3427 0e04 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 3428 0e06 9F07      		cpc r25,r31
 3429 0e08 01F0      		breq .+2
 3430 0e0a 00C0      		rjmp .L120
 3431               	.LBE1161:
 3432               	.LBE1160:
 3433               	.LBB1162:
 3434               	.LBB1127:
 3435               		.loc 4 91 0
 3436 0e0c 4092 0000 		sts ep_in_pipe_data,r4
 3437 0e10 5092 0000 		sts ep_in_pipe_data+1,r5
 3438               	.LVL190:
 3439 0e14 00C0      		rjmp .L120
 3440               	.LVL191:
 3441               	.L123:
 3442               	.LBE1127:
 3443               	.LBE1162:
 3444               	.LBB1163:
 3445               	.LBB1149:
 3446               	.LBB1147:
 3447               	.LBB1144:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3448               		.loc 5 168 0
 3449 0e16 2093 0000 		sts endpoints+20,r18
 3450 0e1a 3093 0000 		sts endpoints+20+1,r19
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3451               		.loc 5 169 0
 3452 0e1e 8092 0000 		sts endpoints+18,r8
 3453 0e22 9092 0000 		sts endpoints+18+1,r9
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 3454               		.loc 5 176 0
 3455 0e26 F301      		movw r30,r6
 3456               	.LVL192:
 3457               	/* #APP */
 3458               	 ;  176 "usb/usb.h" 1
 3459 0e28 04E1      		ldi r16, 20
 3460 0e2a 0693      		.dc.w 0x9306
 3461               		
 3462               	 ;  0 "" 2
 3463               	/* #NOAPP */
 3464 0e2c 00C0      		rjmp .L124
 3465               	.LVL193:
 3466               	.L121:
 3467               	.LBE1144:
 3468               	.LBE1147:
 3469               	.LBE1149:
 3470               	.LBE1163:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 3471               		.loc 2 87 0
 3472 0e2e 8091 0000 		lds r24,ep_in_data+1
 3473 0e32 8130      		cpi r24,lo8(1)
 3474 0e34 01F0      		breq .L161
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 3475               		.loc 2 91 0
 3476 0e36 8230      		cpi r24,lo8(2)
 3477 0e38 01F0      		breq .+2
 3478 0e3a 00C0      		rjmp .L120
 3479               	.LVL194:
 3480               	.LBB1164:
 3481               	.LBB1165:
 3482               	.LBB1166:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 3483               		.loc 5 228 0
 3484 0e3c 8091 0000 		lds r24,endpoints+24
 3485 0e40 8670      		andi r24,lo8(6)
 3486               	.LBE1166:
 3487               	.LBE1165:
 3488               	.LBE1164:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 3489               		.loc 2 91 0
 3490 0e42 8630      		cpi r24,lo8(6)
 3491 0e44 01F0      		breq .+2
 3492 0e46 00C0      		rjmp .L120
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 3493               		.loc 2 92 0
 3494 0e48 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 3495               		.loc 2 93 0
 3496 0e4c 1092 0000 		sts ep_in_data+2,__zero_reg__
 3497 0e50 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 3498               	.LBB1167:
 3499               	.LBB1128:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 3500               		.loc 4 90 0
 3501 0e54 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 3502               		.loc 4 91 0
 3503 0e58 4092 0000 		sts ep_in_pipe_data+2,r4
 3504 0e5c 5092 0000 		sts ep_in_pipe_data+2+1,r5
 3505 0e60 4092 0000 		sts ep_in_pipe_data,r4
 3506 0e64 5092 0000 		sts ep_in_pipe_data+1,r5
 3507               	.LVL195:
 3508 0e68 00C0      		rjmp .L120
 3509               	.LVL196:
 3510               	.L157:
 3511               	.LBE1128:
 3512               	.LBE1167:
 3513               	.LBE1172:
 3514               	.LBE1175:
 3515               	.LBE1184:
 3516               	.LBE1187:
 3517               	.LBE1190:
 3518               	.LBE1193:
 3519               	.LBE1200:
 3520               	.LBE1203:
 3521               	.LBE1211:
 3522               	.LBB1212:
 3523               	.LBB1207:
  15:uart/uart.h   ****         uart_putchar('\r', USART); 
 3524               		.loc 9 15 0
 3525 0e6a 8DE0      		ldi r24,lo8(13)
 3526 0e6c B701      		movw r22,r14
 3527 0e6e 0E94 0000 		call uart_putchar
 3528 0e72 00C0      		rjmp .L148
 3529               	.LVL197:
 3530               	.L161:
 3531               	.LBE1207:
 3532               	.LBE1212:
 3533               	.LBB1213:
 3534               	.LBB1204:
 3535               	.LBB1201:
 3536               	.LBB1194:
 3537               	.LBB1191:
 3538               	.LBB1188:
 3539               	.LBB1185:
 3540               	.LBB1176:
 3541               	.LBB1173:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 3542               		.loc 2 88 0
 3543 0e74 1093 0000 		sts ep_in_data+1,r17
 3544               	.LBB1168:
 3545               	.LBB1169:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 3546               		.loc 4 62 0
 3547 0e78 7091 0000 		lds r23,ep_in_pipe_data
 3548 0e7c E091 0000 		lds r30,ep_in_pipe_data+1
 3549               	.LBE1169:
 3550               	.LBE1168:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 3551               		.loc 2 90 0
 3552 0e80 2091 0000 		lds r18,ep_in_data+2
 3553 0e84 3091 0000 		lds r19,ep_in_data+2+1
 3554               	.LVL198:
 3555               	.LBB1170:
 3556               	.LBB1139:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 3557               		.loc 2 68 0
 3558 0e88 6091 0000 		lds r22,ep_in_data
 3559               	.LVL199:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 3560               		.loc 2 69 0
 3561 0e8c 862F      		mov r24,r22
 3562 0e8e 90E0      		ldi r25,lo8(0)
 3563               	.LVL200:
 3564 0e90 41E0      		ldi r20,lo8(1)
 3565 0e92 8A15      		cp r24,r10
 3566 0e94 9B05      		cpc r25,r11
 3567 0e96 01F0      		breq .L162
 3568 0e98 4093 0000 		sts ep_in_data,r20
 3569               	.LBB1131:
 3570               	.LBB1132:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3571               		.loc 5 168 0
 3572 0e9c 872F      		mov r24,r23
 3573 0e9e 9E2F      		mov r25,r30
 3574               	.LBE1132:
 3575               	.LBE1131:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 3576               		.loc 2 72 0
 3577 0ea0 6623      		tst r22
 3578 0ea2 01F4      		brne .L128
 3579               	.L163:
 3580               	.LVL201:
 3581               	.LBB1135:
 3582               	.LBB1133:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3583               		.loc 5 168 0
 3584 0ea4 8093 0000 		sts endpoints+28,r24
 3585 0ea8 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3586               		.loc 5 169 0
 3587 0eac 2093 0000 		sts endpoints+26,r18
 3588 0eb0 3093 0000 		sts endpoints+26+1,r19
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 3589               		.loc 5 174 0
 3590 0eb4 F301      		movw r30,r6
 3591               	/* #APP */
 3592               	 ;  174 "usb/usb.h" 1
 3593 0eb6 02E2      		ldi r16, 34
 3594 0eb8 0693      		.dc.w 0x9306
 3595               		
 3596               	 ;  0 "" 2
 3597               	/* #NOAPP */
 3598 0eba 00C0      		rjmp .L120
 3599               	.LVL202:
 3600               	.L128:
 3601               	.LBE1133:
 3602               	.LBE1135:
 3603               	.LBB1136:
 3604               	.LBB1137:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3605               		.loc 5 168 0
 3606 0ebc 8093 0000 		sts endpoints+20,r24
 3607 0ec0 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3608               		.loc 5 169 0
 3609 0ec4 2093 0000 		sts endpoints+18,r18
 3610 0ec8 3093 0000 		sts endpoints+18+1,r19
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 3611               		.loc 5 176 0
 3612 0ecc F301      		movw r30,r6
 3613               	/* #APP */
 3614               	 ;  176 "usb/usb.h" 1
 3615 0ece 04E1      		ldi r16, 20
 3616 0ed0 0693      		.dc.w 0x9306
 3617               		
 3618               	 ;  0 "" 2
 3619               	/* #NOAPP */
 3620 0ed2 00C0      		rjmp .L120
 3621               	.LVL203:
 3622               	.L162:
 3623               	.LBE1137:
 3624               	.LBE1136:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 3625               		.loc 2 69 0
 3626 0ed4 40E0      		ldi r20,lo8(0)
 3627 0ed6 4093 0000 		sts ep_in_data,r20
 3628               	.LBB1138:
 3629               	.LBB1134:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3630               		.loc 5 168 0
 3631 0eda 872F      		mov r24,r23
 3632 0edc 9E2F      		mov r25,r30
 3633               	.LBE1134:
 3634               	.LBE1138:
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 3635               		.loc 2 72 0
 3636 0ede 6623      		tst r22
 3637 0ee0 01F4      		brne .L128
 3638 0ee2 00C0      		rjmp .L163
 3639               	.LVL204:
 3640               	.L160:
 3641               	.LBE1139:
 3642               	.LBE1170:
 3643               	.LBE1173:
 3644               	.LBE1176:
 3645               	.LBE1185:
 3646               	.LBE1188:
 3647               	.LBE1191:
 3648               	.LBE1194:
 3649               	.LBE1201:
 3650               	.LBE1204:
 3651               	.LBE1213:
 3652               	.LBB1214:
 3653               	.LBB1215:
 3654               	.LBB1216:
 3655               	.LBB1217:
 110:usb/usb_pipe.h **** 	p->data->flush = 1;
 3656               		.loc 2 110 0
 3657 0ee4 8093 0000 		sts ep_in_data+1,r24
 3658               	.LVL205:
 3659               	.LBB1218:
 3660               	.LBB1219:
 3661               	.LBB1220:
  80:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 3662               		.loc 2 80 0
 3663 0ee8 2FB7      		in r18,__SREG__
 3664               	.LVL206:
 3665               	.LBB1221:
 3666               	.LBB1222:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 3667               		.loc 3 50 0
 3668               	/* #APP */
 3669               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 3670 0eea F894      		cli
 3671               	 ;  0 "" 2
 3672               	.LVL207:
 3673               	/* #NOAPP */
 3674               	.LBE1222:
 3675               	.LBE1221:
 3676               	.LBB1223:
 3677               	.LBB1224:
 220:usb/usb.h     **** 	return e->STATUS & (USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 3678               		.loc 5 220 0
 3679 0eec 8091 0000 		lds r24,endpoints+24
 3680 0ef0 8670      		andi r24,lo8(6)
 3681               	.LBE1224:
 3682               	.LBE1223:
  82:usb/usb_pipe.h **** 			if (USB_ep_ready(p->ep)){
 3683               		.loc 2 82 0
 3684 0ef2 01F0      		breq .+2
 3685 0ef4 00C0      		rjmp .L164
 3686               	.LVL208:
 3687               	.L131:
 3688               	.LBB1225:
 3689               	.LBB1226:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 3690               		.loc 3 70 0
 3691 0ef6 2FBF      		out __SREG__,r18
 3692               		.loc 3 71 0
 3693               	.LBE1226:
 3694               	.LBE1225:
 3695               	.LBE1220:
 3696               	.LBE1219:
 3697               	.LBE1218:
 3698               	.LBE1217:
 3699               	.LBE1216:
  27:Framework.h   ****     USB.INTFLAGSBSET = USB_TRNIF_bm;
 3700               		.loc 1 27 0
 3701 0ef8 82E0      		ldi r24,lo8(2)
 3702 0efa E0EC      		ldi r30,lo8(1216)
 3703 0efc F4E0      		ldi r31,hi8(1216)
 3704 0efe 8587      		std Z+13,r24
 3705               	.LBB1258:
 3706               	.LBB1259:
 3707               	.LBB1260:
 3708               	.LBB1261:
 3709               	.LBB1262:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 3710               		.loc 4 57 0
 3711 0f00 36E0      		ldi r19,lo8(6)
 3712               	.LVL209:
 3713               	.L140:
 3714               	.LBE1262:
 3715               	.LBE1261:
 123:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 3716               		.loc 2 123 0
 3717 0f02 9FB7      		in r25,__SREG__
 3718               	.LVL210:
 3719               	.LBB1264:
 3720               	.LBB1265:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 3721               		.loc 3 50 0
 3722               	/* #APP */
 3723               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 3724 0f04 F894      		cli
 3725               	 ;  0 "" 2
 3726               	.LVL211:
 3727               	/* #NOAPP */
 3728               	.LBE1265:
 3729               	.LBE1264:
 124:usb/usb_pipe.h **** 		if (p->features&PIPE_ENABLE_FLUSH && p->data->flush){
 3730               		.loc 2 124 0
 3731 0f06 8091 0000 		lds r24,ep_in_data+1
 3732 0f0a 8823      		tst r24
 3733 0f0c 01F0      		breq .L165
 3734               	.L145:
 125:usb/usb_pipe.h **** 			r = false;
 3735               		.loc 2 125 0
 3736 0f0e 80E0      		ldi r24,lo8(0)
 3737               	.L141:
 3738               	.LBB1266:
 3739               	.LBB1267:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 3740               		.loc 3 70 0
 3741 0f10 9FBF      		out __SREG__,r25
 3742               		.loc 3 71 0
 3743               	.LBE1267:
 3744               	.LBE1266:
 3745               	.LBE1260:
 3746               	.LBE1259:
 3747               	.LBE1258:
  28:Framework.h   ****     while (!usb_pipe_can_write(&ep_in)){
 3748               		.loc 1 28 0
 3749 0f12 8823      		tst r24
 3750 0f14 01F0      		breq .+2
 3751 0f16 00C0      		rjmp .L110
  29:Framework.h   ****         if (timeout_or_sampling_no_longer_enabled){
 3752               		.loc 1 29 0
 3753 0f18 8091 0000 		lds r24,timeout_or_sampling_no_longer_enabled
 3754 0f1c 8823      		tst r24
 3755 0f1e 01F0      		breq .L140
 3756               	.LVL212:
 3757               	.LBB1271:
 3758               	.LBB1272:
 3759               	.LBB1273:
  54:usb/usb_pipe.h **** 	ATOMIC_BLOCK(PIPE_ATOMIC){
 3760               		.loc 2 54 0
 3761 0f20 2FB7      		in r18,__SREG__
 3762               	.LVL213:
 3763               	.LBB1274:
 3764               	.LBB1275:
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     cli();
 3765               		.loc 3 50 0
 3766               	/* #APP */
 3767               	 ;  50 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h" 1
 3768 0f22 F894      		cli
 3769               	 ;  0 "" 2
 3770               	.LVL214:
 3771               	/* #NOAPP */
 3772               	.LBE1275:
 3773               	.LBE1274:
 3774               	.LBB1276:
 3775               	.LBB1277:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 3776               		.loc 4 90 0
 3777 0f24 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 3778               		.loc 4 91 0
 3779 0f28 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 3780 0f2a 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 3781 0f2c 8093 0000 		sts ep_in_pipe_data+2,r24
 3782 0f30 9093 0000 		sts ep_in_pipe_data+2+1,r25
 3783 0f34 8093 0000 		sts ep_in_pipe_data,r24
 3784 0f38 9093 0000 		sts ep_in_pipe_data+1,r25
 3785               	.LVL215:
 3786               	.LBE1277:
 3787               	.LBE1276:
 3788               	.LBB1278:
 3789               	.LBB1279:
 158:usb/usb.h     **** 		LASR16(&e->STATUS, USB_EP_BUSNACK0_bm | USB_EP_BUSNACK1_bm);
 3790               		.loc 5 158 0
 3791 0f3c E0E0      		ldi r30,lo8(endpoints+24)
 3792 0f3e F0E0      		ldi r31,hi8(endpoints+24)
 3793               	/* #APP */
 3794               	 ;  158 "usb/usb.h" 1
 3795 0f40 06E0      		ldi r16, 6
 3796 0f42 0593      		.dc.w 0x9305
 3797               		
 3798               	 ;  0 "" 2
 159:usb/usb.h     **** 		LACR16(&e->STATUS, USB_EP_BANK_bm);
 3799               		.loc 5 159 0
 3800               	 ;  159 "usb/usb.h" 1
 3801 0f44 08E0      		ldi r16, 8
 3802 0f46 0693      		.dc.w 0x9306
 3803               		
 3804               	 ;  0 "" 2
 3805               	/* #NOAPP */
 3806               	.LBE1279:
 3807               	.LBE1278:
  57:usb/usb_pipe.h **** 		p->data->flush = 0;
 3808               		.loc 2 57 0
 3809 0f48 1092 0000 		sts ep_in_data+1,__zero_reg__
  58:usb/usb_pipe.h **** 		p->data->packet_offset = 0;
 3810               		.loc 2 58 0
 3811 0f4c 1092 0000 		sts ep_in_data+2,__zero_reg__
 3812 0f50 1092 0000 		sts ep_in_data+2+1,__zero_reg__
  59:usb/usb_pipe.h **** 		p->data->bank = 0;
 3813               		.loc 2 59 0
 3814 0f54 1092 0000 		sts ep_in_data,__zero_reg__
 3815               	.LVL216:
 3816               	.LBB1280:
 3817               	.LBB1281:
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/atomic.h ****     SREG = *__s;
 3818               		.loc 3 70 0
 3819 0f58 2FBF      		out __SREG__,r18
 3820               		.loc 3 71 0
 3821 0f5a 00C0      		rjmp .L110
 3822               	.LVL217:
 3823               	.L165:
 3824               	.LBE1281:
 3825               	.LBE1280:
 3826               	.LBE1273:
 3827               	.LBE1272:
 3828               	.LBE1271:
 3829               	.LBB1282:
 3830               	.LBB1270:
 3831               	.LBB1269:
 3832               	.LBB1268:
 3833               	.LBB1263:
  57:usb/pipe.h    **** 	return (int8_t)pipe->slots - pipe->data->count - pipe->reserve_write;
 3834               		.loc 4 57 0
 3835 0f5c 8091 0000 		lds r24,ep_in_pipe_data+4
 3836 0f60 232F      		mov r18,r19
 3837 0f62 281B      		sub r18,r24
 3838               	.LBE1263:
 3839               	.LBE1268:
 127:usb/usb_pipe.h **** 			r = pipe_can_write(p->pipe) > 0;
 3840               		.loc 2 127 0
 3841 0f64 81E0      		ldi r24,lo8(1)
 3842 0f66 1216      		cp __zero_reg__,r18
 3843 0f68 04F0      		brlt .L141
 3844 0f6a 00C0      		rjmp .L145
 3845               	.LVL218:
 3846               	.L164:
 3847               	.LBE1269:
 3848               	.LBE1270:
 3849               	.LBE1282:
 3850               	.LBB1283:
 3851               	.LBB1257:
 3852               	.LBB1256:
 3853               	.LBB1255:
 3854               	.LBB1254:
 3855               	.LBB1227:
 3856               	.LBB1228:
  51:usb/pipe.h    **** 	return pipe->data->count - pipe->reserve_read;
 3857               		.loc 4 51 0
 3858 0f6c 3091 0000 		lds r19,ep_in_pipe_data+4
 3859               	.LBE1228:
 3860               	.LBE1227:
  83:usb/usb_pipe.h **** 				if (pipe_can_read(p->pipe) >= 1){
 3861               		.loc 2 83 0
 3862 0f70 1316      		cp __zero_reg__,r19
 3863 0f72 04F0      		brlt .+2
 3864 0f74 00C0      		rjmp .L132
 3865               	.LBB1229:
 3866               	.LBB1230:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 3867               		.loc 4 62 0
 3868 0f76 8091 0000 		lds r24,ep_in_pipe_data
 3869 0f7a 9091 0000 		lds r25,ep_in_pipe_data+1
 3870               	.LVL219:
 3871               	.LBE1230:
 3872               	.LBE1229:
 3873               	.LBB1231:
 3874               	.LBB1232:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 3875               		.loc 2 68 0
 3876 0f7e 4091 0000 		lds r20,ep_in_data
 3877               	.LVL220:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 3878               		.loc 2 69 0
 3879 0f82 51E0      		ldi r21,lo8(1)
 3880 0f84 4130      		cpi r20,lo8(1)
 3881 0f86 01F4      		brne .L133
 3882 0f88 50E0      		ldi r21,lo8(0)
 3883               	.L133:
 3884 0f8a 5093 0000 		sts ep_in_data,r21
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 3885               		.loc 2 72 0
 3886 0f8e 4423      		tst r20
 3887 0f90 01F4      		brne .L134
 3888               	.LVL221:
 3889               	.LBB1233:
 3890               	.LBB1234:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3891               		.loc 5 168 0
 3892 0f92 8093 0000 		sts endpoints+28,r24
 3893 0f96 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3894               		.loc 5 169 0
 3895 0f9a 40E4      		ldi r20,lo8(64)
 3896 0f9c 50E0      		ldi r21,hi8(64)
 3897 0f9e 4093 0000 		sts endpoints+26,r20
 3898 0fa2 5093 0000 		sts endpoints+26+1,r21
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 3899               		.loc 5 174 0
 3900 0fa6 E0E0      		ldi r30,lo8(endpoints+24)
 3901 0fa8 F0E0      		ldi r31,hi8(endpoints+24)
 3902               	/* #APP */
 3903               	 ;  174 "usb/usb.h" 1
 3904 0faa 02E2      		ldi r16, 34
 3905 0fac 0693      		.dc.w 0x9306
 3906               		
 3907               	 ;  0 "" 2
 3908               	.LVL222:
 3909               	/* #NOAPP */
 3910               	.L135:
 3911               	.LBE1234:
 3912               	.LBE1233:
 3913               	.LBE1232:
 3914               	.LBE1231:
 3915               	.LBB1238:
 3916               	.LBB1239:
  72:usb/pipe.h    **** 	pipe->data->count -= 1;
 3917               		.loc 4 72 0
 3918 0fae 3150      		subi r19,lo8(-(-1))
 3919 0fb0 3093 0000 		sts ep_in_pipe_data+4,r19
  73:usb/pipe.h    **** 	pipe->data->read_ptr += pipe->size;
 3920               		.loc 4 73 0
 3921 0fb4 805C      		subi r24,lo8(-(64))
 3922 0fb6 9F4F      		sbci r25,hi8(-(64))
 3923 0fb8 8093 0000 		sts ep_in_pipe_data,r24
 3924 0fbc 9093 0000 		sts ep_in_pipe_data+1,r25
  75:usb/pipe.h    **** 	if (pipe->data->read_ptr == &pipe->buffer[pipe->slots*pipe->size])
 3925               		.loc 4 75 0
 3926 0fc0 B0E0      		ldi r27,hi8(ep_in_pipe_buffer+512)
 3927 0fc2 8030      		cpi r24,lo8(ep_in_pipe_buffer+512)
 3928 0fc4 9B07      		cpc r25,r27
 3929 0fc6 01F0      		breq .+2
 3930 0fc8 00C0      		rjmp .L131
  76:usb/pipe.h    **** 		pipe->data->read_ptr = &pipe->buffer[0];
 3931               		.loc 4 76 0
 3932 0fca 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 3933 0fcc 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 3934 0fce 8093 0000 		sts ep_in_pipe_data,r24
 3935 0fd2 9093 0000 		sts ep_in_pipe_data+1,r25
 3936 0fd6 00C0      		rjmp .L131
 3937               	.LVL223:
 3938               	.L134:
 3939               	.LBE1239:
 3940               	.LBE1238:
 3941               	.LBB1240:
 3942               	.LBB1237:
 3943               	.LBB1235:
 3944               	.LBB1236:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 3945               		.loc 5 168 0
 3946 0fd8 8093 0000 		sts endpoints+20,r24
 3947 0fdc 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 3948               		.loc 5 169 0
 3949 0fe0 40E4      		ldi r20,lo8(64)
 3950 0fe2 50E0      		ldi r21,hi8(64)
 3951 0fe4 4093 0000 		sts endpoints+18,r20
 3952 0fe8 5093 0000 		sts endpoints+18+1,r21
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 3953               		.loc 5 176 0
 3954 0fec E0E0      		ldi r30,lo8(endpoints+24)
 3955 0fee F0E0      		ldi r31,hi8(endpoints+24)
 3956               	/* #APP */
 3957               	 ;  176 "usb/usb.h" 1
 3958 0ff0 04E1      		ldi r16, 20
 3959 0ff2 0693      		.dc.w 0x9306
 3960               		
 3961               	 ;  0 "" 2
 3962               	/* #NOAPP */
 3963 0ff4 00C0      		rjmp .L135
 3964               	.LVL224:
 3965               	.L132:
 3966               	.LBE1236:
 3967               	.LBE1235:
 3968               	.LBE1237:
 3969               	.LBE1240:
  87:usb/usb_pipe.h **** 					if (p->data->flush == 1){
 3970               		.loc 2 87 0
 3971 0ff6 8091 0000 		lds r24,ep_in_data+1
 3972 0ffa 8130      		cpi r24,lo8(1)
 3973 0ffc 01F0      		breq .L166
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 3974               		.loc 2 91 0
 3975 0ffe 8230      		cpi r24,lo8(2)
 3976 1000 01F0      		breq .+2
 3977 1002 00C0      		rjmp .L131
 3978               	.LVL225:
 3979               	.LBB1241:
 3980               	.LBB1242:
 3981               	.LBB1243:
 228:usb/usb.h     **** 		return (e->STATUS & mask) == mask;
 3982               		.loc 5 228 0
 3983 1004 8091 0000 		lds r24,endpoints+24
 3984 1008 8670      		andi r24,lo8(6)
 3985               	.LBE1243:
 3986               	.LBE1242:
 3987               	.LBE1241:
  91:usb/usb_pipe.h **** 					}else if (p->data->flush == 2 && USB_ep_empty(p->ep)){
 3988               		.loc 2 91 0
 3989 100a 8630      		cpi r24,lo8(6)
 3990 100c 01F0      		breq .+2
 3991 100e 00C0      		rjmp .L131
  92:usb/usb_pipe.h **** 						p->data->flush = 0;
 3992               		.loc 2 92 0
 3993 1010 1092 0000 		sts ep_in_data+1,__zero_reg__
  93:usb/usb_pipe.h **** 						p->data->packet_offset = 0;
 3994               		.loc 2 93 0
 3995 1014 1092 0000 		sts ep_in_data+2,__zero_reg__
 3996 1018 1092 0000 		sts ep_in_data+2+1,__zero_reg__
 3997               	.LBB1244:
 3998               	.LBB1245:
  90:usb/pipe.h    **** 	pipe->data->count = 0;
 3999               		.loc 4 90 0
 4000 101c 1092 0000 		sts ep_in_pipe_data+4,__zero_reg__
 4001               		.loc 4 91 0
 4002 1020 80E0      		ldi r24,lo8(ep_in_pipe_buffer)
 4003 1022 90E0      		ldi r25,hi8(ep_in_pipe_buffer)
 4004 1024 8093 0000 		sts ep_in_pipe_data+2,r24
 4005 1028 9093 0000 		sts ep_in_pipe_data+2+1,r25
 4006 102c 8093 0000 		sts ep_in_pipe_data,r24
 4007 1030 9093 0000 		sts ep_in_pipe_data+1,r25
 4008               	.LVL226:
 4009 1034 00C0      		rjmp .L131
 4010               	.LVL227:
 4011               	.L166:
 4012               	.LBE1245:
 4013               	.LBE1244:
  88:usb/usb_pipe.h **** 						p->data->flush = 2;
 4014               		.loc 2 88 0
 4015 1036 82E0      		ldi r24,lo8(2)
 4016 1038 8093 0000 		sts ep_in_data+1,r24
 4017               	.LBB1246:
 4018               	.LBB1247:
  62:usb/pipe.h    **** 	return pipe->data->read_ptr;
 4019               		.loc 4 62 0
 4020 103c 6091 0000 		lds r22,ep_in_pipe_data
 4021 1040 3091 0000 		lds r19,ep_in_pipe_data+1
 4022               	.LBE1247:
 4023               	.LBE1246:
  90:usb/usb_pipe.h **** 						_usb_pipe_ep_start(p, pipe_read_ptr(p->pipe), p->data->packet_offset);
 4024               		.loc 2 90 0
 4025 1044 4091 0000 		lds r20,ep_in_data+2
 4026 1048 5091 0000 		lds r21,ep_in_data+2+1
 4027               	.LVL228:
 4028               	.LBB1248:
 4029               	.LBB1249:
  68:usb/usb_pipe.h **** 		bank = p->data->bank;
 4030               		.loc 2 68 0
 4031 104c 8091 0000 		lds r24,ep_in_data
 4032               	.LVL229:
  69:usb/usb_pipe.h **** 		p->data->bank ^= 1;
 4033               		.loc 2 69 0
 4034 1050 91E0      		ldi r25,lo8(1)
 4035 1052 8130      		cpi r24,lo8(1)
 4036 1054 01F4      		brne .L138
 4037 1056 90E0      		ldi r25,lo8(0)
 4038               	.L138:
 4039 1058 9093 0000 		sts ep_in_data,r25
  72:usb/usb_pipe.h **** 	if (bank == 0){ // Helps the optimzer constant-fold, since the multiply is expensive
 4040               		.loc 2 72 0
 4041 105c 8823      		tst r24
 4042 105e 01F4      		brne .L139
 4043               	.LVL230:
 4044               	.LBB1250:
 4045               	.LBB1251:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 4046               		.loc 5 168 0
 4047 1060 862F      		mov r24,r22
 4048 1062 932F      		mov r25,r19
 4049 1064 8093 0000 		sts endpoints+28,r24
 4050 1068 9093 0000 		sts endpoints+28+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 4051               		.loc 5 169 0
 4052 106c 4093 0000 		sts endpoints+26,r20
 4053 1070 5093 0000 		sts endpoints+26+1,r21
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 4054               		.loc 5 174 0
 4055 1074 E0E0      		ldi r30,lo8(endpoints+24)
 4056 1076 F0E0      		ldi r31,hi8(endpoints+24)
 4057               	/* #APP */
 4058               	 ;  174 "usb/usb.h" 1
 4059 1078 02E2      		ldi r16, 34
 4060 107a 0693      		.dc.w 0x9306
 4061               		
 4062               	 ;  0 "" 2
 4063               	/* #NOAPP */
 4064 107c 00C0      		rjmp .L131
 4065               	.LVL231:
 4066               	.L139:
 4067               	.LBE1251:
 4068               	.LBE1250:
 4069               	.LBB1252:
 4070               	.LBB1253:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 4071               		.loc 5 168 0
 4072 107e 862F      		mov r24,r22
 4073 1080 932F      		mov r25,r19
 4074 1082 8093 0000 		sts endpoints+20,r24
 4075 1086 9093 0000 		sts endpoints+20+1,r25
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 4076               		.loc 5 169 0
 4077 108a 4093 0000 		sts endpoints+18,r20
 4078 108e 5093 0000 		sts endpoints+18+1,r21
 176:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK1_bm | USB_EP_TRNCOMPL1_bm);
 4079               		.loc 5 176 0
 4080 1092 E0E0      		ldi r30,lo8(endpoints+24)
 4081 1094 F0E0      		ldi r31,hi8(endpoints+24)
 4082               	/* #APP */
 4083               	 ;  176 "usb/usb.h" 1
 4084 1096 04E1      		ldi r16, 20
 4085 1098 0693      		.dc.w 0x9306
 4086               		
 4087               	 ;  0 "" 2
 4088               	/* #NOAPP */
 4089 109a 00C0      		rjmp .L131
 4090               	.LBE1253:
 4091               	.LBE1252:
 4092               	.LBE1249:
 4093               	.LBE1248:
 4094               	.LBE1254:
 4095               	.LBE1255:
 4096               	.LBE1256:
 4097               	.LBE1257:
 4098               	.LBE1283:
 4099               	.LBE1215:
 4100               	.LBE1214:
 4101               		.cfi_endproc
 4102               	.LFE68:
 4104               	.global	toggle_power_gps
 4106               	toggle_power_gps:
 4107               	.LFB69:
 4108               		.file 10 "gps/gps.h"
   1:gps/gps.h     **** void gps_init (USART_t* USART, PORT_t* PORT, char PWRPIN_bm, char TXPIN_bm, char RESETPIN_bm);
   2:gps/gps.h     **** void toggle_power_gps(PORT_t* PORT, char PWRPIN_bm);
   3:gps/gps.h     **** 
   4:gps/gps.h     **** void toggle_power_gps(PORT_t* PORT, char PWRPIN_bm)
   5:gps/gps.h     **** {
 4109               		.loc 10 5 0
 4110               		.cfi_startproc
 4111               	.LVL232:
 4112               	/* prologue: function */
 4113               	/* frame size = 0 */
 4114               	/* stack size = 0 */
 4115               	.L__stack_usage = 0
 4116 109c FC01      		movw r30,r24
 4117               	.LVL233:
 4118               	.LBB1284:
 4119               	.LBB1285:
 4120               		.file 11 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h"
   1:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #endif
 103:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 104:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** /**
 105:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 109:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 112:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 120:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 129:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 132:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 140:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** {
 144:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 156:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 159:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 
 164:/usr/lib/gcc/avr/4.6.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 4121               		.loc 11 164 0
 4122 109e 8FEF      		 ldi r24,lo8(12799999)
 4123 10a0 9FE4      	    ldi r25,hi8(12799999)
 4124 10a2 A3EC      	    ldi r26,hlo8(12799999)
 4125 10a4 8150      	    1:subi r24,1
 4126 10a6 9040      	    sbci r25,0
 4127 10a8 A040      	    sbci r26,0
 4128 10aa 01F4      	    brne 1b
 4129               	.LVL234:
 4130 10ac 00C0      		rjmp .
 4131 10ae 0000      		nop
 4132               	.LBE1285:
 4133               	.LBE1284:
   6:gps/gps.h     ****   // LOW/HIGH transmission of PD0 to wakeup gps module 
   7:gps/gps.h     ****   _delay_ms(2000);
   8:gps/gps.h     ****   PORT->OUTSET |= PWRPIN_bm;
 4134               		.loc 10 8 0
 4135 10b0 8581      		ldd r24,Z+5
 4136 10b2 862B      		or r24,r22
 4137 10b4 8583      		std Z+5,r24
 4138               	.LVL235:
 4139               	.LBB1286:
 4140               	.LBB1287:
 4141               		.loc 11 164 0
 4142 10b6 8FEF      		 ldi r24,lo8(1279999)
 4143 10b8 97E8      	    ldi r25,hi8(1279999)
 4144 10ba A3E1      	    ldi r26,hlo8(1279999)
 4145 10bc 8150      	    1:subi r24,1
 4146 10be 9040      	    sbci r25,0
 4147 10c0 A040      	    sbci r26,0
 4148 10c2 01F4      	    brne 1b
 4149 10c4 00C0      		rjmp .
 4150 10c6 0000      		nop
 4151               	.LBE1287:
 4152               	.LBE1286:
   9:gps/gps.h     ****   _delay_ms(200);
  10:gps/gps.h     ****   PORT->OUTTGL = PWRPIN_bm;
 4153               		.loc 10 10 0
 4154 10c8 6783      		std Z+7,r22
 4155               	.LVL236:
 4156               	.LBB1288:
 4157               	.LBB1289:
 4158               		.loc 11 164 0
 4159 10ca 8AEA      		 ldi r24,lo8(26666666)
 4160 10cc 96EE      	    ldi r25,hi8(26666666)
 4161 10ce A6E9      	    ldi r26,hlo8(26666666)
 4162 10d0 B1E0      	    ldi r27,hhi8(26666666)
 4163 10d2 8150      	    1:subi r24,1
 4164 10d4 9040      	    sbci r25,0
 4165 10d6 A040      	    sbci r26,0
 4166 10d8 B040      	    sbci r27,0
 4167 10da 01F4      	    brne 1b
 4168 10dc 0000      		nop
 4169               	/* epilogue start */
 4170               	.LBE1289:
 4171               	.LBE1288:
  11:gps/gps.h     ****   // give gps time to boot up and start sending nmea string
  12:gps/gps.h     ****   _delay_ms(5000);
  13:gps/gps.h     **** }
 4172               		.loc 10 13 0
 4173 10de 0895      		ret
 4174               		.cfi_endproc
 4175               	.LFE69:
 4177               	.global	gps_init
 4179               	gps_init:
 4180               	.LFB70:
  14:gps/gps.h     **** 
  15:gps/gps.h     **** void gps_init(USART_t* USART, PORT_t* PORT, char PWRPIN_bm, char TXPIN_bm, char RESETPIN_bm) {
 4181               		.loc 10 15 0
 4182               		.cfi_startproc
 4183               	.LVL237:
 4184 10e0 0F93      		push r16
 4185               	.LCFI101:
 4186               		.cfi_def_cfa_offset 3
 4187               		.cfi_offset 16, -2
 4188               	/* prologue: function */
 4189               	/* frame size = 0 */
 4190               	/* stack size = 1 */
 4191               	.L__stack_usage = 1
 4192 10e2 FC01      		movw r30,r24
 4193 10e4 DB01      		movw r26,r22
 4194               	.LVL238:
 4195               	.LBB1290:
 4196               	.LBB1291:
 4197               		.loc 11 164 0
 4198 10e6 6FEF      		 ldi r22,lo8(9599999)
 4199 10e8 7BE7      	    ldi r23,hi8(9599999)
 4200 10ea 82E9      	    ldi r24,hlo8(9599999)
 4201 10ec 6150      	    1:subi r22,1
 4202 10ee 7040      	    sbci r23,0
 4203 10f0 8040      	    sbci r24,0
 4204 10f2 01F4      	    brne 1b
 4205               	.LVL239:
 4206 10f4 00C0      		rjmp .
 4207 10f6 0000      		nop
 4208               	.LBE1291:
 4209               	.LBE1290:
  16:gps/gps.h     ****   /*
  17:gps/gps.h     ****   
  18:gps/gps.h     ****   Port numbers, baud rate, etc will need to be changed when switching 
  19:gps/gps.h     ****   to a different port.  This is a bit complex to abstract out to a new 
  20:gps/gps.h     ****   code layer, but we'll give it our best shot.
  21:gps/gps.h     **** 
  22:gps/gps.h     ****   */
  23:gps/gps.h     **** 
  24:gps/gps.h     ****   // wait 1+ seconds after powering on, as recommended by a2235-h data sheet
  25:gps/gps.h     ****   _delay_ms(1500);
  26:gps/gps.h     **** 
  27:gps/gps.h     ****   //Binary logic notes
  28:gps/gps.h     **** 
  29:gps/gps.h     ****   //Flip a 0 to a 1
  30:gps/gps.h     ****   //00000000
  31:gps/gps.h     ****   //   OR
  32:gps/gps.h     ****   //00100000
  33:gps/gps.h     ****   //   =
  34:gps/gps.h     ****   //00100000
  35:gps/gps.h     **** 
  36:gps/gps.h     ****   //Flip a 1 to a 0
  37:gps/gps.h     ****   //00100000
  38:gps/gps.h     ****   //   ~
  39:gps/gps.h     ****   //11011111
  40:gps/gps.h     ****   //  AND
  41:gps/gps.h     ****   //00100000
  42:gps/gps.h     ****   //   =
  43:gps/gps.h     ****   //00000000
  44:gps/gps.h     **** 
  45:gps/gps.h     ****   //76543210
  46:gps/gps.h     **** 
  47:gps/gps.h     **** 
  48:gps/gps.h     **** 
  49:gps/gps.h     ****   // POWER PIN -- ON_OFF
  50:gps/gps.h     ****   // Set PD0 to low
  51:gps/gps.h     ****   PORT->DIRSET |= PWRPIN_bm;
 4210               		.loc 10 51 0
 4211 10f8 1196      		adiw r26,1
 4212 10fa 8C91      		ld r24,X
 4213 10fc 1197      		sbiw r26,1
 4214               	.LVL240:
 4215 10fe 842B      		or r24,r20
 4216 1100 1196      		adiw r26,1
 4217 1102 8C93      		st X,r24
 4218 1104 1197      		sbiw r26,1
  52:gps/gps.h     ****   PORT->OUTSET &= (~PWRPIN_bm);  
 4219               		.loc 10 52 0
 4220 1106 1596      		adiw r26,5
 4221 1108 9C91      		ld r25,X
 4222 110a 1597      		sbiw r26,5
 4223 110c 842F      		mov r24,r20
 4224 110e 8095      		com r24
 4225 1110 8923      		and r24,r25
 4226 1112 1596      		adiw r26,5
 4227 1114 8C93      		st X,r24
 4228 1116 1597      		sbiw r26,5
  53:gps/gps.h     **** 
  54:gps/gps.h     ****   // RESET PIN : Active LOW
  55:gps/gps.h     ****   // Set to output and send high
  56:gps/gps.h     ****   PORT->DIRSET |= RESETPIN_bm;
 4229               		.loc 10 56 0
 4230 1118 1196      		adiw r26,1
 4231 111a 8C91      		ld r24,X
 4232 111c 1197      		sbiw r26,1
 4233 111e 802B      		or r24,r16
 4234 1120 1196      		adiw r26,1
 4235 1122 8C93      		st X,r24
 4236 1124 1197      		sbiw r26,1
  57:gps/gps.h     ****   PORT->OUTSET |= RESETPIN_bm;
 4237               		.loc 10 57 0
 4238 1126 1596      		adiw r26,5
 4239 1128 8C91      		ld r24,X
 4240 112a 1597      		sbiw r26,5
 4241 112c 802B      		or r24,r16
 4242 112e 1596      		adiw r26,5
 4243 1130 8C93      		st X,r24
 4244 1132 1597      		sbiw r26,5
  58:gps/gps.h     **** 
  59:gps/gps.h     ****   // Set the TxD pin as an output - set PORT OUT register bit 3 to 1 
  60:gps/gps.h     ****   PORT->DIRSET |= TXPIN_bm; 
 4245               		.loc 10 60 0
 4246 1134 1196      		adiw r26,1
 4247 1136 8C91      		ld r24,X
 4248 1138 1197      		sbiw r26,1
 4249 113a 282B      		or r18,r24
 4250               	.LVL241:
 4251 113c 1196      		adiw r26,1
 4252 113e 2C93      		st X,r18
 4253 1140 1197      		sbiw r26,1
 4254               	.LVL242:
  61:gps/gps.h     **** 
  62:gps/gps.h     ****   //Baud rate of 4800 for nmea string communication
  63:gps/gps.h     ****   int BSEL = 12;
  64:gps/gps.h     ****   int BSCALE = 5;
  65:gps/gps.h     ****   USART->BAUDCTRLA = BSEL & 0xFF;
 4255               		.loc 10 65 0
 4256 1142 8CE0      		ldi r24,lo8(12)
 4257 1144 8683      		std Z+6,r24
  66:gps/gps.h     ****   USART->BAUDCTRLB = (BSCALE << 4) | (BSEL & 0xF000) >> 8;
 4258               		.loc 10 66 0
 4259 1146 80E5      		ldi r24,lo8(80)
 4260 1148 8783      		std Z+7,r24
  67:gps/gps.h     **** 
  68:gps/gps.h     ****   // no interrupts
  69:gps/gps.h     ****   // can't overwrite bits 7:6
  70:gps/gps.h     ****   USART->CTRLA = 0x00;
 4261               		.loc 10 70 0
 4262 114a 1382      		std Z+3,__zero_reg__
  71:gps/gps.h     **** 
  72:gps/gps.h     ****   // Enable transmitter and receiver
  73:gps/gps.h     ****   USART->CTRLB = USART_TXEN_bm | USART_RXEN_bm;  
 4263               		.loc 10 73 0
 4264 114c 88E1      		ldi r24,lo8(24)
 4265 114e 8483      		std Z+4,r24
  74:gps/gps.h     **** 
  75:gps/gps.h     ****   // async, no parity, 1 stop bit, 8 bit data,
  76:gps/gps.h     ****   // 00     00         0           011    
  77:gps/gps.h     ****   USART->CTRLC = 0x03;  
 4266               		.loc 10 77 0
 4267 1150 83E0      		ldi r24,lo8(3)
 4268 1152 8583      		std Z+5,r24
 4269               	.LVL243:
 4270               	.LBB1292:
 4271               	.LBB1293:
 4272               	.LBB1294:
 4273               	.LBB1295:
 4274               		.loc 11 164 0
 4275 1154 6FEF      		 ldi r22,lo8(12799999)
 4276 1156 7FE4      	    ldi r23,hi8(12799999)
 4277 1158 83EC      	    ldi r24,hlo8(12799999)
 4278 115a 6150      	    1:subi r22,1
 4279 115c 7040      	    sbci r23,0
 4280 115e 8040      	    sbci r24,0
 4281 1160 01F4      	    brne 1b
 4282 1162 00C0      		rjmp .
 4283 1164 0000      		nop
 4284               	.LBE1295:
 4285               	.LBE1294:
   8:gps/gps.h     ****   PORT->OUTSET |= PWRPIN_bm;
 4286               		.loc 10 8 0
 4287 1166 1596      		adiw r26,5
 4288 1168 8C91      		ld r24,X
 4289 116a 1597      		sbiw r26,5
 4290 116c 842B      		or r24,r20
 4291 116e 1596      		adiw r26,5
 4292 1170 8C93      		st X,r24
 4293 1172 1597      		sbiw r26,5
 4294               	.LVL244:
 4295               	.LBB1296:
 4296               	.LBB1297:
 4297               		.loc 11 164 0
 4298 1174 6FEF      		 ldi r22,lo8(1279999)
 4299 1176 77E8      	    ldi r23,hi8(1279999)
 4300 1178 83E1      	    ldi r24,hlo8(1279999)
 4301 117a 6150      	    1:subi r22,1
 4302 117c 7040      	    sbci r23,0
 4303 117e 8040      	    sbci r24,0
 4304 1180 01F4      	    brne 1b
 4305 1182 00C0      		rjmp .
 4306 1184 0000      		nop
 4307               	.LBE1297:
 4308               	.LBE1296:
  10:gps/gps.h     ****   PORT->OUTTGL = PWRPIN_bm;
 4309               		.loc 10 10 0
 4310 1186 1796      		adiw r26,7
 4311 1188 4C93      		st X,r20
 4312 118a 1797      		sbiw r26,7
 4313               	.LVL245:
 4314               	.LBB1298:
 4315               	.LBB1299:
 4316               		.loc 11 164 0
 4317 118c 8AEA      		 ldi r24,lo8(26666666)
 4318 118e 96EE      	    ldi r25,hi8(26666666)
 4319 1190 A6E9      	    ldi r26,hlo8(26666666)
 4320 1192 B1E0      	    ldi r27,hhi8(26666666)
 4321 1194 8150      	    1:subi r24,1
 4322 1196 9040      	    sbci r25,0
 4323 1198 A040      	    sbci r26,0
 4324 119a B040      	    sbci r27,0
 4325 119c 01F4      	    brne 1b
 4326 119e 0000      		nop
 4327               	/* epilogue start */
 4328               	.LBE1299:
 4329               	.LBE1298:
 4330               	.LBE1293:
 4331               	.LBE1292:
  78:gps/gps.h     **** 
  79:gps/gps.h     ****   // LOW/HIGH transmission of PD0 to wakeup gps module 
  80:gps/gps.h     ****   toggle_power_gps(PORT, PWRPIN_bm);
  81:gps/gps.h     **** 
  82:gps/gps.h     ****   // send_string("Wake up gps");
  83:gps/gps.h     **** }
 4332               		.loc 10 83 0
 4333 11a0 0F91      		pop r16
 4334               	.LVL246:
 4335 11a2 0895      		ret
 4336               		.cfi_endproc
 4337               	.LFE70:
 4339               		.data
 4340               	.LC2:
 4341 0005 2447 5052 		.string	"$GPRMC,"
 4341      4D43 2C00 
 4342               		.text
 4343               	.global	gps_receive
 4345               	gps_receive:
 4346               	.LFB71:
  84:gps/gps.h     **** 
  85:gps/gps.h     **** void gps_receive(USART_t* USART, latlng* gps) {
 4347               		.loc 10 85 0
 4348               		.cfi_startproc
 4349               	.LVL247:
 4350 11a4 9F92      		push r9
 4351               	.LCFI102:
 4352               		.cfi_def_cfa_offset 3
 4353               		.cfi_offset 9, -2
 4354 11a6 AF92      		push r10
 4355               	.LCFI103:
 4356               		.cfi_def_cfa_offset 4
 4357               		.cfi_offset 10, -3
 4358 11a8 BF92      		push r11
 4359               	.LCFI104:
 4360               		.cfi_def_cfa_offset 5
 4361               		.cfi_offset 11, -4
 4362 11aa CF92      		push r12
 4363               	.LCFI105:
 4364               		.cfi_def_cfa_offset 6
 4365               		.cfi_offset 12, -5
 4366 11ac DF92      		push r13
 4367               	.LCFI106:
 4368               		.cfi_def_cfa_offset 7
 4369               		.cfi_offset 13, -6
 4370 11ae EF92      		push r14
 4371               	.LCFI107:
 4372               		.cfi_def_cfa_offset 8
 4373               		.cfi_offset 14, -7
 4374 11b0 FF92      		push r15
 4375               	.LCFI108:
 4376               		.cfi_def_cfa_offset 9
 4377               		.cfi_offset 15, -8
 4378 11b2 0F93      		push r16
 4379               	.LCFI109:
 4380               		.cfi_def_cfa_offset 10
 4381               		.cfi_offset 16, -9
 4382 11b4 1F93      		push r17
 4383               	.LCFI110:
 4384               		.cfi_def_cfa_offset 11
 4385               		.cfi_offset 17, -10
 4386 11b6 CF93      		push r28
 4387               	.LCFI111:
 4388               		.cfi_def_cfa_offset 12
 4389               		.cfi_offset 28, -11
 4390 11b8 DF93      		push r29
 4391               	.LCFI112:
 4392               		.cfi_def_cfa_offset 13
 4393               		.cfi_offset 29, -12
 4394 11ba CDB7      		in r28,__SP_L__
 4395 11bc DEB7      		in r29,__SP_H__
 4396 11be CA5F      		subi r28,lo8(-(-250))
 4397 11c0 D040      		sbci r29,hi8(-(-250))
 4398               	.LCFI113:
 4399               		.cfi_def_cfa 28, 263
 4400 11c2 CDBF      		out __SP_L__,r28
 4401 11c4 DEBF      		out __SP_H__,r29
 4402               	/* prologue: function */
 4403               	/* frame size = 250 */
 4404               	/* stack size = 261 */
 4405               	.L__stack_usage = 261
 4406 11c6 DC01      		movw r26,r24
 4407 11c8 8B01      		movw r16,r22
 4408               	.LVL248:
  86:gps/gps.h     ****   //parsing out gps coordinates
  87:gps/gps.h     **** 
  88:gps/gps.h     ****   //code to look for to indicate start of gps coord string
  89:gps/gps.h     ****   char *code = "$GPRMC,";
  90:gps/gps.h     **** 
  91:gps/gps.h     ****   //length of code
  92:gps/gps.h     ****   int length = 7;
  93:gps/gps.h     **** 
  94:gps/gps.h     ****   //keep track of location in code
  95:gps/gps.h     ****   int index = 0;
  96:gps/gps.h     **** 
  97:gps/gps.h     ****   //indicates whether or not a gps string should be built
  98:gps/gps.h     ****   int read = 0;
  99:gps/gps.h     **** 
 100:gps/gps.h     ****   //buffer to hold gps string -- liberally sized
 101:gps/gps.h     ****   char buff[100];
 102:gps/gps.h     **** 
 103:gps/gps.h     ****   //keep track of position in buffer
 104:gps/gps.h     ****   int buff_index = 0;
 4409               		.loc 10 104 0
 4410 11ca 40E0      		ldi r20,lo8(0)
 4411 11cc 50E0      		ldi r21,hi8(0)
  98:gps/gps.h     ****   int read = 0;
 4412               		.loc 10 98 0
 4413 11ce 20E0      		ldi r18,lo8(0)
 4414 11d0 30E0      		ldi r19,hi8(0)
  95:gps/gps.h     ****   int index = 0;
 4415               		.loc 10 95 0
 4416 11d2 80E0      		ldi r24,lo8(0)
 4417 11d4 90E0      		ldi r25,hi8(0)
 4418               	.LVL249:
 4419               	.L183:
 4420               	.LBB1309:
 4421               	.LBB1310:
  30:uart/uart.h   ****     while ( !( USART->STATUS & USART_RXCIF_bm) ); 
 4422               		.loc 9 30 0
 4423 11d6 1196      		adiw r26,1
 4424 11d8 6C91      		ld r22,X
 4425 11da 1197      		sbiw r26,1
 4426 11dc 67FF      		sbrs r22,7
 4427 11de 00C0      		rjmp .L183
  33:uart/uart.h   ****     return USART->DATA; 
 4428               		.loc 9 33 0
 4429 11e0 6C91      		ld r22,X
 4430               	.LBE1310:
 4431               	.LBE1309:
 105:gps/gps.h     **** 
 106:gps/gps.h     ****   //char to store bytes from uart
 107:gps/gps.h     ****   char c; 
 108:gps/gps.h     **** 
 109:gps/gps.h     ****   //only terminates when break is hit
 110:gps/gps.h     ****   while (1) {
 111:gps/gps.h     ****     //pull char from uart
 112:gps/gps.h     ****     c = uart_getchar(USART);
 113:gps/gps.h     ****     if (index == length) {
 4432               		.loc 10 113 0
 4433 11e2 8730      		cpi r24,7
 4434 11e4 9105      		cpc r25,__zero_reg__
 4435 11e6 01F0      		breq .L172
 4436               	.LVL250:
 114:gps/gps.h     ****       //if past `length` characters match code set flip read to on
 115:gps/gps.h     ****       read = 1;
 116:gps/gps.h     ****     }
 117:gps/gps.h     **** 
 118:gps/gps.h     ****     if (read == 1) {
 4437               		.loc 10 118 0
 4438 11e8 2130      		cpi r18,1
 4439 11ea 3105      		cpc r19,__zero_reg__
 4440 11ec 01F0      		breq .L172
 119:gps/gps.h     ****       //build string
 120:gps/gps.h     ****       buff[buff_index] = c;
 121:gps/gps.h     ****       buff_index++;
 122:gps/gps.h     **** 
 123:gps/gps.h     ****       if (c == '\r' || c == '\n' || c == 'W' || c == 'E') {
 124:gps/gps.h     ****         //send full string
 125:gps/gps.h     ****         buff[buff_index] = '\0';
 126:gps/gps.h     ****         // send_string(buff);
 127:gps/gps.h     **** 
 128:gps/gps.h     ****         //additional parsing
 129:gps/gps.h     ****         parse_nmea(buff, gps);
 130:gps/gps.h     ****         break;
 131:gps/gps.h     ****       }
 132:gps/gps.h     ****     } else if (c == code[index]) {
 4441               		.loc 10 132 0
 4442 11ee FC01      		movw r30,r24
 4443 11f0 E050      		subi r30,lo8(-(.LC2))
 4444 11f2 F040      		sbci r31,hi8(-(.LC2))
 4445 11f4 7081      		ld r23,Z
 4446 11f6 7617      		cp r23,r22
 4447 11f8 01F0      		breq .L184
 133:gps/gps.h     ****       //char from matches corresponding char in code
 134:gps/gps.h     ****       index++;
 135:gps/gps.h     ****     } else {
 136:gps/gps.h     ****       //incorrect character, reset counter
 137:gps/gps.h     ****       index = 0;
 4448               		.loc 10 137 0
 4449 11fa 80E0      		ldi r24,lo8(0)
 4450 11fc 90E0      		ldi r25,hi8(0)
 4451 11fe 00C0      		rjmp .L183
 4452               	.LVL251:
 4453               	.L172:
 120:gps/gps.h     ****       buff[buff_index] = c;
 4454               		.loc 10 120 0
 4455 1200 E7E9      		ldi r30,lo8(151)
 4456 1202 F0E0      		ldi r31,hi8(151)
 4457 1204 EC0F      		add r30,r28
 4458 1206 FD1F      		adc r31,r29
 4459 1208 E40F      		add r30,r20
 4460 120a F51F      		adc r31,r21
 4461 120c 6083      		st Z,r22
 121:gps/gps.h     ****       buff_index++;
 4462               		.loc 10 121 0
 4463 120e 4F5F      		subi r20,lo8(-(1))
 4464 1210 5F4F      		sbci r21,hi8(-(1))
 4465               	.LVL252:
 123:gps/gps.h     ****       if (c == '\r' || c == '\n' || c == 'W' || c == 'E') {
 4466               		.loc 10 123 0
 4467 1212 6D30      		cpi r22,lo8(13)
 4468 1214 01F0      		breq .L174
 123:gps/gps.h     ****       if (c == '\r' || c == '\n' || c == 'W' || c == 'E') {
 4469               		.loc 10 123 0 is_stmt 0 discriminator 1
 4470 1216 6A30      		cpi r22,lo8(10)
 4471 1218 01F0      		breq .L174
 4472 121a 6735      		cpi r22,lo8(87)
 4473 121c 01F0      		breq .L174
 4474 121e 6534      		cpi r22,lo8(69)
 4475 1220 01F0      		breq .L174
 123:gps/gps.h     ****       if (c == '\r' || c == '\n' || c == 'W' || c == 'E') {
 4476               		.loc 10 123 0
 4477 1222 21E0      		ldi r18,lo8(1)
 4478 1224 30E0      		ldi r19,hi8(1)
 4479 1226 00C0      		rjmp .L183
 4480               	.LVL253:
 4481               	.L184:
 134:gps/gps.h     ****       index++;
 4482               		.loc 10 134 0 is_stmt 1
 4483 1228 0196      		adiw r24,1
 4484               	.LVL254:
 4485 122a 00C0      		rjmp .L183
 4486               	.LVL255:
 4487               	.L174:
 125:gps/gps.h     ****         buff[buff_index] = '\0';
 4488               		.loc 10 125 0
 4489 122c 27E9      		ldi r18,lo8(151)
 4490 122e 30E0      		ldi r19,hi8(151)
 4491 1230 2C0F      		add r18,r28
 4492 1232 3D1F      		adc r19,r29
 4493 1234 420F      		add r20,r18
 4494 1236 531F      		adc r21,r19
 4495               	.LVL256:
 4496 1238 DA01      		movw r26,r20
 4497               	.LVL257:
 4498 123a 1C92      		st X,__zero_reg__
 4499               	.LVL258:
 4500               	.LBB1311:
 4501               	.LBB1312:
 100:nmea/nmea.h   ****     parse_nmea_string(buff, gps);
 4502               		.loc 8 100 0
 4503 123c C901      		movw r24,r18
 4504 123e B801      		movw r22,r16
 4505 1240 0E94 0000 		call parse_nmea_string
 103:nmea/nmea.h   ****     if (gps->dist > max_dist) {
 4506               		.loc 8 103 0
 4507 1244 F801      		movw r30,r16
 4508 1246 6085      		ldd r22,Z+8
 4509 1248 7185      		ldd r23,Z+9
 4510 124a 8285      		ldd r24,Z+10
 4511 124c 9385      		ldd r25,Z+11
 4512 124e 2091 0000 		lds r18,max_dist
 4513 1252 3091 0000 		lds r19,max_dist+1
 4514 1256 4091 0000 		lds r20,max_dist+2
 4515 125a 5091 0000 		lds r21,max_dist+3
 4516 125e 0E94 0000 		call __gtsf2
 4517 1262 1816      		cp __zero_reg__,r24
 4518 1264 04F0      		brlt .+2
 4519 1266 00C0      		rjmp .L169
 4520               	.LBB1313:
 109:nmea/nmea.h   ****       sprintf(lat_buff, "%f", gps->lat);
 4521               		.loc 8 109 0
 4522 1268 2DB7      		in r18,__SP_L__
 4523 126a 3EB7      		in r19,__SP_H__
 4524 126c 2850      		subi r18,lo8(-(-8))
 4525 126e 3040      		sbci r19,hi8(-(-8))
 4526 1270 2DBF      		out __SP_L__,r18
 4527 1272 3EBF      		out __SP_H__,r19
 4528 1274 2F5F      		subi r18,lo8(-(1))
 4529 1276 3F4F      		sbci r19,hi8(-(1))
 4530 1278 65E6      		ldi r22,lo8(101)
 4531 127a E62E      		mov r14,r22
 4532 127c F12C      		mov r15,__zero_reg__
 4533 127e EC0E      		add r14,r28
 4534 1280 FD1E      		adc r15,r29
 4535 1282 ADB7      		in r26,__SP_L__
 4536 1284 BEB7      		in r27,__SP_H__
 4537 1286 1196      		adiw r26,1
 4538 1288 ED92      		st X+,r14
 4539 128a FC92      		st X,r15
 4540 128c 1297      		sbiw r26,1+1
 4541 128e 70E0      		ldi r23,lo8(.LC1)
 4542 1290 C72E      		mov r12,r23
 4543 1292 70E0      		ldi r23,hi8(.LC1)
 4544 1294 D72E      		mov r13,r23
 4545 1296 F901      		movw r30,r18
 4546 1298 C282      		std Z+2,r12
 4547 129a D382      		std Z+3,r13
 4548 129c F801      		movw r30,r16
 4549 129e 8081      		ld r24,Z
 4550 12a0 9181      		ldd r25,Z+1
 4551 12a2 A281      		ldd r26,Z+2
 4552 12a4 B381      		ldd r27,Z+3
 4553 12a6 F901      		movw r30,r18
 4554 12a8 8483      		std Z+4,r24
 4555 12aa 9583      		std Z+5,r25
 4556 12ac A683      		std Z+6,r26
 4557 12ae B783      		std Z+7,r27
 4558               		.cfi_escape 0x2e,0x8
 4559 12b0 0E94 0000 		call sprintf
 110:nmea/nmea.h   ****       sprintf(lng_buff, "%f", gps->lng);
 4560               		.loc 8 110 0
 4561 12b4 2DB7      		in r18,__SP_L__
 4562 12b6 3EB7      		in r19,__SP_H__
 4563 12b8 2F5F      		subi r18,lo8(-(1))
 4564 12ba 3F4F      		sbci r19,hi8(-(1))
 4565 12bc 83E3      		ldi r24,lo8(51)
 4566 12be A82E      		mov r10,r24
 4567 12c0 B12C      		mov r11,__zero_reg__
 4568 12c2 AC0E      		add r10,r28
 4569 12c4 BD1E      		adc r11,r29
 4570 12c6 ADB7      		in r26,__SP_L__
 4571 12c8 BEB7      		in r27,__SP_H__
 4572 12ca 1196      		adiw r26,1
 4573 12cc AD92      		st X+,r10
 4574 12ce BC92      		st X,r11
 4575 12d0 1297      		sbiw r26,1+1
 4576 12d2 F901      		movw r30,r18
 4577 12d4 C282      		std Z+2,r12
 4578 12d6 D382      		std Z+3,r13
 4579 12d8 F801      		movw r30,r16
 4580 12da 8481      		ldd r24,Z+4
 4581 12dc 9581      		ldd r25,Z+5
 4582 12de A681      		ldd r26,Z+6
 4583 12e0 B781      		ldd r27,Z+7
 4584 12e2 F901      		movw r30,r18
 4585 12e4 8483      		std Z+4,r24
 4586 12e6 9583      		std Z+5,r25
 4587 12e8 A683      		std Z+6,r26
 4588 12ea B783      		std Z+7,r27
 4589 12ec 0E94 0000 		call sprintf
 111:nmea/nmea.h   ****       sprintf(dist_buff, "%f", gps->dist);
 4590               		.loc 8 111 0
 4591 12f0 2DB7      		in r18,__SP_L__
 4592 12f2 3EB7      		in r19,__SP_H__
 4593 12f4 2F5F      		subi r18,lo8(-(1))
 4594 12f6 3F4F      		sbci r19,hi8(-(1))
 4595 12f8 CE01      		movw r24,r28
 4596 12fa 0196      		adiw r24,1
 4597 12fc ADB7      		in r26,__SP_L__
 4598 12fe BEB7      		in r27,__SP_H__
 4599 1300 1196      		adiw r26,1
 4600 1302 8D93      		st X+,r24
 4601 1304 9C93      		st X,r25
 4602 1306 1297      		sbiw r26,1+1
 4603 1308 F901      		movw r30,r18
 4604 130a C282      		std Z+2,r12
 4605 130c D382      		std Z+3,r13
 4606 130e F801      		movw r30,r16
 4607 1310 8085      		ldd r24,Z+8
 4608 1312 9185      		ldd r25,Z+9
 4609 1314 A285      		ldd r26,Z+10
 4610 1316 B385      		ldd r27,Z+11
 4611 1318 F901      		movw r30,r18
 4612 131a 8483      		std Z+4,r24
 4613 131c 9583      		std Z+5,r25
 4614 131e A683      		std Z+6,r26
 4615 1320 B783      		std Z+7,r27
 4616 1322 0E94 0000 		call sprintf
 4617               	.LVL259:
 4618               	.LBB1314:
 4619               	.LBB1315:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 4620               		.loc 7 16 0
 4621 1326 D701      		movw r26,r14
 4622 1328 0D90      		ld __tmp_reg__,X+
 4623 132a 0020      		tst __tmp_reg__
 4624 132c 01F4      		brne .-6
 4625 132e CD01      		movw r24,r26
 4626 1330 8E19      		sub r24,r14
 4627 1332 9F09      		sbc r25,r15
 4628 1334 EDB7      		in r30,__SP_L__
 4629 1336 FEB7      		in r31,__SP_H__
 4630 1338 3896      		adiw r30,8
 4631 133a EDBF      		out __SP_L__,r30
 4632 133c FEBF      		out __SP_H__,r31
 4633               	.LVL260:
 4634 133e 0196      		adiw r24,1
 4635               		.cfi_escape 0x2e,0
 4636 1340 0E94 0000 		call malloc
 4637               	.LVL261:
 4638 1344 992E      		mov r9,r25
 4639 1346 C82E      		mov r12,r24
 4640 1348 D92E      		mov r13,r25
 4641               	.LVL262:
  18:utils/utils.h ****     strcpy(result, s1);
 4642               		.loc 7 18 0
 4643 134a C601      		movw r24,r12
 4644 134c B701      		movw r22,r14
 4645 134e 0E94 0000 		call strcpy
  19:utils/utils.h ****     strcat(result, s2);
 4646               		.loc 7 19 0
 4647 1352 EC2D      		mov r30,r12
 4648 1354 F92D      		mov r31,r9
 4649 1356 DF01      		movw r26,r30
 4650 1358 0D90      		ld __tmp_reg__,X+
 4651 135a 0020      		tst __tmp_reg__
 4652 135c 01F4      		brne .-6
 4653 135e 1197      		sbiw r26,1
 4654 1360 AE1B      		sub r26,r30
 4655 1362 BF0B      		sbc r27,r31
 4656 1364 AC0D      		add r26,r12
 4657 1366 BD1D      		adc r27,r13
 4658 1368 8CE2      		ldi r24,lo8(44)
 4659 136a 90E0      		ldi r25,hi8(44)
 4660 136c 8D93      		st X+,r24
 4661 136e 9C93      		st X,r25
 4662               	.LVL263:
 4663               	.LBE1315:
 4664               	.LBE1314:
 4665               	.LBB1316:
 4666               	.LBB1317:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 4667               		.loc 7 16 0
 4668 1370 AC2D      		mov r26,r12
 4669 1372 B92D      		mov r27,r9
 4670 1374 FD01      		movw r30,r26
 4671 1376 0190      		ld __tmp_reg__,Z+
 4672 1378 0020      		tst __tmp_reg__
 4673 137a 01F4      		brne .-6
 4674 137c 9F01      		movw r18,r30
 4675 137e F501      		movw r30,r10
 4676 1380 0190      		ld __tmp_reg__,Z+
 4677 1382 0020      		tst __tmp_reg__
 4678 1384 01F4      		brne .-6
 4679 1386 CF01      		movw r24,r30
 4680 1388 0197      		sbiw r24,1
 4681 138a 8A19      		sub r24,r10
 4682 138c 9B09      		sbc r25,r11
 4683 138e 8A1B      		sub r24,r26
 4684 1390 9B0B      		sbc r25,r27
 4685 1392 820F      		add r24,r18
 4686 1394 931F      		adc r25,r19
 4687 1396 0E94 0000 		call malloc
 4688 139a E82E      		mov r14,r24
 4689 139c 992E      		mov r9,r25
 4690               	.LVL264:
  18:utils/utils.h ****     strcpy(result, s1);
 4691               		.loc 7 18 0
 4692 139e B601      		movw r22,r12
 4693 13a0 0E94 0000 		call strcpy
 4694               	.LVL265:
  19:utils/utils.h ****     strcat(result, s2);
 4695               		.loc 7 19 0
 4696 13a4 8E2D      		mov r24,r14
 4697 13a6 992D      		mov r25,r9
 4698 13a8 B501      		movw r22,r10
 4699 13aa 0E94 0000 		call strcat
 4700               	.LBE1317:
 4701               	.LBE1316:
 138:nmea/nmea.h   ****       gps->sms = concat(concat(lat_str, ","), lng_str);
 4702               		.loc 8 138 0
 4703 13ae D801      		movw r26,r16
 4704 13b0 1E96      		adiw r26,14
 4705 13b2 EC92      		st X,r14
 4706 13b4 1E97      		sbiw r26,14
 4707 13b6 1F96      		adiw r26,15
 4708 13b8 9C92      		st X,r9
 4709 13ba 1F97      		sbiw r26,15
 4710               	.LVL266:
 4711               	.L169:
 4712               	/* epilogue start */
 4713               	.LBE1313:
 4714               	.LBE1312:
 4715               	.LBE1311:
 138:gps/gps.h     ****     }
 139:gps/gps.h     ****   }
 140:gps/gps.h     **** }
 4716               		.loc 10 140 0
 4717 13bc C650      		subi r28,lo8(-(250))
 4718 13be DF4F      		sbci r29,hi8(-(250))
 4719 13c0 CDBF      		out __SP_L__,r28
 4720 13c2 DEBF      		out __SP_H__,r29
 4721 13c4 DF91      		pop r29
 4722 13c6 CF91      		pop r28
 4723 13c8 1F91      		pop r17
 4724 13ca 0F91      		pop r16
 4725               	.LVL267:
 4726 13cc FF90      		pop r15
 4727 13ce EF90      		pop r14
 4728 13d0 DF90      		pop r13
 4729 13d2 CF90      		pop r12
 4730 13d4 BF90      		pop r11
 4731 13d6 AF90      		pop r10
 4732 13d8 9F90      		pop r9
 4733 13da 0895      		ret
 4734               		.cfi_endproc
 4735               	.LFE71:
 4737               	.global	wake_up_gprs
 4739               	wake_up_gprs:
 4740               	.LFB72:
 4741               		.file 12 "gprs/gprs.h"
   1:gprs/gprs.h   **** void wake_up_gprs(void);
   2:gprs/gprs.h   **** void gprs_init(USART_t* USART, PORT_t* PORT, char TXPIN_bm);
   3:gprs/gprs.h   **** 
   4:gprs/gprs.h   **** void wake_up_gprs(void) {
 4742               		.loc 12 4 0
 4743               		.cfi_startproc
 4744               	/* prologue: function */
 4745               	/* frame size = 0 */
 4746               	/* stack size = 0 */
 4747               	.L__stack_usage = 0
 4748               	/* epilogue start */
   5:gprs/gprs.h   ****   // 
   6:gprs/gprs.h   **** }
 4749               		.loc 12 6 0
 4750 13dc 0895      		ret
 4751               		.cfi_endproc
 4752               	.LFE72:
 4754               	.global	gprs_init
 4756               	gprs_init:
 4757               	.LFB73:
   7:gprs/gprs.h   **** 
   8:gprs/gprs.h   **** void gprs_init(USART_t* USART, PORT_t* PORT, char TXPIN_bm) {
 4758               		.loc 12 8 0
 4759               		.cfi_startproc
 4760               	.LVL268:
 4761               	/* prologue: function */
 4762               	/* frame size = 0 */
 4763               	/* stack size = 0 */
 4764               	.L__stack_usage = 0
 4765 13de FC01      		movw r30,r24
 4766 13e0 DB01      		movw r26,r22
   9:gprs/gprs.h   ****   //change port numbers when we get our proto board
  10:gprs/gprs.h   **** 
  11:gprs/gprs.h   ****   wake_up_gprs();
  12:gprs/gprs.h   **** 
  13:gprs/gprs.h   ****   // Set the TxD pin as an output - set PORTD OUT register bit 3 to 1 
  14:gprs/gprs.h   ****   PORT->DIRSET = TXPIN_bm; 
 4767               		.loc 12 14 0
 4768 13e2 1196      		adiw r26,1
 4769 13e4 4C93      		st X,r20
 4770 13e6 1197      		sbiw r26,1
  15:gprs/gprs.h   **** 
  16:gprs/gprs.h   ****   // Set the TxD pin high - set PORTD DIR register bit 3 to 1 
  17:gprs/gprs.h   ****   PORT->OUTSET = TXPIN_bm; 
 4771               		.loc 12 17 0
 4772 13e8 1596      		adiw r26,5
 4773 13ea 4C93      		st X,r20
 4774 13ec 1597      		sbiw r26,5
 4775               	.LVL269:
  18:gprs/gprs.h   **** 
  19:gprs/gprs.h   ****   //Baud rate of 19200
  20:gprs/gprs.h   ****   uint16_t BSEL = 12;
  21:gprs/gprs.h   ****   uint8_t BSCALE = 3;
  22:gprs/gprs.h   ****   USART->BAUDCTRLA = BSEL & 0XFF;
 4776               		.loc 12 22 0
 4777 13ee 8CE0      		ldi r24,lo8(12)
 4778               	.LVL270:
 4779 13f0 8683      		std Z+6,r24
  23:gprs/gprs.h   ****   USART->BAUDCTRLB = (BSCALE << 4) | (BSEL & 0xF000) >> 8;
 4780               		.loc 12 23 0
 4781 13f2 80E3      		ldi r24,lo8(48)
 4782 13f4 8783      		std Z+7,r24
  24:gprs/gprs.h   **** 
  25:gprs/gprs.h   ****   // no interrupts
  26:gprs/gprs.h   ****   // can't overwrite bits 7:6
  27:gprs/gprs.h   ****   USART->CTRLA = 0x00;
 4783               		.loc 12 27 0
 4784 13f6 1382      		std Z+3,__zero_reg__
  28:gprs/gprs.h   **** 
  29:gprs/gprs.h   ****   // Enable transmitter and receiver
  30:gprs/gprs.h   ****   USART->CTRLB = USART_TXEN_bm | USART_RXEN_bm;  
 4785               		.loc 12 30 0
 4786 13f8 88E1      		ldi r24,lo8(24)
 4787 13fa 8483      		std Z+4,r24
  31:gprs/gprs.h   **** 
  32:gprs/gprs.h   ****   // async, no parity, 1 stop bit, 8 bit data,
  33:gprs/gprs.h   ****   // 00     00         00          11    
  34:gprs/gprs.h   ****   USART->CTRLC = 0x03;  
 4788               		.loc 12 34 0
 4789 13fc 83E0      		ldi r24,lo8(3)
 4790 13fe 8583      		std Z+5,r24
 4791               	/* epilogue start */
  35:gprs/gprs.h   **** }...
 4792               		.loc 12 35 0
 4793 1400 0895      		ret
 4794               		.cfi_endproc
 4795               	.LFE73:
 4797               		.data
 4798               	.LC3:
 4799 000d 4154 2B43 		.string	"AT+CMGF=1"
 4799      4D47 463D 
 4799      3100 
 4800               	.LC4:
 4801 0017 4154 2B43 		.string	"AT+CMGS=\""
 4801      4D47 533D 
 4801      2200 
 4802               		.text
 4803               	.global	send_message
 4805               	send_message:
 4806               	.LFB74:
 4807               		.file 13 "sms/sms.h"
   1:sms/sms.h     **** #include "Framework.h"
   2:sms/sms.h     **** #include <avr/io.h>
   3:sms/sms.h     **** #include <stdlib.h>
   4:sms/sms.h     **** #include <string.h>
   5:sms/sms.h     **** 
   6:sms/sms.h     **** void send_message(char*, char*, USART_t*);
   7:sms/sms.h     **** char* read_message(USART_t*);
   8:sms/sms.h     **** void delSMS(USART_t*);
   9:sms/sms.h     **** void GprsTextModeSMS(USART_t*);
  10:sms/sms.h     **** void ClearGprsMsg(void);
  11:sms/sms.h     **** void GprsReadSmsStore(char* SmsStorePos, USART_t* USART);
  12:sms/sms.h     **** void ProcessGprsMsg(USART_t*);
  13:sms/sms.h     **** void ProcessSms(char* sms);
  14:sms/sms.h     **** void ReceiveTextMessage(USART_t*);
  15:sms/sms.h     **** void SimpleReceive();
  16:sms/sms.h     **** 
  17:sms/sms.h     **** void send_message(char* number, char* text_message, USART_t* USART) {
 4808               		.loc 13 17 0
 4809               		.cfi_startproc
 4810               	.LVL271:
 4811 1402 AF92      		push r10
 4812               	.LCFI114:
 4813               		.cfi_def_cfa_offset 3
 4814               		.cfi_offset 10, -2
 4815 1404 BF92      		push r11
 4816               	.LCFI115:
 4817               		.cfi_def_cfa_offset 4
 4818               		.cfi_offset 11, -3
 4819 1406 CF92      		push r12
 4820               	.LCFI116:
 4821               		.cfi_def_cfa_offset 5
 4822               		.cfi_offset 12, -4
 4823 1408 DF92      		push r13
 4824               	.LCFI117:
 4825               		.cfi_def_cfa_offset 6
 4826               		.cfi_offset 13, -5
 4827 140a EF92      		push r14
 4828               	.LCFI118:
 4829               		.cfi_def_cfa_offset 7
 4830               		.cfi_offset 14, -6
 4831 140c FF92      		push r15
 4832               	.LCFI119:
 4833               		.cfi_def_cfa_offset 8
 4834               		.cfi_offset 15, -7
 4835 140e 0F93      		push r16
 4836               	.LCFI120:
 4837               		.cfi_def_cfa_offset 9
 4838               		.cfi_offset 16, -8
 4839 1410 1F93      		push r17
 4840               	.LCFI121:
 4841               		.cfi_def_cfa_offset 10
 4842               		.cfi_offset 17, -9
 4843 1412 CF93      		push r28
 4844               	.LCFI122:
 4845               		.cfi_def_cfa_offset 11
 4846               		.cfi_offset 28, -10
 4847 1414 DF93      		push r29
 4848               	.LCFI123:
 4849               		.cfi_def_cfa_offset 12
 4850               		.cfi_offset 29, -11
 4851               	/* prologue: function */
 4852               	/* frame size = 0 */
 4853               	/* stack size = 10 */
 4854               	.L__stack_usage = 10
 4855 1416 F82E      		mov r15,r24
 4856 1418 E92E      		mov r14,r25
 4857 141a 6B01      		movw r12,r22
 4858 141c EA01      		movw r28,r20
 4859               	.LVL272:
 4860               	.L188:
 4861               	.LBB1338:
 4862               	.LBB1339:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 4863               		.loc 9 18 0
 4864 141e 8981      		ldd r24,Y+1
 4865 1420 85FF      		sbrs r24,5
 4866 1422 00C0      		rjmp .L188
  21:uart/uart.h   ****     USART->DATA = c; 
 4867               		.loc 9 21 0
 4868 1424 8DE0      		ldi r24,lo8(13)
 4869 1426 8883      		st Y,r24
 4870               	.LVL273:
 4871               	.LBE1339:
 4872               	.LBE1338:
 4873               	.LBB1340:
 4874               	.LBB1341:
 4875               		.loc 11 164 0
 4876 1428 8FEF      		 ldi r24,lo8(639999)
 4877 142a 93EC      	    ldi r25,hi8(639999)
 4878 142c A9E0      	    ldi r26,hlo8(639999)
 4879 142e 8150      	    1:subi r24,1
 4880 1430 9040      	    sbci r25,0
 4881 1432 A040      	    sbci r26,0
 4882 1434 01F4      	    brne 1b
 4883 1436 00C0      		rjmp .
 4884 1438 0000      		nop
 4885               	.LVL274:
 4886               	.LBE1341:
 4887               	.LBE1340:
 4888               	.LBB1342:
 4889               	.LBB1343:
  18:sms/sms.h     **** 
  19:sms/sms.h     ****   uart_putchar('\r', USART);
  20:sms/sms.h     ****   _delay_ms(100);
  21:sms/sms.h     **** 
  22:sms/sms.h     ****   GprsTextModeSMS(USART);
  23:sms/sms.h     ****   _delay_ms(100);
  24:sms/sms.h     ****   // send_string("GPS TEXT MODE");
  25:sms/sms.h     **** 
  26:sms/sms.h     ****   //build number string
  27:sms/sms.h     ****   char* number_string = concat(concat("AT+CMGS=\"", number), "\"");
  28:sms/sms.h     ****   send_uart(number_string, USART);
  29:sms/sms.h     ****   _delay_ms(100);
  30:sms/sms.h     ****   // send_string(number_string);
  31:sms/sms.h     **** 
  32:sms/sms.h     ****   send_uart(text_message, USART);
  33:sms/sms.h     ****   _delay_ms(100);
  34:sms/sms.h     ****   // send_string(text_message);
  35:sms/sms.h     **** 
  36:sms/sms.h     ****   uart_putchar(26, USART);
  37:sms/sms.h     ****   _delay_ms(100);
  38:sms/sms.h     ****   // send_string("COMPLETE");
  39:sms/sms.h     **** }
  40:sms/sms.h     **** 
  41:sms/sms.h     **** void GprsTextModeSMS(USART_t* USART) {
  42:sms/sms.h     ****   send_uart("AT+CMGF=1", USART);
 4890               		.loc 13 42 0
 4891 143a 80E0      		ldi r24,lo8(.LC3)
 4892 143c 90E0      		ldi r25,hi8(.LC3)
 4893 143e BE01      		movw r22,r28
 4894 1440 0E94 0000 		call send_uart
 4895               	.LVL275:
 4896               	.LBE1343:
 4897               	.LBE1342:
 4898               	.LBB1344:
 4899               	.LBB1345:
 4900               		.loc 11 164 0
 4901 1444 8FEF      		 ldi r24,lo8(639999)
 4902 1446 93EC      	    ldi r25,hi8(639999)
 4903 1448 A9E0      	    ldi r26,hlo8(639999)
 4904 144a 8150      	    1:subi r24,1
 4905 144c 9040      	    sbci r25,0
 4906 144e A040      	    sbci r26,0
 4907 1450 01F4      	    brne 1b
 4908 1452 00C0      		rjmp .
 4909 1454 0000      		nop
 4910               	.LVL276:
 4911               	.LBE1345:
 4912               	.LBE1344:
 4913               	.LBB1346:
 4914               	.LBB1347:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 4915               		.loc 7 16 0
 4916 1456 EF2D      		mov r30,r15
 4917 1458 FE2D      		mov r31,r14
 4918 145a DF01      		movw r26,r30
 4919 145c 0D90      		ld __tmp_reg__,X+
 4920 145e 0020      		tst __tmp_reg__
 4921 1460 01F4      		brne .-6
 4922 1462 CD01      		movw r24,r26
 4923 1464 8E1B      		sub r24,r30
 4924 1466 9F0B      		sbc r25,r31
 4925 1468 0996      		adiw r24,9
 4926 146a 0E94 0000 		call malloc
 4927 146e 182F      		mov r17,r24
 4928 1470 092F      		mov r16,r25
 4929               	.LVL277:
  18:utils/utils.h ****     strcpy(result, s1);
 4930               		.loc 7 18 0
 4931 1472 E82F      		mov r30,r24
 4932 1474 F92F      		mov r31,r25
 4933 1476 A0E0      		ldi r26,lo8(.LC4)
 4934 1478 B0E0      		ldi r27,hi8(.LC4)
 4935 147a 8AE0      		ldi r24,lo8(10)
 4936               	.LVL278:
 4937               	.L189:
 4938 147c 0D90      		ld r0,X+
 4939 147e 0192      		st Z+,r0
 4940 1480 8150      		subi r24,lo8(-(-1))
 4941 1482 01F4      		brne .L189
  19:utils/utils.h ****     strcat(result, s2);
 4942               		.loc 7 19 0
 4943 1484 812F      		mov r24,r17
 4944 1486 902F      		mov r25,r16
 4945               	.LVL279:
 4946 1488 6F2D      		mov r22,r15
 4947 148a 7E2D      		mov r23,r14
 4948 148c 0E94 0000 		call strcat
 4949               	.LVL280:
 4950               	.LBE1347:
 4951               	.LBE1346:
 4952               	.LBB1348:
 4953               	.LBB1349:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 4954               		.loc 7 16 0
 4955 1490 E12F      		mov r30,r17
 4956 1492 F02F      		mov r31,r16
 4957 1494 DF01      		movw r26,r30
 4958 1496 0D90      		ld __tmp_reg__,X+
 4959 1498 0020      		tst __tmp_reg__
 4960 149a 01F4      		brne .-6
 4961 149c CD01      		movw r24,r26
 4962 149e 8E1B      		sub r24,r30
 4963 14a0 9F0B      		sbc r25,r31
 4964 14a2 0196      		adiw r24,1
 4965 14a4 0E94 0000 		call malloc
 4966 14a8 F92E      		mov r15,r25
 4967               	.LVL281:
 4968 14aa A82E      		mov r10,r24
 4969 14ac B92E      		mov r11,r25
 4970               	.LVL282:
  18:utils/utils.h ****     strcpy(result, s1);
 4971               		.loc 7 18 0
 4972 14ae C501      		movw r24,r10
 4973 14b0 612F      		mov r22,r17
 4974 14b2 702F      		mov r23,r16
 4975 14b4 0E94 0000 		call strcpy
  19:utils/utils.h ****     strcat(result, s2);
 4976               		.loc 7 19 0
 4977 14b8 AA2D      		mov r26,r10
 4978 14ba BF2D      		mov r27,r15
 4979 14bc FD01      		movw r30,r26
 4980 14be 0190      		ld __tmp_reg__,Z+
 4981 14c0 0020      		tst __tmp_reg__
 4982 14c2 01F4      		brne .-6
 4983 14c4 3197      		sbiw r30,1
 4984 14c6 EA1B      		sub r30,r26
 4985 14c8 FB0B      		sbc r31,r27
 4986 14ca EA0D      		add r30,r10
 4987 14cc FB1D      		adc r31,r11
 4988 14ce 82E2      		ldi r24,lo8(34)
 4989 14d0 90E0      		ldi r25,hi8(34)
 4990 14d2 8083      		st Z,r24
 4991 14d4 9183      		std Z+1,r25
 4992               	.LBE1349:
 4993               	.LBE1348:
  28:sms/sms.h     ****   send_uart(number_string, USART);
 4994               		.loc 13 28 0
 4995 14d6 C501      		movw r24,r10
 4996 14d8 BE01      		movw r22,r28
 4997 14da 0E94 0000 		call send_uart
 4998               	.LVL283:
 4999               	.LBB1350:
 5000               	.LBB1351:
 5001               		.loc 11 164 0
 5002 14de 8FEF      		 ldi r24,lo8(639999)
 5003 14e0 93EC      	    ldi r25,hi8(639999)
 5004 14e2 A9E0      	    ldi r26,hlo8(639999)
 5005 14e4 8150      	    1:subi r24,1
 5006 14e6 9040      	    sbci r25,0
 5007 14e8 A040      	    sbci r26,0
 5008 14ea 01F4      	    brne 1b
 5009 14ec 00C0      		rjmp .
 5010 14ee 0000      		nop
 5011               	.LBE1351:
 5012               	.LBE1350:
  32:sms/sms.h     ****   send_uart(text_message, USART);
 5013               		.loc 13 32 0
 5014 14f0 C601      		movw r24,r12
 5015 14f2 BE01      		movw r22,r28
 5016 14f4 0E94 0000 		call send_uart
 5017               	.LVL284:
 5018               	.LBB1352:
 5019               	.LBB1353:
 5020               		.loc 11 164 0
 5021 14f8 8FEF      		 ldi r24,lo8(639999)
 5022 14fa 93EC      	    ldi r25,hi8(639999)
 5023 14fc A9E0      	    ldi r26,hlo8(639999)
 5024 14fe 8150      	    1:subi r24,1
 5025 1500 9040      	    sbci r25,0
 5026 1502 A040      	    sbci r26,0
 5027 1504 01F4      	    brne 1b
 5028 1506 00C0      		rjmp .
 5029 1508 0000      		nop
 5030               	.LVL285:
 5031               	.L190:
 5032               	.LBE1353:
 5033               	.LBE1352:
 5034               	.LBB1354:
 5035               	.LBB1355:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 5036               		.loc 9 18 0
 5037 150a 8981      		ldd r24,Y+1
 5038 150c 85FF      		sbrs r24,5
 5039 150e 00C0      		rjmp .L190
  21:uart/uart.h   ****     USART->DATA = c; 
 5040               		.loc 9 21 0
 5041 1510 8AE1      		ldi r24,lo8(26)
 5042 1512 8883      		st Y,r24
 5043               	.LVL286:
 5044               	.LBE1355:
 5045               	.LBE1354:
 5046               	.LBB1356:
 5047               	.LBB1357:
 5048               		.loc 11 164 0
 5049 1514 8FEF      		 ldi r24,lo8(639999)
 5050 1516 93EC      	    ldi r25,hi8(639999)
 5051 1518 A9E0      	    ldi r26,hlo8(639999)
 5052 151a 8150      	    1:subi r24,1
 5053 151c 9040      	    sbci r25,0
 5054 151e A040      	    sbci r26,0
 5055 1520 01F4      	    brne 1b
 5056 1522 00C0      		rjmp .
 5057 1524 0000      		nop
 5058               	/* epilogue start */
 5059               	.LBE1357:
 5060               	.LBE1356:
  39:sms/sms.h     **** }
 5061               		.loc 13 39 0
 5062 1526 DF91      		pop r29
 5063 1528 CF91      		pop r28
 5064               	.LVL287:
 5065 152a 1F91      		pop r17
 5066               	.LVL288:
 5067 152c 0F91      		pop r16
 5068 152e FF90      		pop r15
 5069 1530 EF90      		pop r14
 5070 1532 DF90      		pop r13
 5071 1534 CF90      		pop r12
 5072               	.LVL289:
 5073 1536 BF90      		pop r11
 5074 1538 AF90      		pop r10
 5075               	.LVL290:
 5076 153a 0895      		ret
 5077               		.cfi_endproc
 5078               	.LFE74:
 5080               	.global	GprsTextModeSMS
 5082               	GprsTextModeSMS:
 5083               	.LFB75:
  41:sms/sms.h     **** void GprsTextModeSMS(USART_t* USART) {
 5084               		.loc 13 41 0
 5085               		.cfi_startproc
 5086               	.LVL291:
 5087               	/* prologue: function */
 5088               	/* frame size = 0 */
 5089               	/* stack size = 0 */
 5090               	.L__stack_usage = 0
 5091 153c BC01      		movw r22,r24
 5092               		.loc 13 42 0
 5093 153e 80E0      		ldi r24,lo8(.LC3)
 5094 1540 90E0      		ldi r25,hi8(.LC3)
 5095               	.LVL292:
 5096 1542 0E94 0000 		call send_uart
 5097               	.LVL293:
 5098               	/* epilogue start */
  43:sms/sms.h     **** }
 5099               		.loc 13 43 0
 5100 1546 0895      		ret
 5101               		.cfi_endproc
 5102               	.LFE75:
 5104               		.data
 5105               	.LC5:
 5106 0021 4154 2B43 		.string	"AT+CPOWD=1"
 5106      504F 5744 
 5106      3D31 00
 5107               		.text
 5108               	.global	PowerDownModem
 5110               	PowerDownModem:
 5111               	.LFB76:
  44:sms/sms.h     **** 
  45:sms/sms.h     **** void PowerDownModem(USART_t* USART) {
 5112               		.loc 13 45 0
 5113               		.cfi_startproc
 5114               	.LVL294:
 5115               	/* prologue: function */
 5116               	/* frame size = 0 */
 5117               	/* stack size = 0 */
 5118               	.L__stack_usage = 0
 5119 1548 BC01      		movw r22,r24
  46:sms/sms.h     ****   send_uart("AT+CPOWD=1", USART);
 5120               		.loc 13 46 0
 5121 154a 80E0      		ldi r24,lo8(.LC5)
 5122 154c 90E0      		ldi r25,hi8(.LC5)
 5123               	.LVL295:
 5124 154e 0E94 0000 		call send_uart
 5125               	.LVL296:
 5126               	/* epilogue start */
  47:sms/sms.h     **** }
 5127               		.loc 13 47 0
 5128 1552 0895      		ret
 5129               		.cfi_endproc
 5130               	.LFE76:
 5132               		.data
 5133               	.LC6:
 5134 002c 4154 2B43 		.string	"AT+CFUN=0"
 5134      4655 4E3D 
 5134      3000 
 5135               		.text
 5136               	.global	SleepModem
 5138               	SleepModem:
 5139               	.LFB77:
  48:sms/sms.h     **** 
  49:sms/sms.h     **** void SleepModem(USART_t* USART) {
 5140               		.loc 13 49 0
 5141               		.cfi_startproc
 5142               	.LVL297:
 5143               	/* prologue: function */
 5144               	/* frame size = 0 */
 5145               	/* stack size = 0 */
 5146               	.L__stack_usage = 0
 5147 1554 BC01      		movw r22,r24
  50:sms/sms.h     ****   send_uart("AT+CFUN=0", USART);
 5148               		.loc 13 50 0
 5149 1556 80E0      		ldi r24,lo8(.LC6)
 5150 1558 90E0      		ldi r25,hi8(.LC6)
 5151               	.LVL298:
 5152 155a 0E94 0000 		call send_uart
 5153               	.LVL299:
 5154               	/* epilogue start */
  51:sms/sms.h     **** }
 5155               		.loc 13 51 0
 5156 155e 0895      		ret
 5157               		.cfi_endproc
 5158               	.LFE77:
 5160               		.data
 5161               	.LC7:
 5162 0036 4154 2B43 		.string	"AT+CFUN=1"
 5162      4655 4E3D 
 5162      3100 
 5163               		.text
 5164               	.global	WakeUpModem
 5166               	WakeUpModem:
 5167               	.LFB78:
  52:sms/sms.h     **** 
  53:sms/sms.h     **** void WakeUpModem(USART_t* USART) {
 5168               		.loc 13 53 0
 5169               		.cfi_startproc
 5170               	.LVL300:
 5171               	/* prologue: function */
 5172               	/* frame size = 0 */
 5173               	/* stack size = 0 */
 5174               	.L__stack_usage = 0
 5175 1560 BC01      		movw r22,r24
  54:sms/sms.h     ****   send_uart("AT+CFUN=1", USART);
 5176               		.loc 13 54 0
 5177 1562 80E0      		ldi r24,lo8(.LC7)
 5178 1564 90E0      		ldi r25,hi8(.LC7)
 5179               	.LVL301:
 5180 1566 0E94 0000 		call send_uart
 5181               	.LVL302:
 5182               	/* epilogue start */
  55:sms/sms.h     **** }
 5183               		.loc 13 55 0
 5184 156a 0895      		ret
 5185               		.cfi_endproc
 5186               	.LFE78:
 5188               		.data
 5189               	.LC8:
 5190 0040 5379 6E63 		.string	"Sync"
 5190      00
 5191               	.LC9:
 5192 0045 4154 00   		.string	"AT"
 5193               	.LC10:
 5194 0048 5049 4E47 		.string	"PING"
 5194      00
 5195               	.LC11:
 5196 004d 5465 7874 		.string	"Text Mode"
 5196      204D 6F64 
 5196      6500 
 5197               	.LC12:
 5198 0057 4154 2B43 		.string	"AT+CMGF=?"
 5198      4D47 463D 
 5198      3F00 
 5199               	.LC13:
 5200 0061 4368 6563 		.string	"Check Mode"
 5200      6B20 4D6F 
 5200      6465 00
 5201               		.text
 5202               	.global	SimpleReceive
 5204               	SimpleReceive:
 5205               	.LFB79:
  56:sms/sms.h     **** 
  57:sms/sms.h     **** void SimpleReceive(USART_t* USART) {
 5206               		.loc 13 57 0
 5207               		.cfi_startproc
 5208               	.LVL303:
 5209 156c CF92      		push r12
 5210               	.LCFI124:
 5211               		.cfi_def_cfa_offset 3
 5212               		.cfi_offset 12, -2
 5213 156e DF92      		push r13
 5214               	.LCFI125:
 5215               		.cfi_def_cfa_offset 4
 5216               		.cfi_offset 13, -3
 5217 1570 EF92      		push r14
 5218               	.LCFI126:
 5219               		.cfi_def_cfa_offset 5
 5220               		.cfi_offset 14, -4
 5221 1572 FF92      		push r15
 5222               	.LCFI127:
 5223               		.cfi_def_cfa_offset 6
 5224               		.cfi_offset 15, -5
 5225 1574 0F93      		push r16
 5226               	.LCFI128:
 5227               		.cfi_def_cfa_offset 7
 5228               		.cfi_offset 16, -6
 5229 1576 1F93      		push r17
 5230               	.LCFI129:
 5231               		.cfi_def_cfa_offset 8
 5232               		.cfi_offset 17, -7
 5233 1578 CF93      		push r28
 5234               	.LCFI130:
 5235               		.cfi_def_cfa_offset 9
 5236               		.cfi_offset 28, -8
 5237 157a DF93      		push r29
 5238               	.LCFI131:
 5239               		.cfi_def_cfa_offset 10
 5240               		.cfi_offset 29, -9
 5241 157c CDB7      		in r28,__SP_L__
 5242 157e DEB7      		in r29,__SP_H__
 5243               	.LCFI132:
 5244               		.cfi_def_cfa_register 28
 5245               	/* prologue: function */
 5246               	/* frame size = 0 */
 5247               	/* stack size = 8 */
 5248               	.L__stack_usage = 8
 5249 1580 8C01      		movw r16,r24
  58:sms/sms.h     ****   //not currently functional, perhaps
  59:sms/sms.h     ****   //because of baud rate issues
  60:sms/sms.h     ****   
  61:sms/sms.h     ****   char c;
  62:sms/sms.h     ****   int n = 1;
  63:sms/sms.h     ****   char s[n+1];
  64:sms/sms.h     **** 
  65:sms/sms.h     ****   uart_putchar('A', USART);
  66:sms/sms.h     ****   send_string("Sync");
  67:sms/sms.h     ****   _delay_ms(3000);
  68:sms/sms.h     **** 
  69:sms/sms.h     ****   send_uart("AT", USART);
  70:sms/sms.h     ****   send_string("PING");
  71:sms/sms.h     ****   _delay_ms(100);
  72:sms/sms.h     ****   for (uint8_t i=0; i<n; i++) {
  73:sms/sms.h     ****     c = uart_getchar(USART);
  74:sms/sms.h     ****     s[i] = c;
  75:sms/sms.h     ****   }
  76:sms/sms.h     ****   s[n] = '\0';
  77:sms/sms.h     **** 
  78:sms/sms.h     ****   send_string(s);
  79:sms/sms.h     **** 
  80:sms/sms.h     **** 
  81:sms/sms.h     **** 
  82:sms/sms.h     ****   GprsTextModeSMS(USART);
  83:sms/sms.h     ****   send_string("Text Mode");
  84:sms/sms.h     ****   _delay_ms(800);
  85:sms/sms.h     **** 
  86:sms/sms.h     ****   // send_uart("AT+CMGL=\"REC UNREAD\"", USART); // Read Message 
  87:sms/sms.h     ****   // send_string("Read Messages");
  88:sms/sms.h     ****   // _delay_ms(1000);
  89:sms/sms.h     **** 
  90:sms/sms.h     ****   send_uart("AT+CMGF=?", USART); // Read Message 
  91:sms/sms.h     ****   send_string("Check Mode");
  92:sms/sms.h     ****   _delay_ms(1000);
  93:sms/sms.h     **** }...
 5250               		.loc 13 93 0
 5251 1582 CDB6      		in r12,__SP_L__
 5252 1584 DEB6      		in r13,__SP_H__
 5253               	.LVL304:
  63:sms/sms.h     ****   char s[n+1];
 5254               		.loc 13 63 0
 5255 1586 00D0      		rcall .
 5256 1588 EDB6      		in r14,__SP_L__
 5257 158a FEB6      		in r15,__SP_H__
 5258 158c 0894      		sec
 5259 158e E11C      		adc r14,__zero_reg__
 5260 1590 F11C      		adc r15,__zero_reg__
 5261               	.LVL305:
 5262               	.L199:
 5263               	.LBB1373:
 5264               	.LBB1374:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 5265               		.loc 9 18 0
 5266 1592 D801      		movw r26,r16
 5267 1594 1196      		adiw r26,1
 5268 1596 8C91      		ld r24,X
 5269 1598 1197      		sbiw r26,1
 5270 159a 85FF      		sbrs r24,5
 5271 159c 00C0      		rjmp .L199
  21:uart/uart.h   ****     USART->DATA = c; 
 5272               		.loc 9 21 0
 5273 159e 81E4      		ldi r24,lo8(65)
 5274 15a0 8C93      		st X,r24
 5275               	.LBE1374:
 5276               	.LBE1373:
  66:sms/sms.h     ****   send_string("Sync");
 5277               		.loc 13 66 0
 5278 15a2 80E0      		ldi r24,lo8(.LC8)
 5279 15a4 90E0      		ldi r25,hi8(.LC8)
 5280 15a6 0E94 0000 		call send_string
 5281               	.LVL306:
 5282               	.LBB1375:
 5283               	.LBB1376:
 5284               		.loc 11 164 0
 5285 15aa 8FEF      		 ldi r24,lo8(15999999)
 5286 15ac 93E2      	    ldi r25,hi8(15999999)
 5287 15ae A4EF      	    ldi r26,hlo8(15999999)
 5288 15b0 B0E0      	    ldi r27,hhi8(15999999)
 5289 15b2 8150      	    1:subi r24,1
 5290 15b4 9040      	    sbci r25,0
 5291 15b6 A040      	    sbci r26,0
 5292 15b8 B040      	    sbci r27,0
 5293 15ba 01F4      	    brne 1b
 5294 15bc 00C0      		rjmp .
 5295 15be 0000      		nop
 5296               	.LBE1376:
 5297               	.LBE1375:
  69:sms/sms.h     ****   send_uart("AT", USART);
 5298               		.loc 13 69 0
 5299 15c0 80E0      		ldi r24,lo8(.LC9)
 5300 15c2 90E0      		ldi r25,hi8(.LC9)
 5301 15c4 B801      		movw r22,r16
 5302 15c6 0E94 0000 		call send_uart
  70:sms/sms.h     ****   send_string("PING");
 5303               		.loc 13 70 0
 5304 15ca 80E0      		ldi r24,lo8(.LC10)
 5305 15cc 90E0      		ldi r25,hi8(.LC10)
 5306 15ce 0E94 0000 		call send_string
 5307               	.LVL307:
 5308               	.LBB1377:
 5309               	.LBB1378:
 5310               		.loc 11 164 0
 5311 15d2 8FEF      		 ldi r24,lo8(639999)
 5312 15d4 93EC      	    ldi r25,hi8(639999)
 5313 15d6 A9E0      	    ldi r26,hlo8(639999)
 5314 15d8 8150      	    1:subi r24,1
 5315 15da 9040      	    sbci r25,0
 5316 15dc A040      	    sbci r26,0
 5317 15de 01F4      	    brne 1b
 5318 15e0 00C0      		rjmp .
 5319 15e2 0000      		nop
 5320               	.LVL308:
 5321               	.L200:
 5322               	.LBE1378:
 5323               	.LBE1377:
 5324               	.LBB1379:
 5325               	.LBB1380:
 5326               	.LBB1381:
  30:uart/uart.h   ****     while ( !( USART->STATUS & USART_RXCIF_bm) ); 
 5327               		.loc 9 30 0
 5328 15e4 D801      		movw r26,r16
 5329 15e6 1196      		adiw r26,1
 5330 15e8 8C91      		ld r24,X
 5331 15ea 1197      		sbiw r26,1
 5332 15ec 87FF      		sbrs r24,7
 5333 15ee 00C0      		rjmp .L200
  33:uart/uart.h   ****     return USART->DATA; 
 5334               		.loc 9 33 0
 5335 15f0 8C91      		ld r24,X
 5336               	.LBE1381:
 5337               	.LBE1380:
  74:sms/sms.h     ****     s[i] = c;
 5338               		.loc 13 74 0
 5339 15f2 F701      		movw r30,r14
 5340 15f4 8083      		st Z,r24
 5341               	.LVL309:
 5342               	.LBE1379:
  76:sms/sms.h     ****   s[n] = '\0';
 5343               		.loc 13 76 0
 5344 15f6 1182      		std Z+1,__zero_reg__
  78:sms/sms.h     ****   send_string(s);
 5345               		.loc 13 78 0
 5346 15f8 C701      		movw r24,r14
 5347 15fa 0E94 0000 		call send_string
 5348               	.LVL310:
 5349               	.LBB1382:
 5350               	.LBB1383:
  42:sms/sms.h     ****   send_uart("AT+CMGF=1", USART);
 5351               		.loc 13 42 0
 5352 15fe 80E0      		ldi r24,lo8(.LC3)
 5353 1600 90E0      		ldi r25,hi8(.LC3)
 5354 1602 B801      		movw r22,r16
 5355 1604 0E94 0000 		call send_uart
 5356               	.LBE1383:
 5357               	.LBE1382:
  83:sms/sms.h     ****   send_string("Text Mode");
 5358               		.loc 13 83 0
 5359 1608 80E0      		ldi r24,lo8(.LC11)
 5360 160a 90E0      		ldi r25,hi8(.LC11)
 5361 160c 0E94 0000 		call send_string
 5362               	.LVL311:
 5363               	.LBB1384:
 5364               	.LBB1385:
 5365               		.loc 11 164 0
 5366 1610 8FEF      		 ldi r24,lo8(5119999)
 5367 1612 9FE1      	    ldi r25,hi8(5119999)
 5368 1614 AEE4      	    ldi r26,hlo8(5119999)
 5369 1616 8150      	    1:subi r24,1
 5370 1618 9040      	    sbci r25,0
 5371 161a A040      	    sbci r26,0
 5372 161c 01F4      	    brne 1b
 5373 161e 00C0      		rjmp .
 5374 1620 0000      		nop
 5375               	.LBE1385:
 5376               	.LBE1384:
  90:sms/sms.h     ****   send_uart("AT+CMGF=?", USART); // Read Message 
 5377               		.loc 13 90 0
 5378 1622 80E0      		ldi r24,lo8(.LC12)
 5379 1624 90E0      		ldi r25,hi8(.LC12)
 5380 1626 B801      		movw r22,r16
 5381 1628 0E94 0000 		call send_uart
  91:sms/sms.h     ****   send_string("Check Mode");
 5382               		.loc 13 91 0
 5383 162c 80E0      		ldi r24,lo8(.LC13)
 5384 162e 90E0      		ldi r25,hi8(.LC13)
 5385 1630 0E94 0000 		call send_string
 5386               	.LVL312:
 5387               	.LBB1386:
 5388               	.LBB1387:
 5389               		.loc 11 164 0
 5390 1634 8FEF      		 ldi r24,lo8(6399999)
 5391 1636 97EA      	    ldi r25,hi8(6399999)
 5392 1638 A1E6      	    ldi r26,hlo8(6399999)
 5393 163a 8150      	    1:subi r24,1
 5394 163c 9040      	    sbci r25,0
 5395 163e A040      	    sbci r26,0
 5396 1640 01F4      	    brne 1b
 5397 1642 00C0      		rjmp .
 5398 1644 0000      		nop
 5399               	.LBE1387:
 5400               	.LBE1386:
 5401               		.loc 13 93 0
 5402 1646 CDBE      		out __SP_L__,r12
 5403 1648 DEBE      		out __SP_H__,r13
 5404               	/* epilogue start */
 5405 164a DF91      		pop r29
 5406 164c CF91      		pop r28
 5407 164e 1F91      		pop r17
 5408 1650 0F91      		pop r16
 5409               	.LVL313:
 5410 1652 FF90      		pop r15
 5411 1654 EF90      		pop r14
 5412               	.LVL314:
 5413 1656 DF90      		pop r13
 5414 1658 CF90      		pop r12
 5415               	.LVL315:
 5416 165a 0895      		ret
 5417               		.cfi_endproc
 5418               	.LFE79:
 5420               		.section	.text.startup,"ax",@progbits
 5421               	.global	main
 5423               	main:
 5424               	.LFB80:
  29:main.c        **** int main(void){
 5425               		.loc 6 29 0
 5426               		.cfi_startproc
 5427 0000 CF93      		push r28
 5428               	.LCFI133:
 5429               		.cfi_def_cfa_offset 3
 5430               		.cfi_offset 28, -2
 5431 0002 DF93      		push r29
 5432               	.LCFI134:
 5433               		.cfi_def_cfa_offset 4
 5434               		.cfi_offset 29, -3
 5435 0004 CDB7      		in r28,__SP_L__
 5436 0006 DEB7      		in r29,__SP_H__
 5437 0008 CB5F      		subi r28,lo8(-(-251))
 5438 000a D040      		sbci r29,hi8(-(-251))
 5439               	.LCFI135:
 5440               		.cfi_def_cfa 28, 255
 5441 000c CDBF      		out __SP_L__,r28
 5442 000e DEBF      		out __SP_H__,r29
 5443               	/* prologue: function */
 5444               	/* frame size = 251 */
 5445               	/* stack size = 253 */
 5446               	.L__stack_usage = 253
  32:main.c        **** 	USB_ConfigureClock();
 5447               		.loc 6 32 0
 5448 0010 0E94 0000 		call USB_ConfigureClock
  33:main.c        **** 	USB_Init();
 5449               		.loc 6 33 0
 5450 0014 0E94 0000 		call USB_Init
  34:main.c        **** 	USB.INTCTRLA = USB_BUSEVIE_bm | USB_INTLVL_MED_gc;
 5451               		.loc 6 34 0
 5452 0018 E0EC      		ldi r30,lo8(1216)
 5453 001a F4E0      		ldi r31,hi8(1216)
 5454 001c 82E4      		ldi r24,lo8(66)
 5455 001e 8087      		std Z+8,r24
  35:main.c        **** 	USB.INTCTRLB = USB_TRNIE_bm | USB_SETUPIE_bm;
 5456               		.loc 6 35 0
 5457 0020 83E0      		ldi r24,lo8(3)
 5458 0022 8187      		std Z+9,r24
  36:main.c        **** 	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
 5459               		.loc 6 36 0
 5460 0024 E0EA      		ldi r30,lo8(160)
 5461 0026 F0E0      		ldi r31,hi8(160)
 5462 0028 8283      		std Z+2,r24
  37:main.c        **** 	sei();
 5463               		.loc 6 37 0
 5464               	/* #APP */
 5465               	 ;  37 "main.c" 1
 5466 002a 7894      		sei
 5467               	 ;  0 "" 2
 5468               	.LVL316:
 5469               	/* #NOAPP */
 5470               	.LBB1451:
 5471               	.LBB1452:
  14:gprs/gprs.h   ****   PORT->DIRSET = TXPIN_bm; 
 5472               		.loc 12 14 0
 5473 002c E0E4      		ldi r30,lo8(1600)
 5474 002e F6E0      		ldi r31,hi8(1600)
 5475 0030 98E0      		ldi r25,lo8(8)
 5476 0032 9183      		std Z+1,r25
  17:gprs/gprs.h   ****   PORT->OUTSET = TXPIN_bm; 
 5477               		.loc 12 17 0
 5478 0034 9583      		std Z+5,r25
 5479               	.LVL317:
  22:gprs/gprs.h   ****   USART->BAUDCTRLA = BSEL & 0XFF;
 5480               		.loc 12 22 0
 5481 0036 E0EA      		ldi r30,lo8(2208)
 5482 0038 F8E0      		ldi r31,hi8(2208)
 5483 003a 9CE0      		ldi r25,lo8(12)
 5484 003c 9683      		std Z+6,r25
  23:gprs/gprs.h   ****   USART->BAUDCTRLB = (BSCALE << 4) | (BSEL & 0xF000) >> 8;
 5485               		.loc 12 23 0
 5486 003e 90E3      		ldi r25,lo8(48)
 5487 0040 9783      		std Z+7,r25
  27:gprs/gprs.h   ****   USART->CTRLA = 0x00;
 5488               		.loc 12 27 0
 5489 0042 1382      		std Z+3,__zero_reg__
  30:gprs/gprs.h   ****   USART->CTRLB = USART_TXEN_bm | USART_RXEN_bm;  
 5490               		.loc 12 30 0
 5491 0044 98E1      		ldi r25,lo8(24)
 5492 0046 9483      		std Z+4,r25
  34:gprs/gprs.h   ****   USART->CTRLC = 0x03;  
 5493               		.loc 12 34 0
 5494 0048 8583      		std Z+5,r24
 5495               	.LBE1452:
 5496               	.LBE1451:
  47:main.c        **** 		gps_init(&USARTD0, &PORTD, PIN0_bm, PIN3_bm, PIN4_bm);
 5497               		.loc 6 47 0
 5498 004a 80EA      		ldi r24,lo8(2464)
 5499 004c 99E0      		ldi r25,hi8(2464)
 5500 004e 60E6      		ldi r22,lo8(1632)
 5501 0050 76E0      		ldi r23,hi8(1632)
 5502 0052 41E0      		ldi r20,lo8(1)
 5503 0054 28E0      		ldi r18,lo8(8)
 5504 0056 00E1      		ldi r16,lo8(16)
 5505 0058 0E94 0000 		call gps_init
 104:gps/gps.h     ****   int buff_index = 0;
 5506               		.loc 10 104 0
 5507 005c 60E0      		ldi r22,lo8(0)
 5508 005e 70E0      		ldi r23,hi8(0)
  98:gps/gps.h     ****   int read = 0;
 5509               		.loc 10 98 0
 5510 0060 40E0      		ldi r20,lo8(0)
 5511 0062 50E0      		ldi r21,hi8(0)
  95:gps/gps.h     ****   int index = 0;
 5512               		.loc 10 95 0
 5513 0064 20E0      		ldi r18,lo8(0)
 5514 0066 30E0      		ldi r19,hi8(0)
 5515 0068 7E01      		movw r14,r28
 5516 006a 0894      		sec
 5517 006c E11C      		adc r14,__zero_reg__
 5518 006e F11C      		adc r15,__zero_reg__
 5519 0070 A5E6      		ldi r26,lo8(101)
 5520 0072 CA2E      		mov r12,r26
 5521 0074 D12C      		mov r13,__zero_reg__
 5522 0076 CC0E      		add r12,r28
 5523 0078 DD1E      		adc r13,r29
 5524 007a B0E0      		ldi r27,lo8(.LC1)
 5525 007c 8B2E      		mov r8,r27
 5526 007e B0E0      		ldi r27,hi8(.LC1)
 5527 0080 9B2E      		mov r9,r27
 5528 0082 13E3      		ldi r17,lo8(51)
 5529 0084 A12E      		mov r10,r17
 5530 0086 B12C      		mov r11,__zero_reg__
 5531 0088 AC0E      		add r10,r28
 5532 008a BD1E      		adc r11,r29
 5533               	.LBB1453:
 5534               	.LBB1454:
 5535               	.LBB1455:
 5536               	.LBB1456:
  19:utils/utils.h ****     strcat(result, s2);
 5537               		.loc 7 19 0
 5538 008c 02E2      		ldi r16,lo8(34)
 5539 008e 602E      		mov r6,r16
 5540 0090 712C      		mov r7,__zero_reg__
 5541               	.L240:
 5542               	.LBE1456:
 5543               	.LBE1455:
 5544               	.LBE1454:
 5545               	.LBE1453:
 5546               	.LBB1478:
 5547               	.LBB1479:
 5548               	.LBB1480:
 5549               	.LBB1481:
  30:uart/uart.h   ****     while ( !( USART->STATUS & USART_RXCIF_bm) ); 
 5550               		.loc 9 30 0
 5551 0092 8091 A109 		lds r24,2465
 5552 0096 87FF      		sbrs r24,7
 5553 0098 00C0      		rjmp .L240
  33:uart/uart.h   ****     return USART->DATA; 
 5554               		.loc 9 33 0
 5555 009a 8091 A009 		lds r24,2464
 5556               	.LBE1481:
 5557               	.LBE1480:
 113:gps/gps.h     ****     if (index == length) {
 5558               		.loc 10 113 0
 5559 009e 2730      		cpi r18,7
 5560 00a0 3105      		cpc r19,__zero_reg__
 5561 00a2 01F0      		breq .L206
 5562               	.LVL318:
 118:gps/gps.h     ****     if (read == 1) {
 5563               		.loc 10 118 0
 5564 00a4 4130      		cpi r20,1
 5565 00a6 5105      		cpc r21,__zero_reg__
 5566 00a8 01F0      		breq .L206
 132:gps/gps.h     ****     } else if (c == code[index]) {
 5567               		.loc 10 132 0
 5568 00aa F901      		movw r30,r18
 5569 00ac E050      		subi r30,lo8(-(.LC2))
 5570 00ae F040      		sbci r31,hi8(-(.LC2))
 5571 00b0 9081      		ld r25,Z
 5572 00b2 8917      		cp r24,r25
 5573 00b4 01F0      		breq .L242
 137:gps/gps.h     ****       index = 0;
 5574               		.loc 10 137 0
 5575 00b6 20E0      		ldi r18,lo8(0)
 5576 00b8 30E0      		ldi r19,hi8(0)
 5577 00ba 00C0      		rjmp .L240
 5578               	.LVL319:
 5579               	.L206:
 120:gps/gps.h     ****       buff[buff_index] = c;
 5580               		.loc 10 120 0
 5581 00bc E7E9      		ldi r30,lo8(151)
 5582 00be F0E0      		ldi r31,hi8(151)
 5583 00c0 EC0F      		add r30,r28
 5584 00c2 FD1F      		adc r31,r29
 5585 00c4 E60F      		add r30,r22
 5586 00c6 F71F      		adc r31,r23
 5587 00c8 8083      		st Z,r24
 121:gps/gps.h     ****       buff_index++;
 5588               		.loc 10 121 0
 5589 00ca 6F5F      		subi r22,lo8(-(1))
 5590 00cc 7F4F      		sbci r23,hi8(-(1))
 5591               	.LVL320:
 123:gps/gps.h     ****       if (c == '\r' || c == '\n' || c == 'W' || c == 'E') {
 5592               		.loc 10 123 0
 5593 00ce 8D30      		cpi r24,lo8(13)
 5594 00d0 01F0      		breq .L208
 5595 00d2 8A30      		cpi r24,lo8(10)
 5596 00d4 01F0      		breq .L208
 5597 00d6 8735      		cpi r24,lo8(87)
 5598 00d8 01F0      		breq .L208
 5599 00da 8534      		cpi r24,lo8(69)
 5600 00dc 01F0      		breq .L208
 5601 00de 41E0      		ldi r20,lo8(1)
 5602 00e0 50E0      		ldi r21,hi8(1)
 5603 00e2 00C0      		rjmp .L240
 5604               	.LVL321:
 5605               	.L242:
 134:gps/gps.h     ****       index++;
 5606               		.loc 10 134 0
 5607 00e4 2F5F      		subi r18,lo8(-(1))
 5608 00e6 3F4F      		sbci r19,hi8(-(1))
 5609               	.LVL322:
 5610 00e8 00C0      		rjmp .L240
 5611               	.LVL323:
 5612               	.L208:
 125:gps/gps.h     ****         buff[buff_index] = '\0';
 5613               		.loc 10 125 0
 5614 00ea E7E9      		ldi r30,lo8(151)
 5615 00ec F0E0      		ldi r31,hi8(151)
 5616 00ee EC0F      		add r30,r28
 5617 00f0 FD1F      		adc r31,r29
 5618 00f2 E60F      		add r30,r22
 5619 00f4 F71F      		adc r31,r23
 5620 00f6 1082      		st Z,__zero_reg__
 5621               	.LVL324:
 5622               	.LBB1482:
 5623               	.LBB1483:
 5624               	.LBB1484:
 5625               	.LBB1485:
  45:nmea/nmea.h   ****   token[0] = strtok(s, ","); //get pointer to first token found and store in
 5626               		.loc 8 45 0
 5627 00f8 CE01      		movw r24,r28
 5628 00fa 8956      		subi r24,lo8(-(151))
 5629 00fc 9F4F      		sbci r25,hi8(-(151))
 5630 00fe 60E0      		ldi r22,lo8(.LC0)
 5631 0100 70E0      		ldi r23,hi8(.LC0)
 5632               	.LVL325:
 5633 0102 0E94 0000 		call strtok
  47:nmea/nmea.h   ****   while(token[i] != NULL) {  //while commas continue to be found
 5634               		.loc 8 47 0
 5635 0106 0097      		sbiw r24,0
 5636 0108 01F0      		breq .L210
 5637 010a 10E0      		ldi r17,lo8(0)
 5638               	.LVL326:
 5639               	.L211:
  48:nmea/nmea.h   ****       i++;  
 5640               		.loc 8 48 0
 5641 010c 1F5F      		subi r17,lo8(-(1))
 5642               	.LVL327:
  49:nmea/nmea.h   ****       token[i] = strtok(NULL, ","); //continue to split the string
 5643               		.loc 8 49 0
 5644 010e 80E0      		ldi r24,lo8(0)
 5645 0110 90E0      		ldi r25,hi8(0)
 5646 0112 60E0      		ldi r22,lo8(.LC0)
 5647 0114 70E0      		ldi r23,hi8(.LC0)
 5648 0116 0E94 0000 		call strtok
 5649 011a E12F      		mov r30,r17
 5650 011c F0E0      		ldi r31,lo8(0)
 5651 011e EE0F      		lsl r30
 5652 0120 FF1F      		rol r31
 5653 0122 EE0D      		add r30,r14
 5654 0124 FF1D      		adc r31,r15
 5655 0126 8083      		st Z,r24
 5656 0128 9183      		std Z+1,r25
  47:nmea/nmea.h   ****   while(token[i] != NULL) {  //while commas continue to be found
 5657               		.loc 8 47 0
 5658 012a 0097      		sbiw r24,0
 5659 012c 01F4      		brne .L211
 5660               	.LVL328:
 5661               	.L210:
  67:nmea/nmea.h   ****   char* valid = token[1]; //A --> Valid, V --> Invalid
 5662               		.loc 8 67 0
 5663 012e EB81      		ldd r30,Y+3
 5664 0130 FC81      		ldd r31,Y+4
 5665               	.LVL329:
  68:nmea/nmea.h   ****   char* lat_str = token[2]; //longitude
 5666               		.loc 8 68 0
 5667 0132 8D81      		ldd r24,Y+5
 5668 0134 9E81      		ldd r25,Y+6
 5669               	.LVL330:
  69:nmea/nmea.h   ****   char* lng_str = token[4]; //latitude
 5670               		.loc 8 69 0
 5671 0136 0985      		ldd r16,Y+9
 5672 0138 1A85      		ldd r17,Y+10
 5673               	.LVL331:
  71:nmea/nmea.h   ****   gps->valid = *valid;
 5674               		.loc 8 71 0
 5675 013a 2081      		ld r18,Z
 5676 013c 2093 0000 		sts gps+12,r18
  73:nmea/nmea.h   ****   if (*valid == 'A') {
 5677               		.loc 8 73 0
 5678 0140 2081      		ld r18,Z
 5679 0142 2134      		cpi r18,lo8(65)
 5680 0144 01F0      		breq .L243
  89:nmea/nmea.h   ****     gps->valid = 0;
 5681               		.loc 8 89 0
 5682 0146 1092 0000 		sts gps+12,__zero_reg__
 5683               	.LBE1485:
 5684               	.LBE1484:
 103:nmea/nmea.h   ****     if (gps->dist > max_dist) {
 5685               		.loc 8 103 0
 5686 014a 6091 0000 		lds r22,gps+8
 5687 014e 7091 0000 		lds r23,gps+8+1
 5688 0152 8091 0000 		lds r24,gps+8+2
 5689 0156 9091 0000 		lds r25,gps+8+3
 5690 015a 2091 0000 		lds r18,max_dist
 5691 015e 3091 0000 		lds r19,max_dist+1
 5692 0162 4091 0000 		lds r20,max_dist+2
 5693 0166 5091 0000 		lds r21,max_dist+3
 5694 016a 0E94 0000 		call __gtsf2
 5695 016e 1816      		cp __zero_reg__,r24
 5696 0170 04F4      		brge .+2
 5697 0172 00C0      		rjmp .L215
 5698               	.L227:
 5699               	.LVL332:
 5700               	.LBE1483:
 5701               	.LBE1482:
 5702               	.LBE1479:
 5703               	.LBE1478:
 5704               	.LBB1501:
 5705               	.LBB1502:
 5706               		.loc 11 164 0
 5707 0174 8FEF      		 ldi r24,lo8(159999999)
 5708 0176 97E6      	    ldi r25,hi8(159999999)
 5709 0178 A9E8      	    ldi r26,hlo8(159999999)
 5710 017a B9E0      	    ldi r27,hhi8(159999999)
 5711 017c 8150      	    1:subi r24,1
 5712 017e 9040      	    sbci r25,0
 5713 0180 A040      	    sbci r26,0
 5714 0182 B040      	    sbci r27,0
 5715 0184 01F4      	    brne 1b
 5716 0186 00C0      		rjmp .
 5717 0188 0000      		nop
 104:gps/gps.h     ****   int buff_index = 0;
 5718               		.loc 10 104 0
 5719 018a 60E0      		ldi r22,lo8(0)
 5720 018c 70E0      		ldi r23,hi8(0)
  98:gps/gps.h     ****   int read = 0;
 5721               		.loc 10 98 0
 5722 018e 40E0      		ldi r20,lo8(0)
 5723 0190 50E0      		ldi r21,hi8(0)
  95:gps/gps.h     ****   int index = 0;
 5724               		.loc 10 95 0
 5725 0192 20E0      		ldi r18,lo8(0)
 5726 0194 30E0      		ldi r19,hi8(0)
 5727               	.LVL333:
 5728 0196 00C0      		rjmp .L240
 5729               	.LVL334:
 5730               	.L243:
 5731               	.LBE1502:
 5732               	.LBE1501:
 5733               	.LBB1503:
 5734               	.LBB1499:
 5735               	.LBB1497:
 5736               	.LBB1495:
 5737               	.LBB1488:
 5738               	.LBB1486:
  74:nmea/nmea.h   ****     gps->valid = 1;
 5739               		.loc 8 74 0
 5740 0198 21E0      		ldi r18,lo8(1)
 5741 019a 2093 0000 		sts gps+12,r18
  78:nmea/nmea.h   ****     gps->lat = atof(lat_str)/100.;
 5742               		.loc 8 78 0
 5743 019e 0E94 0000 		call atof
 5744 01a2 20E0      		ldi r18,lo8(0x42c80000)
 5745 01a4 30E0      		ldi r19,hi8(0x42c80000)
 5746 01a6 48EC      		ldi r20,hlo8(0x42c80000)
 5747 01a8 52E4      		ldi r21,hhi8(0x42c80000)
 5748 01aa 0E94 0000 		call __divsf3
 5749 01ae DC01      		movw r26,r24
 5750 01b0 CB01      		movw r24,r22
 5751 01b2 8093 0000 		sts gps,r24
 5752 01b6 9093 0000 		sts gps+1,r25
 5753 01ba A093 0000 		sts gps+2,r26
 5754 01be B093 0000 		sts gps+3,r27
  81:nmea/nmea.h   ****     gps->lng = atof(lng_str)/100.;
 5755               		.loc 8 81 0
 5756 01c2 C801      		movw r24,r16
 5757 01c4 0E94 0000 		call atof
 5758 01c8 20E0      		ldi r18,lo8(0x42c80000)
 5759 01ca 30E0      		ldi r19,hi8(0x42c80000)
 5760 01cc 48EC      		ldi r20,hlo8(0x42c80000)
 5761 01ce 52E4      		ldi r21,hhi8(0x42c80000)
 5762 01d0 0E94 0000 		call __divsf3
 5763 01d4 9B01      		movw r18,r22
 5764 01d6 AC01      		movw r20,r24
 5765 01d8 CB01      		movw r24,r22
 5766 01da DA01      		movw r26,r20
 5767 01dc 8093 0000 		sts gps+4,r24
 5768 01e0 9093 0000 		sts gps+4+1,r25
 5769 01e4 A093 0000 		sts gps+4+2,r26
 5770 01e8 B093 0000 		sts gps+4+3,r27
  82:nmea/nmea.h   ****     gps->dist = distance(gps->lat, gps->lng);
 5771               		.loc 8 82 0
 5772 01ec 6091 0000 		lds r22,gps
 5773 01f0 7091 0000 		lds r23,gps+1
 5774 01f4 8091 0000 		lds r24,gps+2
 5775 01f8 9091 0000 		lds r25,gps+3
 5776 01fc 8901      		movw r16,r18
 5777 01fe 9A01      		movw r18,r20
 5778 0200 A901      		movw r20,r18
 5779 0202 9801      		movw r18,r16
 5780 0204 0E94 0000 		call distance
 5781 0208 6093 0000 		sts gps+8,r22
 5782 020c 7093 0000 		sts gps+8+1,r23
 5783 0210 8093 0000 		sts gps+8+2,r24
 5784 0214 9093 0000 		sts gps+8+3,r25
  83:nmea/nmea.h   ****     if (gps->dist > max_dist) {
 5785               		.loc 8 83 0
 5786 0218 2091 0000 		lds r18,max_dist
 5787 021c 3091 0000 		lds r19,max_dist+1
 5788 0220 4091 0000 		lds r20,max_dist+2
 5789 0224 5091 0000 		lds r21,max_dist+3
 5790 0228 0E94 0000 		call __gtsf2
 5791 022c 1816      		cp __zero_reg__,r24
 5792 022e 04F0      		brlt .+2
 5793 0230 00C0      		rjmp .L241
  84:nmea/nmea.h   ****       gps->roaming = 1;
 5794               		.loc 8 84 0
 5795 0232 31E0      		ldi r19,lo8(1)
 5796 0234 3093 0000 		sts gps+13,r19
 5797               	.L215:
 5798               	.LBE1486:
 5799               	.LBE1488:
 5800               	.LBB1489:
 109:nmea/nmea.h   ****       sprintf(lat_buff, "%f", gps->lat);
 5801               		.loc 8 109 0
 5802 0238 8DB7      		in r24,__SP_L__
 5803 023a 9EB7      		in r25,__SP_H__
 5804 023c 0897      		sbiw r24,8
 5805 023e 8DBF      		out __SP_L__,r24
 5806 0240 9EBF      		out __SP_H__,r25
 5807 0242 EDB7      		in r30,__SP_L__
 5808 0244 FEB7      		in r31,__SP_H__
 5809 0246 3196      		adiw r30,1
 5810 0248 ADB7      		in r26,__SP_L__
 5811 024a BEB7      		in r27,__SP_H__
 5812 024c 1196      		adiw r26,1
 5813 024e CD92      		st X+,r12
 5814 0250 DC92      		st X,r13
 5815 0252 1297      		sbiw r26,1+1
 5816 0254 8282      		std Z+2,r8
 5817 0256 9382      		std Z+3,r9
 5818 0258 8091 0000 		lds r24,gps
 5819 025c 9091 0000 		lds r25,gps+1
 5820 0260 A091 0000 		lds r26,gps+2
 5821 0264 B091 0000 		lds r27,gps+3
 5822 0268 8483      		std Z+4,r24
 5823 026a 9583      		std Z+5,r25
 5824 026c A683      		std Z+6,r26
 5825 026e B783      		std Z+7,r27
 5826               		.cfi_escape 0x2e,0x8
 5827 0270 0E94 0000 		call sprintf
 110:nmea/nmea.h   ****       sprintf(lng_buff, "%f", gps->lng);
 5828               		.loc 8 110 0
 5829 0274 EDB7      		in r30,__SP_L__
 5830 0276 FEB7      		in r31,__SP_H__
 5831 0278 3196      		adiw r30,1
 5832 027a ADB7      		in r26,__SP_L__
 5833 027c BEB7      		in r27,__SP_H__
 5834 027e 1196      		adiw r26,1
 5835 0280 AD92      		st X+,r10
 5836 0282 BC92      		st X,r11
 5837 0284 1297      		sbiw r26,1+1
 5838 0286 8282      		std Z+2,r8
 5839 0288 9382      		std Z+3,r9
 5840 028a 8091 0000 		lds r24,gps+4
 5841 028e 9091 0000 		lds r25,gps+4+1
 5842 0292 A091 0000 		lds r26,gps+4+2
 5843 0296 B091 0000 		lds r27,gps+4+3
 5844 029a 8483      		std Z+4,r24
 5845 029c 9583      		std Z+5,r25
 5846 029e A683      		std Z+6,r26
 5847 02a0 B783      		std Z+7,r27
 5848 02a2 0E94 0000 		call sprintf
 111:nmea/nmea.h   ****       sprintf(dist_buff, "%f", gps->dist);
 5849               		.loc 8 111 0
 5850 02a6 EDB7      		in r30,__SP_L__
 5851 02a8 FEB7      		in r31,__SP_H__
 5852 02aa 3196      		adiw r30,1
 5853 02ac ADB7      		in r26,__SP_L__
 5854 02ae BEB7      		in r27,__SP_H__
 5855 02b0 1196      		adiw r26,1
 5856 02b2 ED92      		st X+,r14
 5857 02b4 FC92      		st X,r15
 5858 02b6 1297      		sbiw r26,1+1
 5859 02b8 8282      		std Z+2,r8
 5860 02ba 9382      		std Z+3,r9
 5861 02bc 8091 0000 		lds r24,gps+8
 5862 02c0 9091 0000 		lds r25,gps+8+1
 5863 02c4 A091 0000 		lds r26,gps+8+2
 5864 02c8 B091 0000 		lds r27,gps+8+3
 5865 02cc 8483      		std Z+4,r24
 5866 02ce 9583      		std Z+5,r25
 5867 02d0 A683      		std Z+6,r26
 5868 02d2 B783      		std Z+7,r27
 5869 02d4 0E94 0000 		call sprintf
 5870               	.LVL335:
 5871               	.LBB1490:
 5872               	.LBB1491:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 5873               		.loc 7 16 0
 5874 02d8 F601      		movw r30,r12
 5875 02da 0190      		ld __tmp_reg__,Z+
 5876 02dc 0020      		tst __tmp_reg__
 5877 02de 01F4      		brne .-6
 5878 02e0 CF01      		movw r24,r30
 5879 02e2 8C19      		sub r24,r12
 5880 02e4 9D09      		sbc r25,r13
 5881 02e6 2DB7      		in r18,__SP_L__
 5882 02e8 3EB7      		in r19,__SP_H__
 5883 02ea 285F      		subi r18,lo8(-(8))
 5884 02ec 3F4F      		sbci r19,hi8(-(8))
 5885 02ee 2DBF      		out __SP_L__,r18
 5886 02f0 3EBF      		out __SP_H__,r19
 5887 02f2 0196      		adiw r24,1
 5888               		.cfi_escape 0x2e,0
 5889 02f4 0E94 0000 		call malloc
 5890 02f8 592E      		mov r5,r25
 5891 02fa 082F      		mov r16,r24
 5892 02fc 192F      		mov r17,r25
 5893               	.LVL336:
  18:utils/utils.h ****     strcpy(result, s1);
 5894               		.loc 7 18 0
 5895 02fe C801      		movw r24,r16
 5896 0300 B601      		movw r22,r12
 5897 0302 0E94 0000 		call strcpy
  19:utils/utils.h ****     strcat(result, s2);
 5898               		.loc 7 19 0
 5899 0306 A02F      		mov r26,r16
 5900 0308 B52D      		mov r27,r5
 5901 030a FD01      		movw r30,r26
 5902 030c 0190      		ld __tmp_reg__,Z+
 5903 030e 0020      		tst __tmp_reg__
 5904 0310 01F4      		brne .-6
 5905 0312 3197      		sbiw r30,1
 5906 0314 EA1B      		sub r30,r26
 5907 0316 FB0B      		sbc r31,r27
 5908 0318 E00F      		add r30,r16
 5909 031a F11F      		adc r31,r17
 5910 031c 8CE2      		ldi r24,lo8(44)
 5911 031e 90E0      		ldi r25,hi8(44)
 5912 0320 8083      		st Z,r24
 5913 0322 9183      		std Z+1,r25
 5914               	.LVL337:
 5915               	.LBE1491:
 5916               	.LBE1490:
 5917               	.LBB1492:
 5918               	.LBB1493:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 5919               		.loc 7 16 0
 5920 0324 FD01      		movw r30,r26
 5921 0326 0190      		ld __tmp_reg__,Z+
 5922 0328 0020      		tst __tmp_reg__
 5923 032a 01F4      		brne .-6
 5924 032c 9F01      		movw r18,r30
 5925 032e F501      		movw r30,r10
 5926 0330 0190      		ld __tmp_reg__,Z+
 5927 0332 0020      		tst __tmp_reg__
 5928 0334 01F4      		brne .-6
 5929 0336 CF01      		movw r24,r30
 5930 0338 0197      		sbiw r24,1
 5931 033a 8A19      		sub r24,r10
 5932 033c 9B09      		sbc r25,r11
 5933 033e 8A1B      		sub r24,r26
 5934 0340 9B0B      		sbc r25,r27
 5935 0342 820F      		add r24,r18
 5936 0344 931F      		adc r25,r19
 5937 0346 0E94 0000 		call malloc
 5938 034a 582E      		mov r5,r24
 5939 034c 492E      		mov r4,r25
 5940               	.LVL338:
  18:utils/utils.h ****     strcpy(result, s1);
 5941               		.loc 7 18 0
 5942 034e B801      		movw r22,r16
 5943 0350 0E94 0000 		call strcpy
 5944               	.LVL339:
  19:utils/utils.h ****     strcat(result, s2);
 5945               		.loc 7 19 0
 5946 0354 852D      		mov r24,r5
 5947 0356 942D      		mov r25,r4
 5948 0358 B501      		movw r22,r10
 5949 035a 0E94 0000 		call strcat
 5950               	.LBE1493:
 5951               	.LBE1492:
 138:nmea/nmea.h   ****       gps->sms = concat(concat(lat_str, ","), lng_str);
 5952               		.loc 8 138 0
 5953 035e 5092 0000 		sts gps+14,r5
 5954 0362 4092 0000 		sts gps+15,r4
 5955               	.LVL340:
 5956               	.L216:
 5957               	.LBE1489:
 5958               	.LBE1495:
 5959               	.LBE1497:
 5960               	.LBE1499:
 5961               	.LBE1503:
  63:main.c        ****     if (gps.valid) {
 5962               		.loc 6 63 0
 5963 0366 8091 0000 		lds r24,gps+12
 5964 036a 8823      		tst r24
 5965 036c 01F4      		brne .+2
 5966 036e 00C0      		rjmp .L227
  64:main.c        ****     	if (gps.roaming) {
 5967               		.loc 6 64 0
 5968 0370 8091 0000 		lds r24,gps+13
 5969 0374 8823      		tst r24
 5970 0376 01F4      		brne .L244
  69:main.c        ****     		freq = LOW_FREQ;
 5971               		.loc 6 69 0
 5972 0378 1092 0000 		sts freq,__zero_reg__
 5973 037c 00C0      		rjmp .L227
 5974               	.L244:
  65:main.c        **** 		  	send_message(phonenumber, gps.sms, &USARTC0);
 5975               		.loc 6 65 0
 5976 037e 1091 0000 		lds r17,phonenumber
 5977 0382 0091 0000 		lds r16,phonenumber+1
 5978 0386 2090 0000 		lds r2,gps+14
 5979 038a 3090 0000 		lds r3,gps+14+1
 5980               	.LVL341:
 5981               	.L220:
 5982               	.LBB1504:
 5983               	.LBB1477:
 5984               	.LBB1458:
 5985               	.LBB1459:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 5986               		.loc 9 18 0
 5987 038e 8091 A108 		lds r24,2209
 5988 0392 85FF      		sbrs r24,5
 5989 0394 00C0      		rjmp .L220
  21:uart/uart.h   ****     USART->DATA = c; 
 5990               		.loc 9 21 0
 5991 0396 FDE0      		ldi r31,lo8(13)
 5992 0398 F093 A008 		sts 2208,r31
 5993               	.LVL342:
 5994               	.LBE1459:
 5995               	.LBE1458:
 5996               	.LBB1460:
 5997               	.LBB1461:
 5998               		.loc 11 164 0
 5999 039c 8FEF      		 ldi r24,lo8(639999)
 6000 039e 93EC      	    ldi r25,hi8(639999)
 6001 03a0 A9E0      	    ldi r26,hlo8(639999)
 6002 03a2 8150      	    1:subi r24,1
 6003 03a4 9040      	    sbci r25,0
 6004 03a6 A040      	    sbci r26,0
 6005 03a8 01F4      	    brne 1b
 6006 03aa 00C0      		rjmp .
 6007 03ac 0000      		nop
 6008               	.LVL343:
 6009               	.LBE1461:
 6010               	.LBE1460:
 6011               	.LBB1462:
 6012               	.LBB1463:
  42:sms/sms.h     ****   send_uart("AT+CMGF=1", USART);
 6013               		.loc 13 42 0
 6014 03ae 80E0      		ldi r24,lo8(.LC3)
 6015 03b0 90E0      		ldi r25,hi8(.LC3)
 6016 03b2 60EA      		ldi r22,lo8(2208)
 6017 03b4 78E0      		ldi r23,hi8(2208)
 6018 03b6 0E94 0000 		call send_uart
 6019               	.LVL344:
 6020               	.LBE1463:
 6021               	.LBE1462:
 6022               	.LBB1464:
 6023               	.LBB1465:
 6024               		.loc 11 164 0
 6025 03ba 8FEF      		 ldi r24,lo8(639999)
 6026 03bc 93EC      	    ldi r25,hi8(639999)
 6027 03be A9E0      	    ldi r26,hlo8(639999)
 6028 03c0 8150      	    1:subi r24,1
 6029 03c2 9040      	    sbci r25,0
 6030 03c4 A040      	    sbci r26,0
 6031 03c6 01F4      	    brne 1b
 6032 03c8 00C0      		rjmp .
 6033 03ca 0000      		nop
 6034               	.LVL345:
 6035               	.LBE1465:
 6036               	.LBE1464:
 6037               	.LBB1466:
 6038               	.LBB1467:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 6039               		.loc 7 16 0
 6040 03cc E12F      		mov r30,r17
 6041 03ce F02F      		mov r31,r16
 6042 03d0 DF01      		movw r26,r30
 6043 03d2 0D90      		ld __tmp_reg__,X+
 6044 03d4 0020      		tst __tmp_reg__
 6045 03d6 01F4      		brne .-6
 6046 03d8 CD01      		movw r24,r26
 6047 03da 8E1B      		sub r24,r30
 6048 03dc 9F0B      		sbc r25,r31
 6049 03de 0996      		adiw r24,9
 6050 03e0 0E94 0000 		call malloc
 6051 03e4 582E      		mov r5,r24
 6052 03e6 492E      		mov r4,r25
 6053               	.LVL346:
  18:utils/utils.h ****     strcpy(result, s1);
 6054               		.loc 7 18 0
 6055 03e8 E82F      		mov r30,r24
 6056 03ea F92F      		mov r31,r25
 6057 03ec A0E0      		ldi r26,lo8(.LC4)
 6058 03ee B0E0      		ldi r27,hi8(.LC4)
 6059 03f0 8AE0      		ldi r24,lo8(10)
 6060               	.LVL347:
 6061               	.L221:
 6062 03f2 0D90      		ld r0,X+
 6063 03f4 0192      		st Z+,r0
 6064 03f6 8150      		subi r24,lo8(-(-1))
 6065 03f8 01F4      		brne .L221
  19:utils/utils.h ****     strcat(result, s2);
 6066               		.loc 7 19 0
 6067 03fa 852D      		mov r24,r5
 6068 03fc 942D      		mov r25,r4
 6069               	.LVL348:
 6070 03fe 612F      		mov r22,r17
 6071 0400 702F      		mov r23,r16
 6072 0402 0E94 0000 		call strcat
 6073               	.LVL349:
 6074               	.LBE1467:
 6075               	.LBE1466:
 6076               	.LBB1468:
 6077               	.LBB1457:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 6078               		.loc 7 16 0
 6079 0406 E52D      		mov r30,r5
 6080 0408 F42D      		mov r31,r4
 6081 040a DF01      		movw r26,r30
 6082 040c 0D90      		ld __tmp_reg__,X+
 6083 040e 0020      		tst __tmp_reg__
 6084 0410 01F4      		brne .-6
 6085 0412 CD01      		movw r24,r26
 6086 0414 8E1B      		sub r24,r30
 6087 0416 9F0B      		sbc r25,r31
 6088 0418 0196      		adiw r24,1
 6089 041a 0E94 0000 		call malloc
 6090 041e 292F      		mov r18,r25
 6091 0420 082F      		mov r16,r24
 6092               	.LVL350:
 6093 0422 192F      		mov r17,r25
 6094               	.LVL351:
  18:utils/utils.h ****     strcpy(result, s1);
 6095               		.loc 7 18 0
 6096 0424 C801      		movw r24,r16
 6097 0426 652D      		mov r22,r5
 6098 0428 742D      		mov r23,r4
 6099 042a C550      		subi r28,lo8(-251)
 6100 042c DF4F      		sbci r29,hi8(-251)
 6101 042e 2883      		st Y,r18
 6102 0430 CB5F      		subi r28,lo8(251)
 6103 0432 D040      		sbci r29,hi8(251)
 6104 0434 0E94 0000 		call strcpy
  19:utils/utils.h ****     strcat(result, s2);
 6105               		.loc 7 19 0
 6106 0438 A02F      		mov r26,r16
 6107 043a C550      		subi r28,lo8(-251)
 6108 043c DF4F      		sbci r29,hi8(-251)
 6109 043e 2881      		ld r18,Y
 6110 0440 CB5F      		subi r28,lo8(251)
 6111 0442 D040      		sbci r29,hi8(251)
 6112 0444 B22F      		mov r27,r18
 6113 0446 FD01      		movw r30,r26
 6114 0448 0190      		ld __tmp_reg__,Z+
 6115 044a 0020      		tst __tmp_reg__
 6116 044c 01F4      		brne .-6
 6117 044e 3197      		sbiw r30,1
 6118 0450 EA1B      		sub r30,r26
 6119 0452 FB0B      		sbc r31,r27
 6120 0454 E00F      		add r30,r16
 6121 0456 F11F      		adc r31,r17
 6122 0458 6082      		st Z,r6
 6123 045a 7182      		std Z+1,r7
 6124               	.LBE1457:
 6125               	.LBE1468:
  28:sms/sms.h     ****   send_uart(number_string, USART);
 6126               		.loc 13 28 0
 6127 045c C801      		movw r24,r16
 6128 045e 60EA      		ldi r22,lo8(2208)
 6129 0460 78E0      		ldi r23,hi8(2208)
 6130 0462 0E94 0000 		call send_uart
 6131               	.LVL352:
 6132               	.LBB1469:
 6133               	.LBB1470:
 6134               		.loc 11 164 0
 6135 0466 8FEF      		 ldi r24,lo8(639999)
 6136 0468 93EC      	    ldi r25,hi8(639999)
 6137 046a A9E0      	    ldi r26,hlo8(639999)
 6138 046c 8150      	    1:subi r24,1
 6139 046e 9040      	    sbci r25,0
 6140 0470 A040      	    sbci r26,0
 6141 0472 01F4      	    brne 1b
 6142 0474 00C0      		rjmp .
 6143 0476 0000      		nop
 6144               	.LBE1470:
 6145               	.LBE1469:
  32:sms/sms.h     ****   send_uart(text_message, USART);
 6146               		.loc 13 32 0
 6147 0478 C101      		movw r24,r2
 6148 047a 60EA      		ldi r22,lo8(2208)
 6149 047c 78E0      		ldi r23,hi8(2208)
 6150 047e 0E94 0000 		call send_uart
 6151               	.LVL353:
 6152               	.LBB1471:
 6153               	.LBB1472:
 6154               		.loc 11 164 0
 6155 0482 8FEF      		 ldi r24,lo8(639999)
 6156 0484 93EC      	    ldi r25,hi8(639999)
 6157 0486 A9E0      	    ldi r26,hlo8(639999)
 6158 0488 8150      	    1:subi r24,1
 6159 048a 9040      	    sbci r25,0
 6160 048c A040      	    sbci r26,0
 6161 048e 01F4      	    brne 1b
 6162 0490 00C0      		rjmp .
 6163 0492 0000      		nop
 6164               	.LVL354:
 6165               	.L222:
 6166               	.LBE1472:
 6167               	.LBE1471:
 6168               	.LBB1473:
 6169               	.LBB1474:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 6170               		.loc 9 18 0
 6171 0494 8091 A108 		lds r24,2209
 6172 0498 85FF      		sbrs r24,5
 6173 049a 00C0      		rjmp .L222
  21:uart/uart.h   ****     USART->DATA = c; 
 6174               		.loc 9 21 0
 6175 049c 9AE1      		ldi r25,lo8(26)
 6176 049e 9093 A008 		sts 2208,r25
 6177               	.LVL355:
 6178               	.LBE1474:
 6179               	.LBE1473:
 6180               	.LBB1475:
 6181               	.LBB1476:
 6182               		.loc 11 164 0
 6183 04a2 8FEF      		 ldi r24,lo8(639999)
 6184 04a4 93EC      	    ldi r25,hi8(639999)
 6185 04a6 A9E0      	    ldi r26,hlo8(639999)
 6186 04a8 8150      	    1:subi r24,1
 6187 04aa 9040      	    sbci r25,0
 6188 04ac A040      	    sbci r26,0
 6189 04ae 01F4      	    brne 1b
 6190 04b0 00C0      		rjmp .
 6191 04b2 0000      		nop
 6192               	.LBE1476:
 6193               	.LBE1475:
 6194               	.LBE1477:
 6195               	.LBE1504:
  66:main.c        ****       	send_message(twilio_number, gps.sms, &USARTC0);
 6196               		.loc 6 66 0
 6197 04b4 1091 0000 		lds r17,twilio_number
 6198 04b8 0091 0000 		lds r16,twilio_number+1
 6199               	.LVL356:
 6200 04bc 2090 0000 		lds r2,gps+14
 6201 04c0 3090 0000 		lds r3,gps+14+1
 6202               	.LVL357:
 6203               	.L223:
 6204               	.LBB1505:
 6205               	.LBB1506:
 6206               	.LBB1507:
 6207               	.LBB1508:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 6208               		.loc 9 18 0
 6209 04c4 8091 A108 		lds r24,2209
 6210 04c8 85FF      		sbrs r24,5
 6211 04ca 00C0      		rjmp .L223
  21:uart/uart.h   ****     USART->DATA = c; 
 6212               		.loc 9 21 0
 6213 04cc 9DE0      		ldi r25,lo8(13)
 6214 04ce 9093 A008 		sts 2208,r25
 6215               	.LBE1508:
 6216               	.LBE1507:
 6217               	.LBB1509:
 6218               	.LBB1510:
 6219               		.loc 11 164 0
 6220 04d2 8FEF      		 ldi r24,lo8(639999)
 6221 04d4 93EC      	    ldi r25,hi8(639999)
 6222 04d6 A9E0      	    ldi r26,hlo8(639999)
 6223 04d8 8150      	    1:subi r24,1
 6224 04da 9040      	    sbci r25,0
 6225 04dc A040      	    sbci r26,0
 6226 04de 01F4      	    brne 1b
 6227 04e0 00C0      		rjmp .
 6228 04e2 0000      		nop
 6229               	.LVL358:
 6230               	.LBE1510:
 6231               	.LBE1509:
 6232               	.LBB1511:
 6233               	.LBB1512:
  42:sms/sms.h     ****   send_uart("AT+CMGF=1", USART);
 6234               		.loc 13 42 0
 6235 04e4 80E0      		ldi r24,lo8(.LC3)
 6236 04e6 90E0      		ldi r25,hi8(.LC3)
 6237 04e8 60EA      		ldi r22,lo8(2208)
 6238 04ea 78E0      		ldi r23,hi8(2208)
 6239 04ec 0E94 0000 		call send_uart
 6240               	.LVL359:
 6241               	.LBE1512:
 6242               	.LBE1511:
 6243               	.LBB1513:
 6244               	.LBB1514:
 6245               		.loc 11 164 0
 6246 04f0 8FEF      		 ldi r24,lo8(639999)
 6247 04f2 93EC      	    ldi r25,hi8(639999)
 6248 04f4 A9E0      	    ldi r26,hlo8(639999)
 6249 04f6 8150      	    1:subi r24,1
 6250 04f8 9040      	    sbci r25,0
 6251 04fa A040      	    sbci r26,0
 6252 04fc 01F4      	    brne 1b
 6253 04fe 00C0      		rjmp .
 6254 0500 0000      		nop
 6255               	.LVL360:
 6256               	.LBE1514:
 6257               	.LBE1513:
 6258               	.LBB1515:
 6259               	.LBB1516:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 6260               		.loc 7 16 0
 6261 0502 E12F      		mov r30,r17
 6262 0504 F02F      		mov r31,r16
 6263 0506 DF01      		movw r26,r30
 6264 0508 0D90      		ld __tmp_reg__,X+
 6265 050a 0020      		tst __tmp_reg__
 6266 050c 01F4      		brne .-6
 6267 050e CD01      		movw r24,r26
 6268 0510 8E1B      		sub r24,r30
 6269 0512 9F0B      		sbc r25,r31
 6270 0514 0996      		adiw r24,9
 6271 0516 0E94 0000 		call malloc
 6272 051a 582E      		mov r5,r24
 6273               	.LVL361:
 6274 051c 492E      		mov r4,r25
 6275               	.LVL362:
  18:utils/utils.h ****     strcpy(result, s1);
 6276               		.loc 7 18 0
 6277 051e E82F      		mov r30,r24
 6278 0520 F92F      		mov r31,r25
 6279 0522 A0E0      		ldi r26,lo8(.LC4)
 6280 0524 B0E0      		ldi r27,hi8(.LC4)
 6281 0526 8AE0      		ldi r24,lo8(10)
 6282               	.LVL363:
 6283               	.L224:
 6284 0528 0D90      		ld r0,X+
 6285 052a 0192      		st Z+,r0
 6286 052c 8150      		subi r24,lo8(-(-1))
 6287 052e 01F4      		brne .L224
  19:utils/utils.h ****     strcat(result, s2);
 6288               		.loc 7 19 0
 6289 0530 852D      		mov r24,r5
 6290 0532 942D      		mov r25,r4
 6291               	.LVL364:
 6292 0534 612F      		mov r22,r17
 6293 0536 702F      		mov r23,r16
 6294 0538 0E94 0000 		call strcat
 6295               	.LVL365:
 6296               	.LBE1516:
 6297               	.LBE1515:
 6298               	.LBB1517:
 6299               	.LBB1518:
  16:utils/utils.h ****     char *result = malloc(strlen(s1)+strlen(s2)+1);
 6300               		.loc 7 16 0
 6301 053c E52D      		mov r30,r5
 6302 053e F42D      		mov r31,r4
 6303 0540 DF01      		movw r26,r30
 6304 0542 0D90      		ld __tmp_reg__,X+
 6305 0544 0020      		tst __tmp_reg__
 6306 0546 01F4      		brne .-6
 6307 0548 CD01      		movw r24,r26
 6308 054a 8E1B      		sub r24,r30
 6309 054c 9F0B      		sbc r25,r31
 6310 054e 0196      		adiw r24,1
 6311 0550 0E94 0000 		call malloc
 6312 0554 292F      		mov r18,r25
 6313 0556 082F      		mov r16,r24
 6314               	.LVL366:
 6315 0558 192F      		mov r17,r25
 6316               	.LVL367:
  18:utils/utils.h ****     strcpy(result, s1);
 6317               		.loc 7 18 0
 6318 055a C801      		movw r24,r16
 6319 055c 652D      		mov r22,r5
 6320 055e 742D      		mov r23,r4
 6321 0560 C550      		subi r28,lo8(-251)
 6322 0562 DF4F      		sbci r29,hi8(-251)
 6323 0564 2883      		st Y,r18
 6324 0566 CB5F      		subi r28,lo8(251)
 6325 0568 D040      		sbci r29,hi8(251)
 6326 056a 0E94 0000 		call strcpy
  19:utils/utils.h ****     strcat(result, s2);
 6327               		.loc 7 19 0
 6328 056e A02F      		mov r26,r16
 6329 0570 C550      		subi r28,lo8(-251)
 6330 0572 DF4F      		sbci r29,hi8(-251)
 6331 0574 2881      		ld r18,Y
 6332 0576 CB5F      		subi r28,lo8(251)
 6333 0578 D040      		sbci r29,hi8(251)
 6334 057a B22F      		mov r27,r18
 6335 057c FD01      		movw r30,r26
 6336 057e 0190      		ld __tmp_reg__,Z+
 6337 0580 0020      		tst __tmp_reg__
 6338 0582 01F4      		brne .-6
 6339 0584 3197      		sbiw r30,1
 6340 0586 EA1B      		sub r30,r26
 6341 0588 FB0B      		sbc r31,r27
 6342 058a E00F      		add r30,r16
 6343 058c F11F      		adc r31,r17
 6344 058e 6082      		st Z,r6
 6345 0590 7182      		std Z+1,r7
 6346               	.LBE1518:
 6347               	.LBE1517:
  28:sms/sms.h     ****   send_uart(number_string, USART);
 6348               		.loc 13 28 0
 6349 0592 C801      		movw r24,r16
 6350 0594 60EA      		ldi r22,lo8(2208)
 6351 0596 78E0      		ldi r23,hi8(2208)
 6352 0598 0E94 0000 		call send_uart
 6353               	.LBB1519:
 6354               	.LBB1520:
 6355               		.loc 11 164 0
 6356 059c 8FEF      		 ldi r24,lo8(639999)
 6357 059e 93EC      	    ldi r25,hi8(639999)
 6358 05a0 A9E0      	    ldi r26,hlo8(639999)
 6359 05a2 8150      	    1:subi r24,1
 6360 05a4 9040      	    sbci r25,0
 6361 05a6 A040      	    sbci r26,0
 6362 05a8 01F4      	    brne 1b
 6363 05aa 00C0      		rjmp .
 6364 05ac 0000      		nop
 6365               	.LBE1520:
 6366               	.LBE1519:
  32:sms/sms.h     ****   send_uart(text_message, USART);
 6367               		.loc 13 32 0
 6368 05ae C101      		movw r24,r2
 6369 05b0 60EA      		ldi r22,lo8(2208)
 6370 05b2 78E0      		ldi r23,hi8(2208)
 6371 05b4 0E94 0000 		call send_uart
 6372               	.LBB1521:
 6373               	.LBB1522:
 6374               		.loc 11 164 0
 6375 05b8 8FEF      		 ldi r24,lo8(639999)
 6376 05ba 93EC      	    ldi r25,hi8(639999)
 6377 05bc A9E0      	    ldi r26,hlo8(639999)
 6378 05be 8150      	    1:subi r24,1
 6379 05c0 9040      	    sbci r25,0
 6380 05c2 A040      	    sbci r26,0
 6381 05c4 01F4      	    brne 1b
 6382 05c6 00C0      		rjmp .
 6383 05c8 0000      		nop
 6384               	.LVL368:
 6385               	.L225:
 6386               	.LBE1522:
 6387               	.LBE1521:
 6388               	.LBB1523:
 6389               	.LBB1524:
  18:uart/uart.h   ****     while ( !( USART->STATUS & USART_DREIF_bm) ); 
 6390               		.loc 9 18 0
 6391 05ca 8091 A108 		lds r24,2209
 6392 05ce 85FF      		sbrs r24,5
 6393 05d0 00C0      		rjmp .L225
  21:uart/uart.h   ****     USART->DATA = c; 
 6394               		.loc 9 21 0
 6395 05d2 9AE1      		ldi r25,lo8(26)
 6396 05d4 9093 A008 		sts 2208,r25
 6397               	.LVL369:
 6398               	.LBE1524:
 6399               	.LBE1523:
 6400               	.LBB1525:
 6401               	.LBB1526:
 6402               		.loc 11 164 0
 6403 05d8 8FEF      		 ldi r24,lo8(639999)
 6404 05da 93EC      	    ldi r25,hi8(639999)
 6405 05dc A9E0      	    ldi r26,hlo8(639999)
 6406 05de 8150      	    1:subi r24,1
 6407 05e0 9040      	    sbci r25,0
 6408 05e2 A040      	    sbci r26,0
 6409 05e4 01F4      	    brne 1b
 6410 05e6 00C0      		rjmp .
 6411 05e8 0000      		nop
 6412               	.LBE1526:
 6413               	.LBE1525:
 6414               	.LBE1506:
 6415               	.LBE1505:
  67:main.c        ****       	freq = HIGH_FREQ;
 6416               		.loc 6 67 0
 6417 05ea 91E0      		ldi r25,lo8(1)
 6418 05ec 9093 0000 		sts freq,r25
 6419 05f0 00C0      		rjmp .L227
 6420               	.LVL370:
 6421               	.L241:
 6422               	.LBB1527:
 6423               	.LBB1500:
 6424               	.LBB1498:
 6425               	.LBB1496:
 6426               	.LBB1494:
 6427               	.LBB1487:
  86:nmea/nmea.h   ****       gps->roaming = 0;
 6428               		.loc 8 86 0
 6429 05f2 1092 0000 		sts gps+13,__zero_reg__
 6430 05f6 00C0      		rjmp .L216
 6431               	.LBE1487:
 6432               	.LBE1494:
 6433               	.LBE1496:
 6434               	.LBE1498:
 6435               	.LBE1500:
 6436               	.LBE1527:
 6437               		.cfi_endproc
 6438               	.LFE80:
 6440               		.text
 6441               	.global	EVENT_USB_Device_ControlRequest
 6443               	EVENT_USB_Device_ControlRequest:
 6444               	.LFB81:
  97:main.c        **** bool EVENT_USB_Device_ControlRequest(USB_Request_Header_t* req){
 6445               		.loc 6 97 0
 6446               		.cfi_startproc
 6447               	.LVL371:
 6448 165c 0F93      		push r16
 6449               	.LCFI136:
 6450               		.cfi_def_cfa_offset 3
 6451               		.cfi_offset 16, -2
 6452 165e 1F93      		push r17
 6453               	.LCFI137:
 6454               		.cfi_def_cfa_offset 4
 6455               		.cfi_offset 17, -3
 6456 1660 CF93      		push r28
 6457               	.LCFI138:
 6458               		.cfi_def_cfa_offset 5
 6459               		.cfi_offset 28, -4
 6460 1662 DF93      		push r29
 6461               	.LCFI139:
 6462               		.cfi_def_cfa_offset 6
 6463               		.cfi_offset 29, -5
 6464               	/* prologue: function */
 6465               	/* frame size = 0 */
 6466               	/* stack size = 4 */
 6467               	.L__stack_usage = 4
 6468 1664 9C01      		movw r18,r24
 6469               	.LVL372:
 157:main.c        **** 	return false;
 6470               		.loc 6 157 0
 6471 1666 A0E0      		ldi r26,lo8(ep0_buf_in)
 6472 1668 B0E0      		ldi r27,hi8(ep0_buf_in)
  97:main.c        **** bool EVENT_USB_Device_ControlRequest(USB_Request_Header_t* req){
 6473               		.loc 6 97 0
 6474 166a 8D01      		movw r16,r26
 6475 166c 80E0      		ldi r24,lo8(ep0_buf_in+64)
 6476 166e 90E0      		ldi r25,hi8(ep0_buf_in+64)
 6477               	.LVL373:
 6478 1670 FD01      		movw r30,r26
 6479               	.LVL374:
 6480               	.L246:
 6481               	.LBB1528:
  99:main.c        **** 	for (uint8_t i = 0; i < 64; i++) ep0_buf_in[i] = 0;
 6482               		.loc 6 99 0 discriminator 2
 6483 1672 1192      		st Z+,__zero_reg__
 6484 1674 40E0      		ldi r20,hi8(ep0_buf_in+64)
 6485 1676 E030      		cpi r30,lo8(ep0_buf_in+64)
 6486 1678 F407      		cpc r31,r20
 6487 167a 01F4      		brne .L246
 6488               	.LBE1528:
 100:main.c        **** 	usb_cmd = 0;
 6489               		.loc 6 100 0
 6490 167c 1092 0000 		sts usb_cmd,__zero_reg__
 101:main.c        **** 	if ((req->bmRequestType & CONTROL_REQTYPE_TYPE) == REQTYPE_VENDOR){
 6491               		.loc 6 101 0
 6492 1680 F901      		movw r30,r18
 6493 1682 C081      		ld r28,Z
 6494 1684 D0E0      		ldi r29,lo8(0)
 6495 1686 C076      		andi r28,lo8(96)
 6496 1688 D070      		andi r29,hi8(96)
 6497 168a C034      		cpi r28,64
 6498 168c D105      		cpc r29,__zero_reg__
 6499 168e 01F0      		breq .L270
 6500               	.L264:
 157:main.c        **** 	return false;
 6501               		.loc 6 157 0
 6502 1690 80E0      		ldi r24,lo8(0)
 6503               	.LVL375:
 6504               	.L247:
 6505               	/* epilogue start */
 158:main.c        **** }
 6506               		.loc 6 158 0
 6507 1692 DF91      		pop r29
 6508 1694 CF91      		pop r28
 6509 1696 1F91      		pop r17
 6510 1698 0F91      		pop r16
 6511 169a 0895      		ret
 6512               	.LVL376:
 6513               	.L270:
 102:main.c        **** 		switch(req->bRequest){
 6514               		.loc 6 102 0
 6515 169c 4181      		ldd r20,Z+1
 6516 169e 4631      		cpi r20,lo8(22)
 6517 16a0 01F4      		brne .+2
 6518 16a2 00C0      		rjmp .L252
 6519 16a4 4731      		cpi r20,lo8(23)
 6520 16a6 00F0      		brlo .L271
 6521 16a8 4B3B      		cpi r20,lo8(-69)
 6522 16aa 01F4      		brne .+2
 6523 16ac 00C0      		rjmp .L254
 6524 16ae 4C3B      		cpi r20,lo8(-68)
 6525 16b0 00F0      		brlo .+2
 6526 16b2 00C0      		rjmp .L259
 6527 16b4 4731      		cpi r20,lo8(23)
 6528 16b6 01F4      		brne .L264
 6529               	.LBB1529:
 133:main.c        **** 				addr = (uint16_t *) req->wIndex;
 6530               		.loc 6 133 0
 6531 16b8 0480      		ldd __tmp_reg__,Z+4
 6532 16ba F581      		ldd r31,Z+5
 6533 16bc E02D      		mov r30,__tmp_reg__
 6534               	.LVL377:
 134:main.c        **** 				ep0_buf_in[0] = *addr & 0xFF;
 6535               		.loc 6 134 0
 6536 16be 8081      		ld r24,Z
 6537 16c0 8093 0000 		sts ep0_buf_in,r24
 135:main.c        **** 				ep0_buf_in[1] = *addr >> 8;
 6538               		.loc 6 135 0
 6539 16c4 8181      		ldd r24,Z+1
 6540 16c6 8093 0000 		sts ep0_buf_in+1,r24
 6541               	.LVL378:
 6542               	.LBB1530:
 6543               	.LBB1531:
 6544               	.LBB1532:
 6545               	.LBB1533:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 6546               		.loc 5 168 0
 6547 16ca 0093 0000 		sts endpoints+12,r16
 6548 16ce 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 6549               		.loc 5 169 0
 6550 16d2 82E0      		ldi r24,lo8(2)
 6551 16d4 90E0      		ldi r25,hi8(2)
 6552 16d6 8093 0000 		sts endpoints+10,r24
 6553 16da 9093 0000 		sts endpoints+10+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 6554               		.loc 5 174 0
 6555 16de E0E0      		ldi r30,lo8(endpoints+8)
 6556 16e0 F0E0      		ldi r31,hi8(endpoints+8)
 6557               	/* #APP */
 6558               	 ;  174 "usb/usb.h" 1
 6559 16e2 02E2      		ldi r16, 34
 6560 16e4 0693      		.dc.w 0x9306
 6561               		
 6562               	 ;  0 "" 2
 6563               	/* #NOAPP */
 6564               	.LBE1533:
 6565               	.LBE1532:
 6566               	.LBE1531:
 6567               	.LBE1530:
 6568               	.LBE1529:
 137:main.c        **** 				return true;
 6569               		.loc 6 137 0
 6570 16e6 81E0      		ldi r24,lo8(1)
 6571 16e8 00C0      		rjmp .L247
 6572               	.LVL379:
 6573               	.L271:
 102:main.c        **** 		switch(req->bRequest){
 6574               		.loc 6 102 0
 6575 16ea 4230      		cpi r20,lo8(2)
 6576 16ec 01F4      		brne .+2
 6577 16ee 00C0      		rjmp .L249
 6578 16f0 4330      		cpi r20,lo8(3)
 6579 16f2 00F4      		brsh .L258
 6580 16f4 4423      		tst r20
 6581 16f6 01F4      		brne .L264
 104:main.c        **** 				if (req->wIndex == 0){
 6582               		.loc 6 104 0
 6583 16f8 8481      		ldd r24,Z+4
 6584 16fa 9581      		ldd r25,Z+5
 6585 16fc 0097      		sbiw r24,0
 6586 16fe 01F4      		brne .+2
 6587 1700 00C0      		rjmp .L272
 106:main.c        **** 				}else if (req->wIndex == 1){
 6588               		.loc 6 106 0
 6589 1702 8130      		cpi r24,1
 6590 1704 9105      		cpc r25,__zero_reg__
 6591 1706 01F4      		brne .+2
 6592 1708 00C0      		rjmp .L273
 109:main.c        **** 				return true;
 6593               		.loc 6 109 0
 6594 170a 81E0      		ldi r24,lo8(1)
 6595 170c 00C0      		rjmp .L247
 6596               	.L258:
 102:main.c        **** 		switch(req->bRequest){
 6597               		.loc 6 102 0
 6598 170e 4830      		cpi r20,lo8(8)
 6599 1710 01F0      		breq .L250
 6600 1712 4930      		cpi r20,lo8(9)
 6601 1714 01F0      		breq .+2
 6602 1716 00C0      		rjmp .L264
 124:main.c        **** 				ep0_buf_in[0] = * ((uint8_t *) req->wIndex);
 6603               		.loc 6 124 0
 6604 1718 0480      		ldd __tmp_reg__,Z+4
 6605 171a F581      		ldd r31,Z+5
 6606 171c E02D      		mov r30,__tmp_reg__
 6607 171e 8081      		ld r24,Z
 6608 1720 8093 0000 		sts ep0_buf_in,r24
 6609               	.LVL380:
 6610               	.LBB1534:
 6611               	.LBB1535:
 6612               	.LBB1536:
 6613               	.LBB1537:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 6614               		.loc 5 168 0
 6615 1724 0093 0000 		sts endpoints+12,r16
 6616 1728 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 6617               		.loc 5 169 0
 6618 172c 81E0      		ldi r24,lo8(1)
 6619 172e 90E0      		ldi r25,hi8(1)
 6620 1730 8093 0000 		sts endpoints+10,r24
 6621 1734 9093 0000 		sts endpoints+10+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 6622               		.loc 5 174 0
 6623 1738 E0E0      		ldi r30,lo8(endpoints+8)
 6624 173a F0E0      		ldi r31,hi8(endpoints+8)
 6625               	.LVL381:
 6626               	/* #APP */
 6627               	 ;  174 "usb/usb.h" 1
 6628 173c 02E2      		ldi r16, 34
 6629 173e 0693      		.dc.w 0x9306
 6630               		
 6631               	 ;  0 "" 2
 6632               	/* #NOAPP */
 6633               	.LBE1537:
 6634               	.LBE1536:
 6635               	.LBE1535:
 6636               	.LBE1534:
 126:main.c        **** 				return true;
 6637               		.loc 6 126 0
 6638 1740 81E0      		ldi r24,lo8(1)
 6639 1742 00C0      		rjmp .L247
 6640               	.LVL382:
 6641               	.L259:
 102:main.c        **** 		switch(req->bRequest){
 6642               		.loc 6 102 0
 6643 1744 403E      		cpi r20,lo8(-32)
 6644 1746 01F0      		breq .L255
 6645 1748 413E      		cpi r20,lo8(-31)
 6646 174a 01F0      		breq .+2
 6647 174c 00C0      		rjmp .L264
 146:main.c        **** 				usb_cmd = req->bRequest;
 6648               		.loc 6 146 0
 6649 174e 4093 0000 		sts usb_cmd,r20
 147:main.c        **** 				cmd_data = req->wIndex;
 6650               		.loc 6 147 0
 6651 1752 8481      		ldd r24,Z+4
 6652 1754 8093 0000 		sts cmd_data,r24
 6653               	.LVL383:
 6654               	.L269:
 6655               	.LBB1538:
 6656               	.LBB1539:
 6657               	.LBB1540:
 6658               	.LBB1541:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 6659               		.loc 5 168 0
 6660 1758 0093 0000 		sts endpoints+12,r16
 6661 175c 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 6662               		.loc 5 169 0
 6663 1760 1092 0000 		sts endpoints+10,__zero_reg__
 6664 1764 1092 0000 		sts endpoints+10+1,__zero_reg__
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 6665               		.loc 5 174 0
 6666 1768 E0E0      		ldi r30,lo8(endpoints+8)
 6667 176a F0E0      		ldi r31,hi8(endpoints+8)
 6668               	.LVL384:
 6669               	/* #APP */
 6670               	 ;  174 "usb/usb.h" 1
 6671 176c 02E2      		ldi r16, 34
 6672 176e 0693      		.dc.w 0x9306
 6673               		
 6674               	 ;  0 "" 2
 6675               	/* #NOAPP */
 6676               	.LBE1541:
 6677               	.LBE1540:
 6678               	.LBE1539:
 6679               	.LBE1538:
 130:main.c        **** 				return true;
 6680               		.loc 6 130 0
 6681 1770 81E0      		ldi r24,lo8(1)
 6682               	/* epilogue start */
 158:main.c        **** }
 6683               		.loc 6 158 0
 6684 1772 DF91      		pop r29
 6685 1774 CF91      		pop r28
 6686 1776 1F91      		pop r17
 6687 1778 0F91      		pop r16
 6688 177a 0895      		ret
 6689               	.LVL385:
 6690               	.L250:
 120:main.c        **** 				* ((uint8_t *) req->wIndex) = req->wValue;
 6691               		.loc 6 120 0
 6692 177c D901      		movw r26,r18
 6693 177e 0480      		ldd __tmp_reg__,Z+4
 6694 1780 F581      		ldd r31,Z+5
 6695 1782 E02D      		mov r30,__tmp_reg__
 6696 1784 1296      		adiw r26,2
 6697 1786 8C91      		ld r24,X
 6698 1788 1297      		sbiw r26,2
 6699 178a 8083      		st Z,r24
 6700               	.LVL386:
 6701 178c 00C0      		rjmp .L269
 6702               	.LVL387:
 6703               	.L255:
 140:main.c        **** 				eeprom_read_block(ep0_buf_in, (void*)(req->wIndex*64), 64);
 6704               		.loc 6 140 0
 6705 178e F901      		movw r30,r18
 6706 1790 6481      		ldd r22,Z+4
 6707 1792 7581      		ldd r23,Z+5
 6708 1794 0024      		clr __tmp_reg__
 6709 1796 7695      		lsr r23
 6710 1798 6795      		ror r22
 6711 179a 0794      		ror __tmp_reg__
 6712 179c 7695      		lsr r23
 6713 179e 6795      		ror r22
 6714 17a0 0794      		ror __tmp_reg__
 6715 17a2 762F      		mov r23,r22
 6716 17a4 602D      		mov r22,__tmp_reg__
 6717 17a6 80E0      		ldi r24,lo8(ep0_buf_in)
 6718 17a8 90E0      		ldi r25,hi8(ep0_buf_in)
 6719 17aa 40E4      		ldi r20,lo8(64)
 6720 17ac 50E0      		ldi r21,hi8(64)
 6721 17ae 0E94 0000 		call __eerd_block_x32a4u
 6722               	.LVL388:
 6723               	.LBB1542:
 6724               	.LBB1543:
 6725               	.LBB1544:
 6726               	.LBB1545:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 6727               		.loc 5 168 0
 6728 17b2 0093 0000 		sts endpoints+12,r16
 6729 17b6 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 6730               		.loc 5 169 0
 6731 17ba C093 0000 		sts endpoints+10,r28
 6732 17be D093 0000 		sts endpoints+10+1,r29
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 6733               		.loc 5 174 0
 6734 17c2 E0E0      		ldi r30,lo8(endpoints+8)
 6735 17c4 F0E0      		ldi r31,hi8(endpoints+8)
 6736               	.LVL389:
 6737               	/* #APP */
 6738               	 ;  174 "usb/usb.h" 1
 6739 17c6 02E2      		ldi r16, 34
 6740 17c8 0693      		.dc.w 0x9306
 6741               		
 6742               	 ;  0 "" 2
 6743               	/* #NOAPP */
 6744               	.LBE1545:
 6745               	.LBE1544:
 6746               	.LBE1543:
 6747               	.LBE1542:
 142:main.c        **** 				return true;
 6748               		.loc 6 142 0
 6749 17ca 81E0      		ldi r24,lo8(1)
 6750 17cc 00C0      		rjmp .L247
 6751               	.LVL390:
 6752               	.L254:
 6753               	.LBB1546:
 6754               	.LBB1547:
 330:usb/usb.h     **** 		USB_ep0_enableOut();
 331:usb/usb.h     **** 	}
 332:usb/usb.h     **** }
 333:usb/usb.h     **** 
 334:usb/usb.h     **** static inline void USB_enter_bootloader(void){
 335:usb/usb.h     **** 	cli();
 6755               		.loc 5 335 0
 6756               	/* #APP */
 6757               	 ;  335 "usb/usb.h" 1
 6758 17ce F894      		cli
 6759               	 ;  0 "" 2
 6760               	.LVL391:
 6761               	/* #NOAPP */
 6762               	.LBB1548:
 6763               	.LBB1549:
 6764               	.LBB1550:
 6765               	.LBB1551:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 6766               		.loc 5 168 0
 6767 17d0 0093 0000 		sts endpoints+12,r16
 6768 17d4 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 6769               		.loc 5 169 0
 6770 17d8 1092 0000 		sts endpoints+10,__zero_reg__
 6771 17dc 1092 0000 		sts endpoints+10+1,__zero_reg__
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 6772               		.loc 5 174 0
 6773 17e0 E0E0      		ldi r30,lo8(endpoints+8)
 6774 17e2 F0E0      		ldi r31,hi8(endpoints+8)
 6775               	.LVL392:
 6776               	/* #APP */
 6777               	 ;  174 "usb/usb.h" 1
 6778 17e4 02E2      		ldi r16, 34
 6779 17e6 0693      		.dc.w 0x9306
 6780               		
 6781               	 ;  0 "" 2
 6782               	/* #NOAPP */
 6783               	.LBE1551:
 6784               	.LBE1550:
 6785               	.LBE1549:
 6786               	.LBE1548:
 6787               	.LBB1552:
 6788               	.LBB1553:
 280:usb/usb.h     **** 	LACR16(&endpoints[0].out.STATUS, USB_EP_SETUP_bm | USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm | USB_
 6789               		.loc 5 280 0
 6790 17e8 3897      		sbiw r30,8
 6791               	.LVL393:
 6792               	/* #APP */
 6793               	 ;  280 "usb/usb.h" 1
 6794 17ea 02E7      		ldi r16, 114
 6795 17ec 0693      		.dc.w 0x9306
 6796               		
 6797               	 ;  0 "" 2
 6798               	.LVL394:
 6799               	/* #NOAPP */
 6800               	.L262:
 6801               	.LBE1553:
 6802               	.LBE1552:
 6803               	.LBB1554:
 6804               	.LBB1555:
 6805               	.LBB1556:
 6806               	.LBB1557:
 202:usb/usb.h     **** 		return e->STATUS & USB_EP_TRNCOMPL0_bm;
 6807               		.loc 5 202 0
 6808 17ee 8091 0000 		lds r24,endpoints
 6809               	.LBE1557:
 6810               	.LBE1556:
 253:usb/usb.h     **** 	while (!USB_ep_done(ep)){};
 6811               		.loc 5 253 0
 6812 17f2 85FF      		sbrs r24,5
 6813 17f4 00C0      		rjmp .L262
 6814               	.LVL395:
 6815               	.LBE1555:
 6816               	.LBE1554:
 6817               	.LBB1558:
 6818               	.LBB1559:
 6819               		.loc 11 164 0
 6820 17f6 8FEF      		 ldi r24,lo8(63999)
 6821 17f8 99EF      	    ldi r25,hi8(63999)
 6822 17fa A0E0      	    ldi r26,hlo8(63999)
 6823 17fc 8150      	    1:subi r24,1
 6824 17fe 9040      	    sbci r25,0
 6825 1800 A040      	    sbci r26,0
 6826 1802 01F4      	    brne 1b
 6827 1804 00C0      		rjmp .
 6828 1806 0000      		nop
 6829               	.LBE1559:
 6830               	.LBE1558:
 6831               	.LBB1560:
 6832               	.LBB1561:
 296:usb/usb.h     **** 	USB.CTRLB &= ~USB_ATTACH_bm;
 6833               		.loc 5 296 0
 6834 1808 8091 C104 		lds r24,1217
 6835 180c 8E7F      		andi r24,lo8(-2)
 6836 180e E0EC      		ldi r30,lo8(1216)
 6837 1810 F4E0      		ldi r31,hi8(1216)
 6838               	.LVL396:
 6839 1812 8183      		std Z+1,r24
 6840               	.LVL397:
 6841               	.LBE1561:
 6842               	.LBE1560:
 6843               	.LBB1562:
 6844               	.LBB1563:
 6845               		.loc 11 164 0
 6846 1814 8FEF      		 ldi r24,lo8(639999)
 6847 1816 93EC      	    ldi r25,hi8(639999)
 6848 1818 A9E0      	    ldi r26,hlo8(639999)
 6849 181a 8150      	    1:subi r24,1
 6850 181c 9040      	    sbci r25,0
 6851 181e A040      	    sbci r26,0
 6852 1820 01F4      	    brne 1b
 6853 1822 00C0      		rjmp .
 6854 1824 0000      		nop
 6855               	.LVL398:
 6856               	.LBE1563:
 6857               	.LBE1562:
 336:usb/usb.h     **** 	USB_ep0_send(0);
 337:usb/usb.h     **** 	USB_ep0_enableOut();
 338:usb/usb.h     **** 	USB_ep_wait(0x00); // Wait for the status stage to complete
 339:usb/usb.h     **** 	_delay_ms(10);
 340:usb/usb.h     **** 	USB_Detach();
 341:usb/usb.h     **** 	_delay_ms(100);
 342:usb/usb.h     **** 	void (*enter_bootloader)(void) = (void*) 0x47fc /*0x8ff8/2*/;
 343:usb/usb.h     **** 	enter_bootloader();
 6858               		.loc 5 343 0
 6859 1826 ECEF      		ldi r30,lo8(18428)
 6860 1828 F7E4      		ldi r31,hi8(18428)
 6861 182a 0995      		icall
 6862               	.LVL399:
 6863               	.LBE1547:
 6864               	.LBE1546:
 154:main.c        **** 				return true;
 6865               		.loc 6 154 0
 6866 182c 81E0      		ldi r24,lo8(1)
 6867 182e 00C0      		rjmp .L247
 6868               	.LVL400:
 6869               	.L249:
 6870               	.LBB1564:
 112:main.c        **** 					int l = strlen(message);
 6871               		.loc 6 112 0
 6872 1830 3091 0000 		lds r19,message
 6873 1834 2091 0000 		lds r18,message+1
 6874               	.LVL401:
 6875 1838 C32F      		mov r28,r19
 6876 183a D22F      		mov r29,r18
 6877 183c FE01      		movw r30,r28
 6878               	.LVL402:
 6879 183e 0190      		ld __tmp_reg__,Z+
 6880 1840 0020      		tst __tmp_reg__
 6881 1842 01F4      		brne .-6
 6882 1844 3197      		sbiw r30,1
 6883 1846 E31B      		sub r30,r19
 6884               	.LVL403:
 6885               	.L261:
 6886               	.LBB1565:
 114:main.c        **** 						ep0_buf_in[i] = message[i];
 6887               		.loc 6 114 0 discriminator 2
 6888 1848 2991      		ld r18,Y+
 6889 184a 2D93      		st X+,r18
 113:main.c        **** 					for (uint8_t i=0; i<64; i++) {
 6890               		.loc 6 113 0 discriminator 2
 6891 184c 8A17      		cp r24,r26
 6892 184e 9B07      		cpc r25,r27
 6893 1850 01F4      		brne .L261
 6894               	.LVL404:
 6895               	.LBE1565:
 6896               	.LBB1566:
 6897               	.LBB1567:
 247:usb/usb.h     **** 	USB_ep_in_start(0x80, ep0_buf_in, size);
 6898               		.loc 5 247 0
 6899 1852 8E2F      		mov r24,r30
 6900 1854 90E0      		ldi r25,lo8(0)
 6901               	.LVL405:
 6902               	.LBB1568:
 6903               	.LBB1569:
 6904               	.LBB1570:
 168:usb/usb.h     **** 	b->DATAPTR = (unsigned) addr;
 6905               		.loc 5 168 0
 6906 1856 0093 0000 		sts endpoints+12,r16
 6907 185a 1093 0000 		sts endpoints+12+1,r17
 169:usb/usb.h     **** 	if (ep & USB_EP_IN) b->CNT = size;
 6908               		.loc 5 169 0
 6909 185e 8093 0000 		sts endpoints+10,r24
 6910 1862 9093 0000 		sts endpoints+10+1,r25
 174:usb/usb.h     **** 		LACR16(&(e->STATUS), USB_EP_BUSNACK0_bm | USB_EP_TRNCOMPL0_bm);
 6911               		.loc 5 174 0
 6912 1866 E0E0      		ldi r30,lo8(endpoints+8)
 6913 1868 F0E0      		ldi r31,hi8(endpoints+8)
 6914               	.LVL406:
 6915               	/* #APP */
 6916               	 ;  174 "usb/usb.h" 1
 6917 186a 02E2      		ldi r16, 34
 6918 186c 0693      		.dc.w 0x9306
 6919               		
 6920               	 ;  0 "" 2
 6921               	/* #NOAPP */
 6922               	.LBE1570:
 6923               	.LBE1569:
 6924               	.LBE1568:
 6925               	.LBE1567:
 6926               	.LBE1566:
 117:main.c        **** 					return true;
 6927               		.loc 6 117 0
 6928 186e 81E0      		ldi r24,lo8(1)
 6929               	.LVL407:
 6930 1870 00C0      		rjmp .L247
 6931               	.LVL408:
 6932               	.L252:
 6933               	.LBE1564:
 128:main.c        **** 				* ((uint16_t *) req->wIndex) = req->wValue;
 6934               		.loc 6 128 0
 6935 1872 F901      		movw r30,r18
 6936 1874 8281      		ldd r24,Z+2
 6937 1876 9381      		ldd r25,Z+3
 6938 1878 0480      		ldd __tmp_reg__,Z+4
 6939 187a F581      		ldd r31,Z+5
 6940 187c E02D      		mov r30,__tmp_reg__
 6941 187e 8083      		st Z,r24
 6942 1880 9183      		std Z+1,r25
 6943 1882 00C0      		rjmp .L269
 6944               	.L273:
 107:main.c        **** 					USB_ep0_send_progmem((uint8_t*)fwversion, sizeof(fwversion));
 6945               		.loc 6 107 0
 6946 1884 80E0      		ldi r24,lo8(fwversion)
 6947 1886 90E0      		ldi r25,hi8(fwversion)
 6948 1888 6BE0      		ldi r22,lo8(11)
 6949 188a 70E0      		ldi r23,hi8(11)
 6950 188c 0E94 0000 		call USB_ep0_send_progmem
 6951               	.LVL409:
 109:main.c        **** 				return true;
 6952               		.loc 6 109 0
 6953 1890 81E0      		ldi r24,lo8(1)
 6954 1892 00C0      		rjmp .L247
 6955               	.LVL410:
 6956               	.L272:
 105:main.c        **** 					USB_ep0_send_progmem((uint8_t*)hwversion, sizeof(hwversion));
 6957               		.loc 6 105 0
 6958 1894 80E0      		ldi r24,lo8(hwversion)
 6959 1896 90E0      		ldi r25,hi8(hwversion)
 6960 1898 6BE0      		ldi r22,lo8(11)
 6961 189a 70E0      		ldi r23,hi8(11)
 6962 189c 0E94 0000 		call USB_ep0_send_progmem
 6963               	.LVL411:
 109:main.c        **** 				return true;
 6964               		.loc 6 109 0
 6965 18a0 81E0      		ldi r24,lo8(1)
 6966 18a2 00C0      		rjmp .L247
 6967               		.cfi_endproc
 6968               	.LFE81:
 6970               	.global	EVENT_USB_Device_ControlOUT
 6972               	EVENT_USB_Device_ControlOUT:
 6973               	.LFB82:
 160:main.c        **** void EVENT_USB_Device_ControlOUT(uint8_t* buf, uint8_t count){
 6974               		.loc 6 160 0
 6975               		.cfi_startproc
 6976               	.LVL412:
 6977               	/* prologue: function */
 6978               	/* frame size = 0 */
 6979               	/* stack size = 0 */
 6980               	.L__stack_usage = 0
 6981 18a4 462F      		mov r20,r22
 161:main.c        **** 	switch (usb_cmd){
 6982               		.loc 6 161 0
 6983 18a6 2091 0000 		lds r18,usb_cmd
 6984 18aa 213E      		cpi r18,lo8(-31)
 6985 18ac 01F0      		breq .L277
 6986               	.LVL413:
 6987 18ae 0895      		ret
 6988               	.L277:
 6989               		.loc 6 163 0
 6990 18b0 2091 0000 		lds r18,cmd_data
 6991 18b4 30E0      		ldi r19,lo8(0)
 6992 18b6 0024      		clr __tmp_reg__
 6993 18b8 3695      		lsr r19
 6994 18ba 2795      		ror r18
 6995 18bc 0794      		ror __tmp_reg__
 6996 18be 3695      		lsr r19
 6997 18c0 2795      		ror r18
 6998 18c2 0794      		ror __tmp_reg__
 6999 18c4 322F      		mov r19,r18
 7000 18c6 202D      		mov r18,__tmp_reg__
 7001 18c8 B901      		movw r22,r18
 7002 18ca 50E0      		ldi r21,lo8(0)
 7003 18cc 0E94 0000 		call __eeupd_block_x32a4u
 7004               	.LVL414:
 7005 18d0 0895      		ret
 7006               		.cfi_endproc
 7007               	.LFE82:
 7009               	.global	cmd_data
 7010               	.global	cmd_data
 7011               		.section .bss
 7014               	cmd_data:
 7015 0000 00        		.skip 1,0
 7016               	.global	usb_cmd
 7017               	.global	usb_cmd
 7020               	usb_cmd:
 7021 0001 00        		.skip 1,0
 7022               	.global	fwversion
 7023               		.section	.progmem.data,"a",@progbits
 7026               	fwversion:
 7027 0000 4657 5F56 		.string	"FW_VERSION"
 7027      4552 5349 
 7027      4F4E 00
 7028               	.global	hwversion
 7031               	hwversion:
 7032 000b 4857 5F56 		.string	"HW_VERSION"
 7032      4552 5349 
 7032      4F4E 00
 7033               		.comm gps,16,1
 7034               		.comm count,1,1
 7035               	.global	updating
 7036               	.global	updating
 7037               		.section .bss
 7040               	updating:
 7041 0002 00        		.skip 1,0
 7042               		.comm message,2,1
 7043               	.global	twilio_number
 7044               		.data
 7045               	.LC14:
 7046 006c 2B31 3330 		.string	"+13042493059"
 7046      3432 3439 
 7046      3330 3539 
 7046      00
 7049               	twilio_number:
 7050 0079 0000      		.word	.LC14
 7051               	.global	phonenumber
 7052               	.LC15:
 7053 007b 2B31 3835 		.string	"+18572080246"
 7053      3732 3038 
 7053      3032 3436 
 7053      00
 7056               	phonenumber:
 7057 0088 0000      		.word	.LC15
 7058               	.global	freq
 7059               	.global	freq
 7060               		.section .bss
 7063               	freq:
 7064 0003 00        		.skip 1,0
 7065               	.global	high_freq
 7066               		.data
 7069               	high_freq:
 7070 008a 3075      		.word	30000
 7071               	.global	low_freq
 7074               	low_freq:
 7075 008c 3075      		.word	30000
 7076               	.global	debug
 7077               	.global	debug
 7078               		.section .bss
 7081               	debug:
 7082 0004 00        		.skip 1,0
 7083               	.global	max_dist
 7084               		.data
 7087               	max_dist:
 7088 008e CD        		.byte	-51
 7089 008f CC        		.byte	-52
 7090 0090 4C        		.byte	76
 7091 0091 3E        		.byte	62
 7092               	.global	lng
 7095               	lng:
 7096 0092 00        		.byte	0
 7097 0093 00        		.byte	0
 7098 0094 92        		.byte	-110
 7099 0095 C2        		.byte	-62
 7100               	.global	lat
 7103               	lat:
 7104 0096 00        		.byte	0
 7105 0097 00        		.byte	0
 7106 0098 2C        		.byte	44
 7107 0099 42        		.byte	66
 7108               	.global	timeout_or_sampling_no_longer_enabled
 7109               	.global	timeout_or_sampling_no_longer_enabled
 7110               		.section .bss
 7113               	timeout_or_sampling_no_longer_enabled:
 7114 0005 00        		.skip 1,0
 7115               	.global	ep_in_data
 7116               	.global	ep_in_data
 7119               	ep_in_data:
 7120 0006 0000 0000 		.skip 4,0
 7121               	.global	ep_in_pipe_data
 7122               		.data
 7125               	ep_in_pipe_data:
 7126 009a 0000      		.word	ep_in_pipe_buffer
 7127 009c 0000      		.word	ep_in_pipe_buffer
 7128 009e 00        		.byte	0
 7129               		.comm ep_in_pipe_buffer,512,1
 7130               		.text
 7131               	.Letext0:
 7132               		.file 14 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/stdint.h"
 7133               		.file 15 "/usr/lib/gcc/avr/4.6.2/../../../avr/include/avr/iox32a4u.h"
 7134               		.file 16 "usb/StdRequestType.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccoslIJV.s:2      *ABS*:000000000000003f __SREG__
     /tmp/ccoslIJV.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/ccoslIJV.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/ccoslIJV.s:5      *ABS*:0000000000000034 __CCP__
     /tmp/ccoslIJV.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccoslIJV.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccoslIJV.s:15     .text:0000000000000000 EVENT_USB_Device_ConfigurationChanged
     /tmp/ccoslIJV.s:7125   .data:000000000000009a ep_in_pipe_data
                            *COM*:0000000000000200 ep_in_pipe_buffer
     /tmp/ccoslIJV.s:7119   .bss:0000000000000006 ep_in_data
     /tmp/ccoslIJV.s:108    .text:000000000000004e __vector_125
     /tmp/ccoslIJV.s:246    .text:00000000000000d8 __vector_126
     /tmp/ccoslIJV.s:7020   .bss:0000000000000001 usb_cmd
     /tmp/ccoslIJV.s:7014   .bss:0000000000000000 cmd_data
     /tmp/ccoslIJV.s:782    .text:00000000000002ea send_string
     /tmp/ccoslIJV.s:7113   .bss:0000000000000005 timeout_or_sampling_no_longer_enabled
     /tmp/ccoslIJV.s:1916   .text:00000000000006e2 concat
     /tmp/ccoslIJV.s:2010   .text:000000000000074e distance
     /tmp/ccoslIJV.s:7103   .data:0000000000000096 lat
     /tmp/ccoslIJV.s:7095   .data:0000000000000092 lng
     /tmp/ccoslIJV.s:2303   .text:000000000000090e parse_nmea_string
     /tmp/ccoslIJV.s:7087   .data:000000000000008e max_dist
     /tmp/ccoslIJV.s:2519   .text:0000000000000a3c parse_nmea
     /tmp/ccoslIJV.s:2817   .text:0000000000000bfa uart_putchar
     /tmp/ccoslIJV.s:2863   .text:0000000000000c1a uart_getchar
     /tmp/ccoslIJV.s:2889   .text:0000000000000c26 send_uart
     /tmp/ccoslIJV.s:7081   .bss:0000000000000004 debug
     /tmp/ccoslIJV.s:4106   .text:000000000000109c toggle_power_gps
     /tmp/ccoslIJV.s:4179   .text:00000000000010e0 gps_init
     /tmp/ccoslIJV.s:4345   .text:00000000000011a4 gps_receive
     /tmp/ccoslIJV.s:4739   .text:00000000000013dc wake_up_gprs
     /tmp/ccoslIJV.s:4756   .text:00000000000013de gprs_init
     /tmp/ccoslIJV.s:4805   .text:0000000000001402 send_message
     /tmp/ccoslIJV.s:5082   .text:000000000000153c GprsTextModeSMS
     /tmp/ccoslIJV.s:5110   .text:0000000000001548 PowerDownModem
     /tmp/ccoslIJV.s:5138   .text:0000000000001554 SleepModem
     /tmp/ccoslIJV.s:5166   .text:0000000000001560 WakeUpModem
     /tmp/ccoslIJV.s:5204   .text:000000000000156c SimpleReceive
     /tmp/ccoslIJV.s:5423   .text.startup:0000000000000000 main
                            *COM*:0000000000000010 gps
     /tmp/ccoslIJV.s:7063   .bss:0000000000000003 freq
     /tmp/ccoslIJV.s:7056   .data:0000000000000088 phonenumber
     /tmp/ccoslIJV.s:7049   .data:0000000000000079 twilio_number
     /tmp/ccoslIJV.s:6443   .text:000000000000165c EVENT_USB_Device_ControlRequest
                            *COM*:0000000000000002 message
     /tmp/ccoslIJV.s:7026   .progmem.data:0000000000000000 fwversion
     /tmp/ccoslIJV.s:7031   .progmem.data:000000000000000b hwversion
     /tmp/ccoslIJV.s:6972   .text:00000000000018a4 EVENT_USB_Device_ControlOUT
                            *COM*:0000000000000001 count
     /tmp/ccoslIJV.s:7040   .bss:0000000000000002 updating
     /tmp/ccoslIJV.s:7069   .data:000000000000008a high_freq
     /tmp/ccoslIJV.s:7074   .data:000000000000008c low_freq

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
endpoints
USB_Init
USB_HandleSetup
ep0_buf_out
__eeupd_block_x32a4u
malloc
strcpy
strcat
__subsf3
__mulsf3
sin
cos
__addsf3
sqrt
atan2
strtok
atof
__divsf3
__gtsf2
sprintf
USB_ConfigureClock
ep0_buf_in
__eerd_block_x32a4u
USB_ep0_send_progmem
